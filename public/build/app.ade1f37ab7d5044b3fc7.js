webpackJsonp([2],{

/***/ 1225:
/***/ (function(module, exports) {

/* ===================================================
 * bootstrap-transition.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#transitions
 * ===================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


  /* CSS TRANSITION SUPPORT (http://www.modernizr.com/)
   * ======================================================= */

  $(function () {

    $.support.transition = (function () {

      var transitionEnd = (function () {

        var el = document.createElement('bootstrap')
          , transEndEventNames = {
               'WebkitTransition' : 'webkitTransitionEnd'
            ,  'MozTransition'    : 'transitionend'
            ,  'OTransition'      : 'oTransitionEnd otransitionend'
            ,  'transition'       : 'transitionend'
            }
          , name

        for (name in transEndEventNames){
          if (el.style[name] !== undefined) {
            return transEndEventNames[name]
          }
        }

      }())

      return transitionEnd && {
        end: transitionEnd
      }

    })()

  })

}(window.jQuery);/* ==========================================================
 * bootstrap-alert.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#alerts
 * ==========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;

/* ============================================================
 * bootstrap-dropdown.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#dropdowns
 * ============================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


 /* DROPDOWN CLASS DEFINITION
  * ========================= */

  var toggle = '[data-toggle=dropdown]'
    , Dropdown = function (element) {
        var $el = $(element).on('click.dropdown.data-api', this.toggle)
        $('html').on('click.dropdown.data-api', function () {
          $el.parent().removeClass('open')
        })
      }

  Dropdown.prototype = {

    constructor: Dropdown

  , toggle: function (e) {
      var $this = $(this)
        , $parent
        , isActive

      if ($this.is('.disabled, :disabled')) return

      $parent = getParent($this)

      isActive = $parent.hasClass('open')

      clearMenus()

      if (!isActive) {
        if ('ontouchstart' in document.documentElement) {
          // if mobile we we use a backdrop because click events don't delegate
          $('<div class="dropdown-backdrop"/>').insertBefore($(this)).on('click', clearMenus)
        }
        $parent.toggleClass('open')
      }

      $this.focus()

      return false
    }

  , keydown: function (e) {
      var $this
        , $items
        , $active
        , $parent
        , isActive
        , index

      if (!/(38|40|27)/.test(e.keyCode)) return

      $this = $(this)

      e.preventDefault()
      e.stopPropagation()

      if ($this.is('.disabled, :disabled')) return

      $parent = getParent($this)

      isActive = $parent.hasClass('open')

      if (!isActive || (isActive && e.keyCode == 27)) {
        if (e.which == 27) $parent.find(toggle).focus()
        return $this.click()
      }

      $items = $('[role=menu] li:not(.divider):visible a', $parent)

      if (!$items.length) return

      index = $items.index($items.filter(':focus'))

      if (e.keyCode == 38 && index > 0) index--                                        // up
      if (e.keyCode == 40 && index < $items.length - 1) index++                        // down
      if (!~index) index = 0

      $items
        .eq(index)
        .focus()
    }

  }

  function clearMenus() {
    $('.dropdown-backdrop').remove()
    $(toggle).each(function () {
      getParent($(this)).removeClass('open')
    })
  }

  function getParent($this) {
    var selector = $this.attr('data-target')
      , $parent

    if (!selector) {
      selector = $this.attr('href')
      // grafana backport fix from bootstrap 3
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
    }

    $parent = selector && $(selector)

    if (!$parent || !$parent.length) $parent = $this.parent()

    return $parent
  }


  /* DROPDOWN PLUGIN DEFINITION
   * ========================== */

  var old = $.fn.dropdown

  $.fn.dropdown = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('dropdown')
      if (!data) $this.data('dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  $.fn.dropdown.Constructor = Dropdown


 /* DROPDOWN NO CONFLICT
  * ==================== */

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  /* APPLY TO STANDARD DROPDOWN ELEMENTS
   * =================================== */

  $(document)
    .on('click.dropdown.data-api', clearMenus)
    .on('click.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.dropdown.data-api'  , toggle, Dropdown.prototype.toggle)
    .on('keydown.dropdown.data-api', toggle + ', [role=menu]' , Dropdown.prototype.keydown)

}(window.jQuery);
/* =========================================================
 * bootstrap-modal.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#modals
 * =========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */


!function ($) {

  "use strict"; // jshint ;_;


 /* MODAL CLASS DEFINITION
  * ====================== */

  var Modal = function (element, options) {
    this.options = options
    this.$element = $(element)
      .delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this))
    this.options.remote && this.$element.find('.modal-body').load(this.options.remote)
  }

  Modal.prototype = {

      constructor: Modal

    , toggle: function () {
        return this[!this.isShown ? 'show' : 'hide']()
      }

    , show: function () {
        var that = this
          , e = $.Event('show')

        this.$element.trigger(e)

        if (this.isShown || e.isDefaultPrevented()) return

        this.isShown = true

        this.escape()

        this.backdrop(function () {
          var transition = $.support.transition && that.$element.hasClass('fade')

          if (!that.$element.parent().length) {
            that.$element.appendTo(document.body) //don't move modals dom position
          }

          that.$element.show()

          if (transition) {
            that.$element[0].offsetWidth // force reflow
          }

          that.$element
            .addClass('in')
            .attr('aria-hidden', false)

          that.enforceFocus()

          transition ?
            that.$element.one($.support.transition.end, function () { that.$element.focus().trigger('shown') }) :
            that.$element.focus().trigger('shown')

        })
      }

    , hide: function (e) {
        e && e.preventDefault()

        var that = this

        e = $.Event('hide')

        this.$element.trigger(e)

        if (!this.isShown || e.isDefaultPrevented()) return

        this.isShown = false

        this.escape()

        $(document).off('focusin.modal')

        this.$element
          .removeClass('in')
          .attr('aria-hidden', true)

        $.support.transition && this.$element.hasClass('fade') ?
          this.hideWithTransition() :
          this.hideModal()
      }

    , enforceFocus: function () {
        var that = this
        $(document).on('focusin.modal', function (e) {
          if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
            that.$element.focus()
          }
        })
      }

    , escape: function () {
        var that = this
        if (this.isShown && this.options.keyboard) {
          this.$element.on('keyup.dismiss.modal', function ( e ) {
            e.which == 27 && that.hide()
          })
        } else if (!this.isShown) {
          this.$element.off('keyup.dismiss.modal')
        }
      }

    , hideWithTransition: function () {
        var that = this
          , timeout = setTimeout(function () {
              that.$element.off($.support.transition.end)
              that.hideModal()
            }, 500)

        this.$element.one($.support.transition.end, function () {
          clearTimeout(timeout)
          that.hideModal()
        })
      }

    , hideModal: function () {
        var that = this
        this.$element.hide()
        this.backdrop(function () {
          that.removeBackdrop()
          that.$element.trigger('hidden')
        })
      }

    , removeBackdrop: function () {
        this.$backdrop && this.$backdrop.remove()
        this.$backdrop = null
      }

    , backdrop: function (callback) {
        var that = this
          , animate = this.$element.hasClass('fade') ? 'fade' : ''

        if (this.isShown && this.options.backdrop) {
          var doAnimate = $.support.transition && animate

          this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
            .appendTo(document.body)

          this.$backdrop.click(
            this.options.backdrop == 'static' ?
              $.proxy(this.$element[0].focus, this.$element[0])
            : $.proxy(this.hide, this)
          )

          if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

          this.$backdrop.addClass('in')

          if (!callback) return

          doAnimate ?
            this.$backdrop.one($.support.transition.end, callback) :
            callback()

        } else if (!this.isShown && this.$backdrop) {
          this.$backdrop.removeClass('in')

          $.support.transition && this.$element.hasClass('fade')?
            this.$backdrop.one($.support.transition.end, callback) :
            callback()

        } else if (callback) {
          callback()
        }
      }
  }


 /* MODAL PLUGIN DEFINITION
  * ======================= */

  var old = $.fn.modal

  $.fn.modal = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('modal')
        , options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option)
      if (!data) $this.data('modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option]()
      else if (options.show) data.show()
    })
  }

  $.fn.modal.defaults = {
      backdrop: true
    , keyboard: true
    , show: true
  }

  $.fn.modal.Constructor = Modal


 /* MODAL NO CONFLICT
  * ================= */

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


 /* MODAL DATA-API
  * ============== */

  $(document).on('click.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this = $(this)
      , href = $this.attr('href')
      , $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
      , option = $target.data('modal') ? 'toggle' : $.extend({ remote:!/#/.test(href) && href }, $target.data(), $this.data())

    e.preventDefault()

    $target
      .modal(option)
      .one('hide', function () {
        $this.focus()
      })
  })

}(window.jQuery);
/* ===========================================================
 * bootstrap-tooltip.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* TOOLTIP PUBLIC CLASS DEFINITION
  * =============================== */

  var Tooltip = function (element, options) {
    this.init('tooltip', element, options)
  }

  Tooltip.prototype = {

    constructor: Tooltip

  , init: function (type, element, options) {
      var eventIn
        , eventOut
        , triggers
        , trigger
        , i

      this.type = type
      this.$element = $(element)
      this.options = this.getOptions(options)
      this.enabled = true

      triggers = this.options.trigger.split(' ')

      for (i = triggers.length; i--;) {
        trigger = triggers[i]
        if (trigger == 'click') {
          this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
        } else if (trigger != 'manual') {
          eventIn = trigger == 'hover' ? 'mouseenter' : 'focus'
          eventOut = trigger == 'hover' ? 'mouseleave' : 'blur'
          this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
          this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
        }
      }

      this.options.selector ?
        (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
        this.fixTitle()
    }

  , getOptions: function (options) {
      options = $.extend({}, $.fn[this.type].defaults, this.$element.data(), options)

      if (options.delay && typeof options.delay == 'number') {
        options.delay = {
          show: options.delay
        , hide: options.delay
        }
      }

      return options
    }

  , enter: function (e) {
      var defaults = $.fn[this.type].defaults
        , options = {}
        , self

      this._options && $.each(this._options, function (key, value) {
        if (defaults[key] != value) options[key] = value
      }, this)

      self = $(e.currentTarget)[this.type](options).data(this.type)

      if (!self.options.delay || !self.options.delay.show) return self.show()

      clearTimeout(this.timeout)
      self.hoverState = 'in'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'in') self.show()
      }, self.options.delay.show)
    }

  , leave: function (e) {
      var self = $(e.currentTarget)[this.type](this._options).data(this.type)

      if (this.timeout) clearTimeout(this.timeout)
      if (!self.options.delay || !self.options.delay.hide) return self.hide()

      self.hoverState = 'out'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'out') self.hide()
      }, self.options.delay.hide)
    }

  , show: function () {
      var $tip
        , pos
        , actualWidth
        , actualHeight
        , placement
        , tp
        , e = $.Event('show')

      if (this.hasContent() && this.enabled) {
        this.$element.trigger(e)
        if (e.isDefaultPrevented()) return
        $tip = this.tip()
        this.setContent()

        if (this.options.animation) {
          $tip.addClass('fade')
        }

        placement = typeof this.options.placement == 'function' ?
          this.options.placement.call(this, $tip[0], this.$element[0]) :
          this.options.placement

        $tip
          .detach()
          .css({ top: 0, left: 0, display: 'block' })

        this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

        pos = this.getPosition()

        actualWidth = $tip[0].offsetWidth
        actualHeight = $tip[0].offsetHeight

        switch (placement) {
          case 'bottom':
            tp = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'top':
            tp = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'left':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth}
            break
          case 'right':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}
            break

          // extend placements (top)
          case 'topLeft':
            tp = {top: pos.top - actualHeight,  left: pos.left + pos.width / 2 - (actualWidth * .10)};
            break;
          case 'topRight':
            tp = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - (actualWidth * .90)};
            break;

          // extend placements (right)
          case 'rightTop':
            tp = {top: pos.top + pos.height / 2 - (actualHeight *.10), left: pos.left + pos.width};
            break;
          case 'rightBottom':
            tp = {top: pos.top + pos.height / 2 - (actualHeight * .90), left: pos.left + pos.width};
            break;

          // extend placements (bottom)
          case 'bottomLeft':
            tp = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - (actualWidth * .10)};
            break;
          case 'bottomRight':
            tp = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - (actualWidth * .90)};
            break;

          // extend placements (left)
          case 'leftTop':
            tp = {top: pos.top + pos.height / 2 - (actualHeight *.10), left: pos.left - actualWidth};
            break;
          case 'leftBottom':
            tp = {top: pos.top + pos.height / 2 - (actualHeight * .90), left: pos.left - actualWidth};
            break;


        }

        this.applyPlacement(tp, placement)
        this.$element.trigger('shown')
      }
    }

  , applyPlacement: function(offset, placement){
      var $tip = this.tip()
        , width = $tip[0].offsetWidth
        , height = $tip[0].offsetHeight
        , actualWidth
        , actualHeight
        , delta
        , replace

      $tip
        .offset(offset)
        .addClass(placement)
        .addClass('in')

      actualWidth = $tip[0].offsetWidth
      actualHeight = $tip[0].offsetHeight

      if (placement == 'top' && actualHeight != height) {
        offset.top = offset.top + height - actualHeight
        replace = true
      }

      if (placement == 'bottom' || placement == 'top') {
        delta = 0

        if (offset.left < 0){
          delta = offset.left * -2
          offset.left = 0
          $tip.offset(offset)
          actualWidth = $tip[0].offsetWidth
          actualHeight = $tip[0].offsetHeight
        }

        this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
      } else {
        this.replaceArrow(actualHeight - height, actualHeight, 'top')
      }

      if (replace) $tip.offset(offset)
    }

  , replaceArrow: function(delta, dimension, position){
      this
        .arrow()
        .css(position, delta ? (50 * (1 - delta / dimension) + "%") : '')
    }

  , setContent: function () {
      var $tip = this.tip()
        , title = this.getTitle()

      $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
      $tip.removeClass('fade in top bottom left right')
    }

  , hide: function () {
      var that = this
        , $tip = this.tip()
        , e = $.Event('hide')

      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return

      $tip.removeClass('in')

      function removeWithAnimation() {
        var timeout = setTimeout(function () {
          $tip.off($.support.transition.end).detach()
        }, 500)

        $tip.one($.support.transition.end, function () {
          clearTimeout(timeout)
          $tip.detach()
        })
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        removeWithAnimation() :
        $tip.detach()

      this.$element.trigger('hidden')

      return this
    }

  , fixTitle: function () {
      var $e = this.$element
      if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
        $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
      }
    }

  , hasContent: function () {
      return this.getTitle()
    }

  , getPosition: function () {
      var el = this.$element[0]
      return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
        width: el.offsetWidth
      , height: el.offsetHeight
      }, this.$element.offset())
    }

  , getTitle: function () {
      var title
        , $e = this.$element
        , o = this.options

      title = $e.attr('data-original-title')
        || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

      return title
    }

  , tip: function () {
      return this.$tip = this.$tip || $(this.options.template)
    }

  , arrow: function(){
      return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
    }

  , validate: function () {
      if (!this.$element[0].parentNode) {
        this.hide()
        this.$element = null
        this.options = null
      }
    }

  , enable: function () {
      this.enabled = true
    }

  , disable: function () {
      this.enabled = false
    }

  , toggleEnabled: function () {
      this.enabled = !this.enabled
    }

  , toggle: function (e) {
      var self = e ? $(e.currentTarget)[this.type](this._options).data(this.type) : this
      self.tip().hasClass('in') ? self.hide() : self.show()
    }

  , destroy: function () {
      this.hide().$element.off('.' + this.type).removeData(this.type)
    }

  }


 /* TOOLTIP PLUGIN DEFINITION
  * ========================= */

  var old = $.fn.tooltip

  $.fn.tooltip = function ( option ) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('tooltip')
        , options = typeof option == 'object' && option
      if (!data) $this.data('tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.tooltip.Constructor = Tooltip

  $.fn.tooltip.defaults = {
    animation: true
  , placement: 'top'
  , selector: false
  , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
  , trigger: 'hover focus'
  , title: ''
  , delay: 0
  , html: false
  , container: false
  }


 /* TOOLTIP NO CONFLICT
  * =================== */

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(window.jQuery);

/* ========================================================
 * bootstrap-tab.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#tabs
 * ========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* TAB CLASS DEFINITION
  * ==================== */

  var Tab = function (element) {
    this.element = $(element)
  }

  Tab.prototype = {

    constructor: Tab

  , show: function () {
      var $this = this.element
        , $ul = $this.closest('ul:not(.dropdown-menu)')
        , selector = $this.attr('data-target')
        , previous
        , $target
        , e

      if (!selector) {
        selector = $this.attr('href')
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
      }

      if ( $this.parent('li').hasClass('active') ) return

      previous = $ul.find('.active:last a')[0]

      e = $.Event('show', {
        relatedTarget: previous
      })

      $this.trigger(e)

      if (e.isDefaultPrevented()) return

      $target = $($.escapeSelector(selector))

      this.activate($this.parent('li'), $ul)
      this.activate($target, $target.parent(), function () {
        $this.trigger({
          type: 'shown'
        , relatedTarget: previous
        })
      })
    }

  , activate: function ( element, container, callback) {
      var $active = container.find('> .active')
        , transition = callback
            && $.support.transition
            && $active.hasClass('fade')

      function next() {
        $active
          .removeClass('active')
          .find('> .dropdown-menu > .active')
          .removeClass('active')

        element.addClass('active')

        if (transition) {
          element[0].offsetWidth // reflow for transition
          element.addClass('in')
        } else {
          element.removeClass('fade')
        }

        if ( element.parent('.dropdown-menu') ) {
          element.closest('li.dropdown').addClass('active')
        }

        callback && callback()
      }

      transition ?
        $active.one($.support.transition.end, next) :
        next()

      $active.removeClass('in')
    }
  }


 /* TAB PLUGIN DEFINITION
  * ===================== */

  var old = $.fn.tab

  $.fn.tab = function ( option ) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('tab')
      if (!data) $this.data('tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.tab.Constructor = Tab


 /* TAB NO CONFLICT
  * =============== */

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


 /* TAB DATA-API
  * ============ */

  $(document).on('click.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"]', function (e) {
    e.preventDefault()
    $(this).tab('show')
  })

}(window.jQuery);/* =============================================================
 * bootstrap-typeahead.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#typeahead
 * =============================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function($){

  "use strict"; // jshint ;_;


 /* TYPEAHEAD PUBLIC CLASS DEFINITION
  * ================================= */

  var Typeahead = function (element, options) {
    this.$element = $(element)
    this.options = $.extend({}, $.fn.typeahead.defaults, options)
    this.matcher = this.options.matcher || this.matcher
    this.sorter = this.options.sorter || this.sorter
    this.highlighter = this.options.highlighter || this.highlighter
    this.updater = this.options.updater || this.updater
    this.source = this.options.source
    this.$menu = $(this.options.menu)
    this.shown = false
    this.listen()
  }

  Typeahead.prototype = {

    constructor: Typeahead

  , select: function () {
    // CHANGE (rashidkpc) If nothing is selected, use existing value
      var val = this.$menu.find('.active').attr('data-value') || this.$element.val();
      this.$element
        .val(this.updater(val))
        .change()
      return this.hide()
    }

  , updater: function (item) {
      return item
    }

  , show: function () {
      var pos = $.extend({}, this.$element.position(), {
        height: this.$element[0].offsetHeight
      })

      this.$menu
        .insertAfter(this.$element)
        .css({
          top: pos.top + pos.height
        , left: pos.left
        })
        .show()

      this.shown = true
      return this
    }

  , hide: function () {
      this.$menu.hide()
      this.shown = false
      return this
    }

  , lookup: function (event) {
      var items

      this.query = this.$element.val()

      if (!this.query || this.query.length < this.options.minLength) {
        return this.shown ? this.hide() : this
      }

      items = $.isFunction(this.source) ? this.source(this.query, $.proxy(this.process, this)) : this.source

      return items ? this.process(items) : this
    }

    , process: function (items) {
      var that = this

      items = $.grep(items, function (item) {
        return that.matcher(item)
      })

      items = this.sorter(items)

      if (!items.length) {
        return this.shown ? this.hide() : this
      }

      return this.render(items.slice(0, this.options.items)).show()
    }

  , matcher: function (item) {
      return ~item.toLowerCase().indexOf(this.query.toLowerCase())
    }

  , sorter: function (items) {
      var beginswith = []
        , caseSensitive = []
        , caseInsensitive = []
        , item

      while (item = items.shift()) {
        if (!item.toLowerCase().indexOf(this.query.toLowerCase())) beginswith.push(item)
        else if (~item.indexOf(this.query)) caseSensitive.push(item)
        else caseInsensitive.push(item)
      }

      return beginswith.concat(caseSensitive, caseInsensitive)
    }

  , highlighter: function (item) {
      var query = this.query.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&')
      if (!query) {
        return item;
      }
      return item.replace(new RegExp('(' + query + ')', 'ig'), function ($1, match) {
        return '<strong>' + match + '</strong>'
      });
    }

  , render: function (items) {
      var that = this

      items = $(items).map(function (i, item) {
        i = $(that.options.item).attr('data-value', item)
        i.find('a').html(that.highlighter(item))
        return i[0]
      })

      // CHANGE (rashidpc) Do not select first element by default
      // items.first().addClass('active')
      this.$menu.html(items)
      return this
    }

  , next: function (event) {
      var active = this.$menu.find('.active').removeClass('active')
        , next = active.next()

      if (!next.length) {
        next = $(this.$menu.find('li')[0])
      }

      next.addClass('active')
    }

  , prev: function (event) {
      var active = this.$menu.find('.active').removeClass('active')
        , prev = active.prev()

      if (!prev.length) {
        prev = this.$menu.find('li').last()
      }

      prev.addClass('active')
    }

  , listen: function () {
      this.$element
        .on('focus',    $.proxy(this.focus, this))
        .on('blur',     $.proxy(this.blur, this))
        .on('keypress', $.proxy(this.keypress, this))
        .on('keyup',    $.proxy(this.keyup, this))

      if (this.eventSupported('keydown')) {
        this.$element.on('keydown', $.proxy(this.keydown, this))
      }

      this.$menu
        .on('click', $.proxy(this.click, this))
        .on('mouseenter', 'li', $.proxy(this.mouseenter, this))
        .on('mouseleave', 'li', $.proxy(this.mouseleave, this))
    },

    destroy: function () {
      this.$element.off().removeData('typeahead');
      this.$menu.off();
    }

  , eventSupported: function(eventName) {
      var isSupported = eventName in this.$element
      if (!isSupported) {
        this.$element.setAttribute(eventName, 'return;')
        isSupported = typeof this.$element[eventName] === 'function'
      }
      return isSupported
    }

  , move: function (e) {
      if (!this.shown) return

      // grafana change, shift+left parenthesis
      if (e.shiftKey && e.keyCode === 40) {
        return;
      }

      switch(e.keyCode) {
        case 9: // tab
        case 13: // enter
        case 27: // escape
          e.preventDefault()
          break

        case 38: // up arrow
          e.preventDefault()
          this.prev()
          break

        case 40: // down arrow
          e.preventDefault()
          this.next()
          break
      }

      e.stopPropagation()
    }

  , keydown: function (e) {
      this.suppressKeyPressRepeat = ~$.inArray(e.keyCode, [40,38,9,13,27,57])
      this.move(e)
    }

  , keypress: function (e) {
      if (this.suppressKeyPressRepeat) return
      this.move(e)
    }

  , keyup: function (e) {
      switch(e.keyCode) {
        case 40: // down arrow
        case 38: // up arrow
        case 16: // shift
        case 17: // ctrl
        case 18: // alt
          break

        case 9: // tab
        case 13: // enter
          if (!this.shown) return
          this.select()
          break

        case 27: // escape
          if (!this.shown) return
          this.hide()
          break

        default:
          this.lookup();
      }

      if(e.keyCode === 13 && typeof this.$menu.find('.active').attr('data-value') === 'undefined') {
        // CHANGE (rashidkpc). Enter was hit, nothing was selected from typeahead, submit form
        this.$element.submit();
      } else {
        e.stopPropagation()
        e.preventDefault()
      }

  }

  , focus: function (e) {
      this.focused = true
    }

  , blur: function (e) {
      this.focused = false
      if (!this.mousedover && this.shown) this.hide()
    }

  , click: function (e) {
      e.stopPropagation()
      e.preventDefault()
      this.select()
      this.$element.focus()
    }

  , mouseenter: function (e) {
      this.mousedover = true
      this.$menu.find('.active').removeClass('active')
      $(e.currentTarget).addClass('active')
    }

  , mouseleave: function (e) {
      this.mousedover = false
      if (!this.focused && this.shown) this.hide()
    }

  }


  /* TYPEAHEAD PLUGIN DEFINITION
   * =========================== */

  var old = $.fn.typeahead

  $.fn.typeahead = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('typeahead')
        , options = typeof option == 'object' && option
      if (!data) $this.data('typeahead', (data = new Typeahead(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.typeahead.defaults = {
    source: []
  , items: 8
  , menu: '<ul class="typeahead dropdown-menu"></ul>'
  , item: '<li><a href="#"></a></li>'
  , minLength: 1
  }

  $.fn.typeahead.Constructor = Typeahead


 /* TYPEAHEAD NO CONFLICT
  * =================== */

  $.fn.typeahead.noConflict = function () {
    $.fn.typeahead = old
    return this
  }


 /* TYPEAHEAD DATA-API
  * ================== */

  $(document).on('focus.typeahead.data-api', '[data-provide="typeahead"]', function (e) {
    var $this = $(this)
    if ($this.data('typeahead')) return
    $this.typeahead($this.data())
  })

}(window.jQuery);
/* ==========================================================
 * bootstrap-affix.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#affix
 * ==========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* AFFIX CLASS DEFINITION
  * ====================== */

  var Affix = function (element, options) {
    this.options = $.extend({}, $.fn.affix.defaults, options)
    this.$window = $(window)
      .on('scroll.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.affix.data-api',  $.proxy(function () { setTimeout($.proxy(this.checkPosition, this), 1) }, this))
    this.$element = $(element)
    this.checkPosition()
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var scrollHeight = $(document).height()
      , scrollTop = this.$window.scrollTop()
      , position = this.$element.offset()
      , offset = this.options.offset
      , offsetBottom = offset.bottom
      , offsetTop = offset.top
      , reset = 'affix affix-top affix-bottom'
      , affix

    if (typeof offset != 'object') offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function') offsetTop = offset.top()
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom()

    affix = this.unpin != null && (scrollTop + this.unpin <= position.top) ?
      false    : offsetBottom != null && (position.top + this.$element.height() >= scrollHeight - offsetBottom) ?
      'bottom' : offsetTop != null && scrollTop <= offsetTop ?
      'top'    : false

    if (this.affixed === affix) return

    this.affixed = affix
    this.unpin = affix == 'bottom' ? position.top - scrollTop : null

    this.$element.removeClass(reset).addClass('affix' + (affix ? '-' + affix : ''))
  }


 /* AFFIX PLUGIN DEFINITION
  * ======================= */

  var old = $.fn.affix

  $.fn.affix = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('affix')
        , options = typeof option == 'object' && option
      if (!data) $this.data('affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.affix.Constructor = Affix

  $.fn.affix.defaults = {
    offset: 0
  }


 /* AFFIX NO CONFLICT
  * ================= */

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


 /* AFFIX DATA-API
  * ============== */

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
        , data = $spy.data()

      data.offset = data.offset || {}

      data.offsetBottom && (data.offset.bottom = data.offsetBottom)
      data.offsetTop && (data.offset.top = data.offsetTop)

      $spy.affix(data)
    })
  })


}(window.jQuery);

/* =============================================================
 * bootstrap-collapse.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#collapse
 * =============================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function ($) {

  "use strict"; // jshint ;_;


 /* COLLAPSE PUBLIC CLASS DEFINITION
  * ================================ */

  var Collapse = function (element, options) {
    this.$element = $(element)
    this.options = $.extend({}, $.fn.collapse.defaults, options)

    if (this.options.parent) {
      this.$parent = $(this.options.parent)
    }

    this.options.toggle && this.toggle()
  }

  Collapse.prototype = {

    constructor: Collapse

  , dimension: function () {
      var hasWidth = this.$element.hasClass('width')
      return hasWidth ? 'width' : 'height'
    }

  , show: function () {
      var dimension
        , scroll
        , actives
        , hasData

      if (this.transitioning || this.$element.hasClass('in')) return

      dimension = this.dimension()
      scroll = $.camelCase(['scroll', dimension].join('-'))
      actives = this.$parent && this.$parent.find('> .accordion-group > .in')

      if (actives && actives.length) {
        hasData = actives.data('collapse')
        if (hasData && hasData.transitioning) return
        actives.collapse('hide')
        hasData || actives.data('collapse', null)
      }

      this.$element[dimension](0)
      this.transition('addClass', $.Event('show'), 'shown')
      $.support.transition && this.$element[dimension](this.$element[0][scroll])
    }

  , hide: function () {
      var dimension
      if (this.transitioning || !this.$element.hasClass('in')) return
      dimension = this.dimension()
      this.reset(this.$element[dimension]())
      this.transition('removeClass', $.Event('hide'), 'hidden')
      this.$element[dimension](0)
    }

  , reset: function (size) {
      var dimension = this.dimension()

      this.$element
        .removeClass('collapse')
        [dimension](size || 'auto')
        [0].offsetWidth

      this.$element[size !== null ? 'addClass' : 'removeClass']('collapse')

      return this
    }

  , transition: function (method, startEvent, completeEvent) {
      var that = this
        , complete = function () {
            if (startEvent.type == 'show') that.reset()
            that.transitioning = 0
            that.$element.trigger(completeEvent)
          }

      this.$element.trigger(startEvent)

      if (startEvent.isDefaultPrevented()) return

      this.transitioning = 1

      this.$element[method]('in')

      $.support.transition && this.$element.hasClass('collapse') ?
        this.$element.one($.support.transition.end, complete) :
        complete()
    }

  , toggle: function () {
      this[this.$element.hasClass('in') ? 'hide' : 'show']()
    }

  }


 /* COLLAPSE PLUGIN DEFINITION
  * ========================== */

  var old = $.fn.collapse

  $.fn.collapse = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('collapse')
        , options = $.extend({}, $.fn.collapse.defaults, $this.data(), typeof option == 'object' && option)
      if (!data) $this.data('collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.collapse.defaults = {
    toggle: true
  }

  $.fn.collapse.Constructor = Collapse


 /* COLLAPSE NO CONFLICT
  * ==================== */

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


 /* COLLAPSE DATA-API
  * ================= */

  $(document).on('click.collapse.data-api', '[data-toggle=collapse]', function (e) {
    var $this = $(this), href
      , target = $this.attr('data-target')
        || e.preventDefault()
        || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') //strip for ie7
      , option = $(target).data('collapse') ? 'toggle' : $this.data()
    $this[$(target).hasClass('in') ? 'addClass' : 'removeClass']('collapsed')
    $(target).collapse(option)
  })

}(window.jQuery);


/***/ }),

/***/ 1226:
/***/ (function(module, exports) {

/**
 * angular-strap
 * @version v2.3.12 - 2017-01-26
 * @link http://mgcrea.github.io/angular-strap
 * @author Olivier Louvignes <olivier@mg-crea.com> (https://github.com/mgcrea)
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
(function(window, document, undefined) {
  'use strict';
  bsCompilerService.$inject = [ '$q', '$http', '$injector', '$compile', '$controller', '$templateCache' ];
  angular.module('mgcrea.ngStrap.typeahead', [ 'mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions' ]).provider('$typeahead', function() {
    var defaults = this.defaults = {
      animation: 'am-fade',
      prefixClass: 'typeahead',
      prefixEvent: '$typeahead',
      placement: 'bottom-left',
      templateUrl: 'typeahead/typeahead.tpl.html',
      trigger: 'focus',
      container: false,
      keyboard: true,
      html: false,
      delay: 0,
      minLength: 1,
      filter: 'bsAsyncFilter',
      limit: 6,
      autoSelect: false,
      comparator: '',
      trimValue: true
    };
    this.$get = [ '$window', '$rootScope', '$tooltip', '$$rAF', '$timeout', function($window, $rootScope, $tooltip, $$rAF, $timeout) {
      function TypeaheadFactory(element, controller, config) {
        var $typeahead = {};
        var options = angular.extend({}, defaults, config);
        $typeahead = $tooltip(element, options);
        var parentScope = config.scope;
        var scope = $typeahead.$scope;
        scope.$resetMatches = function() {
          scope.$matches = [];
          scope.$activeIndex = options.autoSelect ? 0 : -1;
        };
        scope.$resetMatches();
        scope.$activate = function(index) {
          scope.$$postDigest(function() {
            $typeahead.activate(index);
          });
        };
        scope.$select = function(index, evt) {
          scope.$$postDigest(function() {
            $typeahead.select(index);
          });
        };
        scope.$isVisible = function() {
          return $typeahead.$isVisible();
        };
        $typeahead.update = function(matches) {
          scope.$matches = matches;
          if (scope.$activeIndex >= matches.length) {
            scope.$activeIndex = options.autoSelect ? 0 : -1;
          }
          safeDigest(scope);
          $$rAF($typeahead.$applyPlacement);
        };
        $typeahead.activate = function(index) {
          scope.$activeIndex = index;
        };
        $typeahead.select = function(index) {
          if (index === -1) return;
          var value = scope.$matches[index].value;
          controller.$setViewValue(value);
          controller.$render();
          scope.$resetMatches();
          if (parentScope) parentScope.$digest();
          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);
          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {
            options.onSelect(value, index, $typeahead);
          }
        };
        $typeahead.$isVisible = function() {
          if (!options.minLength || !controller) {
            return !!scope.$matches.length;
          }
          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;
        };
        $typeahead.$getIndex = function(value) {
          var index;
          for (index = scope.$matches.length; index--; ) {
            if (angular.equals(scope.$matches[index].value, value)) break;
          }
          return index;
        };
        $typeahead.$onMouseDown = function(evt) {
          evt.preventDefault();
          evt.stopPropagation();
        };
        $typeahead.$$updateScrollTop = function(container, index) {
          if (index > -1 && index < container.children.length) {
            var active = container.children[index];
            var clientTop = active.offsetTop;
            var clientBottom = active.offsetTop + active.clientHeight;
            var highWatermark = container.scrollTop;
            var lowWatermark = container.scrollTop + container.clientHeight;
            if (clientBottom >= highWatermark && clientTop < highWatermark) {
              container.scrollTop = Math.max(0, container.scrollTop - container.clientHeight);
            } else if (clientBottom > lowWatermark) {
              container.scrollTop = clientTop;
            }
          }
        };
        $typeahead.$onKeyDown = function(evt) {
          if (!/(38|40|13)/.test(evt.keyCode)) return;
          if ($typeahead.$isVisible() && !(evt.keyCode === 13 && scope.$activeIndex === -1)) {
            evt.preventDefault();
            evt.stopPropagation();
          }
          if (evt.keyCode === 13 && scope.$matches.length) {
            $typeahead.select(scope.$activeIndex);
          } else if (evt.keyCode === 38 && scope.$activeIndex > 0) {
            scope.$activeIndex--;
          } else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) {
            scope.$activeIndex++;
          } else if (angular.isUndefined(scope.$activeIndex)) {
            scope.$activeIndex = 0;
          }
          $typeahead.$$updateScrollTop($typeahead.$element[0], scope.$activeIndex);
          scope.$digest();
        };
        var show = $typeahead.show;
        $typeahead.show = function() {
          show();
          $timeout(function() {
            if ($typeahead.$element) {
              $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);
              if (options.keyboard) {
                if (element) element.on('keydown', $typeahead.$onKeyDown);
              }
            }
          }, 0, false);
        };
        var hide = $typeahead.hide;
        $typeahead.hide = function() {
          if ($typeahead.$element) $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);
          if (options.keyboard) {
            if (element) element.off('keydown', $typeahead.$onKeyDown);
          }
          if (!options.autoSelect) {
            $typeahead.activate(-1);
          }
          hide();
        };
        return $typeahead;
      }
      function safeDigest(scope) {
        scope.$$phase || scope.$root && scope.$root.$$phase || scope.$digest();
      }
      TypeaheadFactory.defaults = defaults;
      return TypeaheadFactory;
    } ];
  }).filter('bsAsyncFilter', [ '$filter', function($filter) {
    return function(array, expression, comparator) {
      if (array && angular.isFunction(array.then)) {
        return array.then(function(results) {
          return $filter('filter')(results, expression, comparator);
        });
      }
      return $filter('filter')(array, expression, comparator);
    };
  } ]).directive('bsTypeahead', [ '$window', '$parse', '$q', '$typeahead', '$parseOptions', function($window, $parse, $q, $typeahead, $parseOptions) {
    var defaults = $typeahead.defaults;
    return {
      restrict: 'EAC',
      require: 'ngModel',
      link: function postLink(scope, element, attr, controller) {
        element.off('change');
        var options = {
          scope: scope
        };
        angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass' ], function(key) {
          if (angular.isDefined(attr[key])) options[key] = attr[key];
        });
        var falseValueRegExp = /^(false|0|)$/i;
        angular.forEach([ 'html', 'container', 'trimValue', 'filter' ], function(key) {
          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;
        });
        angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect' ], function(key) {
          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);
          if (angular.isDefined(attr[bsKey])) {
            options[key] = scope.$eval(attr[bsKey]);
          }
        });
        if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');
        var filter = angular.isDefined(options.filter) ? options.filter : defaults.filter;
        var limit = options.limit || defaults.limit;
        var comparator = options.comparator || defaults.comparator;
        var bsOptions = attr.bsOptions;
        if (filter) {
          bsOptions += ' | ' + filter + ':$viewValue';
          if (comparator) bsOptions += ':' + comparator;
        }
        if (limit) bsOptions += ' | limitTo:' + limit;
        var parsedOptions = $parseOptions(bsOptions);
        var typeahead = $typeahead(element, controller, options);
        if (options.watchOptions) {
          var watchedOptions = parsedOptions.$match[7].replace(/\|.+/, '').replace(/\(.*\)/g, '').trim();
          scope.$watchCollection(watchedOptions, function(newValue, oldValue) {
            parsedOptions.valuesFn(scope, controller).then(function(values) {
              typeahead.update(values);
              controller.$render();
            });
          });
        }
        scope.$watch(attr.ngModel, function(newValue, oldValue) {
          scope.$modelValue = newValue;
          parsedOptions.valuesFn(scope, controller).then(function(values) {
            if (options.selectMode && !values.length && newValue.length > 0) {
              controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));
              return;
            }
            if (values.length > limit) values = values.slice(0, limit);
            typeahead.update(values);
            controller.$render();
          });
        });
        controller.$formatters.push(function(modelValue) {
          var displayValue = parsedOptions.displayValue(modelValue);
          if (displayValue) {
            return displayValue;
          }
          if (angular.isDefined(modelValue) && typeof modelValue !== 'object') {
            return modelValue;
          }
          return '';
        });
        controller.$render = function() {
          if (controller.$isEmpty(controller.$viewValue)) {
            return element.val('');
          }
          var index = typeahead.$getIndex(controller.$modelValue);
          var selected = index !== -1 ? typeahead.$scope.$matches[index].label : controller.$viewValue;
          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;
          var value = selected ? selected.toString().replace(/<(?:.|\n)*?>/gm, '') : '';
          var ss = element[0].selectionStart;
          var sd = element[0].selectionEnd;
          element.val(options.trimValue === false ? value : value.trim());
          element[0].setSelectionRange(ss, sd);
        };
        scope.$on('$destroy', function() {
          if (typeahead) typeahead.destroy();
          options = null;
          typeahead = null;
        });
      }
    };
  } ]);
  angular.module('mgcrea.ngStrap.tooltip', [ 'mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions' ]).provider('$tooltip', function() {
    var defaults = this.defaults = {
      animation: 'am-fade',
      customClass: '',
      prefixClass: 'tooltip',
      prefixEvent: 'tooltip',
      container: false,
      target: false,
      placement: 'top',
      templateUrl: 'tooltip/tooltip.tpl.html',
      template: '',
      titleTemplate: false,
      trigger: 'hover focus',
      keyboard: false,
      html: false,
      show: false,
      title: '',
      type: '',
      delay: 0,
      autoClose: false,
      bsEnabled: true,
      mouseDownPreventDefault: true,
      mouseDownStopPropagation: true,
      viewport: {
        selector: 'body',
        padding: 0
      }
    };
    this.$get = [ '$window', '$rootScope', '$bsCompiler', '$q', '$templateCache', '$http', '$animate', '$sce', 'dimensions', '$$rAF', '$timeout', function($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {
      var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);
      var isTouch = 'createTouch' in $window.document && isNative;
      var $body = angular.element($window.document);
      function TooltipFactory(element, config) {
        var $tooltip = {};
        var options = $tooltip.$options = angular.extend({}, defaults, config);
        var promise = $tooltip.$promise = $bsCompiler.compile(options);
        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();
        var nodeName = element[0].nodeName.toLowerCase();
        if (options.delay && angular.isString(options.delay)) {
          var split = options.delay.split(',').map(parseFloat);
          options.delay = split.length > 1 ? {
            show: split[0],
            hide: split[1]
          } : split[0];
        }
        $tooltip.$id = options.id || element.attr('id') || '';
        if (options.title) {
          scope.title = $sce.trustAsHtml(options.title);
        }
        scope.$setEnabled = function(isEnabled) {
          scope.$$postDigest(function() {
            $tooltip.setEnabled(isEnabled);
          });
        };
        scope.$hide = function() {
          scope.$$postDigest(function() {
            $tooltip.hide();
          });
        };
        scope.$show = function() {
          scope.$$postDigest(function() {
            $tooltip.show();
          });
        };
        scope.$toggle = function() {
          scope.$$postDigest(function() {
            $tooltip.toggle();
          });
        };
        $tooltip.$isShown = scope.$isShown = false;
        var timeout;
        var hoverState;
        var compileData;
        var tipElement;
        var tipContainer;
        var tipScope;
        promise.then(function(data) {
          compileData = data;
          $tooltip.init();
        });
        $tooltip.init = function() {
          if (options.delay && angular.isNumber(options.delay)) {
            options.delay = {
              show: options.delay,
              hide: options.delay
            };
          }
          if (options.container === 'self') {
            tipContainer = element;
          } else if (angular.isElement(options.container)) {
            tipContainer = options.container;
          } else if (options.container) {
            tipContainer = findElement(options.container);
          }
          bindTriggerEvents();
          if (options.target) {
            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);
          }
          if (options.show) {
            scope.$$postDigest(function() {
              if (options.trigger === 'focus') {
                element[0].focus();
              } else {
                $tooltip.show();
              }
            });
          }
        };
        $tooltip.destroy = function() {
          unbindTriggerEvents();
          destroyTipElement();
          scope.$destroy();
        };
        $tooltip.enter = function() {
          clearTimeout(timeout);
          hoverState = 'in';
          if (!options.delay || !options.delay.show) {
            return $tooltip.show();
          }
          timeout = setTimeout(function() {
            if (hoverState === 'in') $tooltip.show();
          }, options.delay.show);
        };
        $tooltip.show = function() {
          if (!options.bsEnabled || $tooltip.$isShown) return;
          scope.$emit(options.prefixEvent + '.show.before', $tooltip);
          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {
            options.onBeforeShow($tooltip);
          }
          var parent;
          var after;
          if (options.container) {
            parent = tipContainer;
            if (tipContainer[0].lastChild) {
              after = angular.element(tipContainer[0].lastChild);
            } else {
              after = null;
            }
          } else {
            parent = null;
            after = element;
          }
          if (tipElement) destroyTipElement();
          tipScope = $tooltip.$scope.$new();
          tipElement = $tooltip.$element = compileData.link(tipScope, function(clonedElement, scope) {});
          tipElement.css({
            top: '-9999px',
            left: '-9999px',
            right: 'auto',
            display: 'block',
            visibility: 'hidden'
          });
          if (options.animation) tipElement.addClass(options.animation);
          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);
          if (options.customClass) tipElement.addClass(options.customClass);
          if (after) {
            after.after(tipElement);
          } else {
            parent.prepend(tipElement);
          }
          $tooltip.$isShown = scope.$isShown = true;
          safeDigest(scope);
          $tooltip.$applyPlacement();
          if (angular.version.minor <= 2) {
            $animate.enter(tipElement, parent, after, enterAnimateCallback);
          } else {
            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);
          }
          safeDigest(scope);
          $$rAF(function() {
            if (tipElement) tipElement.css({
              visibility: 'visible'
            });
            if (options.keyboard) {
              if (options.trigger !== 'focus') {
                $tooltip.focus();
              }
              bindKeyboardEvents();
            }
          });
          if (options.autoClose) {
            bindAutoCloseEvents();
          }
        };
        function enterAnimateCallback() {
          scope.$emit(options.prefixEvent + '.show', $tooltip);
          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {
            options.onShow($tooltip);
          }
        }
        $tooltip.leave = function() {
          clearTimeout(timeout);
          hoverState = 'out';
          if (!options.delay || !options.delay.hide) {
            return $tooltip.hide();
          }
          timeout = setTimeout(function() {
            if (hoverState === 'out') {
              $tooltip.hide();
            }
          }, options.delay.hide);
        };
        var _blur;
        var _tipToHide;
        $tooltip.hide = function(blur) {
          if (!$tooltip.$isShown) return;
          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);
          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {
            options.onBeforeHide($tooltip);
          }
          _blur = blur;
          _tipToHide = tipElement;
          if (tipElement !== null) {
            if (angular.version.minor <= 2) {
              $animate.leave(tipElement, leaveAnimateCallback);
            } else {
              $animate.leave(tipElement).then(leaveAnimateCallback);
            }
          }
          $tooltip.$isShown = scope.$isShown = false;
          safeDigest(scope);
          if (options.keyboard && tipElement !== null) {
            unbindKeyboardEvents();
          }
          if (options.autoClose && tipElement !== null) {
            unbindAutoCloseEvents();
          }
        };
        function leaveAnimateCallback() {
          scope.$emit(options.prefixEvent + '.hide', $tooltip);
          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {
            options.onHide($tooltip);
          }
          if (tipElement === _tipToHide) {
            if (_blur && options.trigger === 'focus') {
              return element[0].blur();
            }
            destroyTipElement();
          }
        }
        $tooltip.toggle = function(evt) {
          if (evt) {
            evt.preventDefault();
          }
          if ($tooltip.$isShown) {
            $tooltip.leave();
          } else {
            $tooltip.enter();
          }
        };
        $tooltip.focus = function() {
          tipElement[0].focus();
        };
        $tooltip.setEnabled = function(isEnabled) {
          options.bsEnabled = isEnabled;
        };
        $tooltip.setViewport = function(viewport) {
          options.viewport = viewport;
        };
        $tooltip.$applyPlacement = function() {
          if (!tipElement) return;
          var placement = options.placement;
          var autoToken = /\s?auto?\s?/i;
          var autoPlace = autoToken.test(placement);
          if (autoPlace) {
            placement = placement.replace(autoToken, '') || defaults.placement;
          }
          tipElement.addClass(options.placement);
          var elementPosition = getPosition();
          var tipWidth = tipElement.prop('offsetWidth');
          var tipHeight = tipElement.prop('offsetHeight');
          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);
          if (autoPlace) {
            var originalPlacement = placement;
            var viewportPosition = getPosition($tooltip.$viewport);
            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {
              placement = originalPlacement.replace('bottom', 'top');
            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {
              placement = originalPlacement.replace('top', 'bottom');
            }
            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {
              placement = placement.replace('left', 'right');
            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {
              placement = placement.replace('right', 'left');
            }
            tipElement.removeClass(originalPlacement).addClass(placement);
          }
          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);
          applyPlacement(tipPosition, placement);
        };
        $tooltip.$onKeyUp = function(evt) {
          if (evt.which === 27 && $tooltip.$isShown) {
            $tooltip.hide();
            evt.stopPropagation();
          }
        };
        $tooltip.$onFocusKeyUp = function(evt) {
          if (evt.which === 27) {
            element[0].blur();
            evt.stopPropagation();
          }
        };
        $tooltip.$onFocusElementMouseDown = function(evt) {
          if (options.mouseDownPreventDefault) {
            evt.preventDefault();
          }
          if (options.mouseDownStopPropagation) {
            evt.stopPropagation();
          }
          if ($tooltip.$isShown) {
            element[0].blur();
          } else {
            element[0].focus();
          }
        };
        function bindTriggerEvents() {
          var triggers = options.trigger.split(' ');
          angular.forEach(triggers, function(trigger) {
            if (trigger === 'click' || trigger === 'contextmenu') {
              element.on(trigger, $tooltip.toggle);
            } else if (trigger !== 'manual') {
              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);
              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);
              if (nodeName === 'button' && trigger !== 'hover') {
                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);
              }
            }
          });
        }
        function unbindTriggerEvents() {
          var triggers = options.trigger.split(' ');
          for (var i = triggers.length; i--; ) {
            var trigger = triggers[i];
            if (trigger === 'click' || trigger === 'contextmenu') {
              element.off(trigger, $tooltip.toggle);
            } else if (trigger !== 'manual') {
              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);
              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);
              if (nodeName === 'button' && trigger !== 'hover') {
                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);
              }
            }
          }
        }
        function bindKeyboardEvents() {
          if (options.trigger !== 'focus') {
            tipElement.on('keyup', $tooltip.$onKeyUp);
          } else {
            element.on('keyup', $tooltip.$onFocusKeyUp);
          }
        }
        function unbindKeyboardEvents() {
          if (options.trigger !== 'focus') {
            tipElement.off('keyup', $tooltip.$onKeyUp);
          } else {
            element.off('keyup', $tooltip.$onFocusKeyUp);
          }
        }
        var _autoCloseEventsBinded = false;
        function bindAutoCloseEvents() {
          $timeout(function() {
            tipElement.on('click', stopEventPropagation);
            $body.on('click', $tooltip.hide);
            _autoCloseEventsBinded = true;
          }, 0, false);
        }
        function unbindAutoCloseEvents() {
          if (_autoCloseEventsBinded) {
            tipElement.off('click', stopEventPropagation);
            $body.off('click', $tooltip.hide);
            _autoCloseEventsBinded = false;
          }
        }
        function stopEventPropagation(event) {
          event.stopPropagation();
        }
        function getPosition($element) {
          $element = $element || (options.target || element);
          var el = $element[0];
          var isBody = el.tagName === 'BODY';
          var elRect = el.getBoundingClientRect();
          var rect = {};
          for (var p in elRect) {
            rect[p] = elRect[p];
          }
          if (rect.width === null) {
            rect = angular.extend({}, rect, {
              width: elRect.right - elRect.left,
              height: elRect.bottom - elRect.top
            });
          }
          var elOffset = isBody ? {
            top: 0,
            left: 0
          } : dimensions.offset(el);
          var scroll = {
            scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0
          };
          var outerDims = isBody ? {
            width: document.documentElement.clientWidth,
            height: $window.innerHeight
          } : null;
          return angular.extend({}, rect, scroll, outerDims, elOffset);
        }
        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {
          var offset;
          var split = placement.split('-');
          switch (split[0]) {
           case 'right':
            offset = {
              top: position.top + position.height / 2 - actualHeight / 2,
              left: position.left + position.width
            };
            break;

           case 'bottom':
            offset = {
              top: position.top + position.height,
              left: position.left + position.width / 2 - actualWidth / 2
            };
            break;

           case 'left':
            offset = {
              top: position.top + position.height / 2 - actualHeight / 2,
              left: position.left - actualWidth
            };
            break;

           default:
            offset = {
              top: position.top - actualHeight,
              left: position.left + position.width / 2 - actualWidth / 2
            };
            break;
          }
          if (!split[1]) {
            return offset;
          }
          if (split[0] === 'top' || split[0] === 'bottom') {
            switch (split[1]) {
             case 'left':
              offset.left = position.left;
              break;

             case 'right':
              offset.left = position.left + position.width - actualWidth;
              break;

             default:
              break;
            }
          } else if (split[0] === 'left' || split[0] === 'right') {
            switch (split[1]) {
             case 'top':
              offset.top = position.top - actualHeight + position.height;
              break;

             case 'bottom':
              offset.top = position.top;
              break;

             default:
              break;
            }
          }
          return offset;
        }
        function applyPlacement(offset, placement) {
          var tip = tipElement[0];
          var width = tip.offsetWidth;
          var height = tip.offsetHeight;
          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);
          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);
          if (isNaN(marginTop)) marginTop = 0;
          if (isNaN(marginLeft)) marginLeft = 0;
          offset.top = offset.top + marginTop;
          offset.left = offset.left + marginLeft;
          dimensions.setOffset(tip, angular.extend({
            using: function(props) {
              tipElement.css({
                top: Math.round(props.top) + 'px',
                left: Math.round(props.left) + 'px',
                right: ''
              });
            }
          }, offset), 0);
          var actualWidth = tip.offsetWidth;
          var actualHeight = tip.offsetHeight;
          if (placement === 'top' && actualHeight !== height) {
            offset.top = offset.top + height - actualHeight;
          }
          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;
          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
          if (delta.left) {
            offset.left += delta.left;
          } else {
            offset.top += delta.top;
          }
          dimensions.setOffset(tip, offset);
          if (/top|right|bottom|left/.test(placement)) {
            var isVertical = /top|bottom/.test(placement);
            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';
            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);
          }
        }
        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {
          var delta = {
            top: 0,
            left: 0
          };
          if (!$tooltip.$viewport) return delta;
          var viewportPadding = options.viewport && options.viewport.padding || 0;
          var viewportDimensions = getPosition($tooltip.$viewport);
          if (/right|left/.test(placement)) {
            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;
            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;
            if (topEdgeOffset < viewportDimensions.top) {
              delta.top = viewportDimensions.top - topEdgeOffset;
            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
            }
          } else {
            var leftEdgeOffset = position.left - viewportPadding;
            var rightEdgeOffset = position.left + viewportPadding + actualWidth;
            if (leftEdgeOffset < viewportDimensions.left) {
              delta.left = viewportDimensions.left - leftEdgeOffset;
            } else if (rightEdgeOffset > viewportDimensions.right) {
              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
            }
          }
          return delta;
        }
        function replaceArrow(delta, dimension, isHorizontal) {
          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);
          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isHorizontal ? 'top' : 'left', '');
        }
        function destroyTipElement() {
          clearTimeout(timeout);
          if ($tooltip.$isShown && tipElement !== null) {
            if (options.autoClose) {
              unbindAutoCloseEvents();
            }
            if (options.keyboard) {
              unbindKeyboardEvents();
            }
          }
          if (tipScope) {
            tipScope.$destroy();
            tipScope = null;
          }
          if (tipElement) {
            tipElement.remove();
            tipElement = $tooltip.$element = null;
          }
        }
        return $tooltip;
      }
      function safeDigest(scope) {
        scope.$$phase || scope.$root && scope.$root.$$phase || scope.$digest();
      }
      function findElement(query, element) {
        return angular.element((element || document).querySelectorAll(query));
      }
      return TooltipFactory;
    } ];
  }).directive('bsTooltip', [ '$window', '$location', '$sce', '$parse', '$tooltip', '$$rAF', function($window, $location, $sce, $parse, $tooltip, $$rAF) {
    return {
      restrict: 'EAC',
      scope: true,
      link: function postLink(scope, element, attr, transclusion) {
        var tooltip;
        var options = {
          scope: scope
        };
        angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id' ], function(key) {
          if (angular.isDefined(attr[key])) options[key] = attr[key];
        });
        var falseValueRegExp = /^(false|0|)$/i;
        angular.forEach([ 'html', 'container' ], function(key) {
          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {
            options[key] = false;
          }
        });
        angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide' ], function(key) {
          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);
          if (angular.isDefined(attr[bsKey])) {
            options[key] = scope.$eval(attr[bsKey]);
          }
        });
        var dataTarget = element.attr('data-target');
        if (angular.isDefined(dataTarget)) {
          if (falseValueRegExp.test(dataTarget)) {
            options.target = false;
          } else {
            options.target = dataTarget;
          }
        }
        if (!scope.hasOwnProperty('title')) {
          scope.title = '';
        }
        attr.$observe('title', function(newValue) {
          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {
            var oldValue = scope.title;
            scope.title = $sce.trustAsHtml(newValue);
            if (angular.isDefined(oldValue)) {
              $$rAF(function() {
                if (tooltip) tooltip.$applyPlacement();
              });
            }
          }
        });
        attr.$observe('disabled', function(newValue) {
          if (newValue && tooltip.$isShown) {
            tooltip.hide();
          }
        });
        if (attr.bsTooltip) {
          scope.$watch(attr.bsTooltip, function(newValue, oldValue) {
            if (angular.isObject(newValue)) {
              angular.extend(scope, newValue);
            } else {
              scope.title = newValue;
            }
            if (angular.isDefined(oldValue)) {
              $$rAF(function() {
                if (tooltip) tooltip.$applyPlacement();
              });
            }
          }, true);
        }
        if (attr.bsShow) {
          scope.$watch(attr.bsShow, function(newValue, oldValue) {
            if (!tooltip || !angular.isDefined(newValue)) return;
            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);
            if (newValue === true) {
              tooltip.show();
            } else {
              tooltip.hide();
            }
          });
        }
        if (attr.bsEnabled) {
          scope.$watch(attr.bsEnabled, function(newValue, oldValue) {
            if (!tooltip || !angular.isDefined(newValue)) return;
            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);
            if (newValue === false) {
              tooltip.setEnabled(false);
            } else {
              tooltip.setEnabled(true);
            }
          });
        }
        if (attr.viewport) {
          scope.$watch(attr.viewport, function(newValue) {
            if (!tooltip || !angular.isDefined(newValue)) return;
            tooltip.setViewport(newValue);
          });
        }
        tooltip = $tooltip(element, options);
        scope.$on('$destroy', function() {
          if (tooltip) tooltip.destroy();
          options = null;
          tooltip = null;
        });
      }
    };
  } ]);
  angular.module('mgcrea.ngStrap.timepicker', [ 'mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip' ]).provider('$timepicker', function() {
    var defaults = this.defaults = {
      animation: 'am-fade',
      defaultDate: 'auto',
      prefixClass: 'timepicker',
      placement: 'bottom-left',
      templateUrl: 'timepicker/timepicker.tpl.html',
      trigger: 'focus',
      container: false,
      keyboard: true,
      html: false,
      delay: 0,
      useNative: true,
      timeType: 'date',
      timeFormat: 'shortTime',
      timezone: null,
      modelTimeFormat: null,
      autoclose: false,
      minTime: -Infinity,
      maxTime: +Infinity,
      length: 5,
      hourStep: 1,
      minuteStep: 5,
      secondStep: 5,
      roundDisplay: false,
      iconUp: 'glyphicon glyphicon-chevron-up',
      iconDown: 'glyphicon glyphicon-chevron-down',
      arrowBehavior: 'pager'
    };
    this.$get = [ '$window', '$document', '$rootScope', '$sce', '$dateFormatter', '$tooltip', '$timeout', function($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {
      var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);
      var isTouch = 'createTouch' in $window.document && isNative;
      if (!defaults.lang) {
        defaults.lang = $dateFormatter.getDefaultLocale();
      }
      function timepickerFactory(element, controller, config) {
        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));
        var parentScope = config.scope;
        var options = $timepicker.$options;
        var scope = $timepicker.$scope;
        var lang = options.lang;
        var formatDate = function(date, format, timezone) {
          return $dateFormatter.formatDate(date, format, lang, timezone);
        };
        function floorMinutes(time) {
          var coeff = 1e3 * 60 * options.minuteStep;
          return new Date(Math.floor(time.getTime() / coeff) * coeff);
        }
        var selectedIndex = 0;
        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();
        var startDate = controller.$dateValue || defaultDate;
        var viewDate = {
          hour: startDate.getHours(),
          meridian: startDate.getHours() < 12,
          minute: startDate.getMinutes(),
          second: startDate.getSeconds(),
          millisecond: startDate.getMilliseconds()
        };
        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);
        var hoursFormat = $dateFormatter.hoursFormat(format);
        var timeSeparator = $dateFormatter.timeSeparator(format);
        var minutesFormat = $dateFormatter.minutesFormat(format);
        var secondsFormat = $dateFormatter.secondsFormat(format);
        var showSeconds = $dateFormatter.showSeconds(format);
        var showAM = $dateFormatter.showAM(format);
        scope.$iconUp = options.iconUp;
        scope.$iconDown = options.iconDown;
        scope.$select = function(date, index) {
          $timepicker.select(date, index);
        };
        scope.$moveIndex = function(value, index) {
          $timepicker.$moveIndex(value, index);
        };
        scope.$switchMeridian = function(date) {
          $timepicker.switchMeridian(date);
        };
        $timepicker.update = function(date) {
          if (angular.isDate(date) && !isNaN(date.getTime())) {
            $timepicker.$date = date;
            angular.extend(viewDate, {
              hour: date.getHours(),
              minute: date.getMinutes(),
              second: date.getSeconds(),
              millisecond: date.getMilliseconds()
            });
            $timepicker.$build();
          } else if (!$timepicker.$isBuilt) {
            $timepicker.$build();
          }
        };
        $timepicker.select = function(date, index, keep) {
          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {
            controller.$dateValue = options.defaultDate === 'today' ? new Date() : new Date(1970, 0, 1);
          }
          if (!angular.isDate(date)) date = new Date(date);
          if (index === 0) controller.$dateValue.setHours(date.getHours()); else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes()); else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());
          controller.$setViewValue(angular.copy(controller.$dateValue));
          controller.$render();
          if (options.autoclose && !keep) {
            $timeout(function() {
              $timepicker.hide(true);
            });
          }
        };
        $timepicker.switchMeridian = function(date) {
          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {
            return;
          }
          var hours = (date || controller.$dateValue).getHours();
          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);
          controller.$setViewValue(angular.copy(controller.$dateValue));
          controller.$render();
        };
        $timepicker.$build = function() {
          var i;
          var midIndex = scope.midIndex = parseInt(options.length / 2, 10);
          var hours = [];
          var hour;
          for (i = 0; i < options.length; i++) {
            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);
            hours.push({
              date: hour,
              label: formatDate(hour, hoursFormat),
              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),
              disabled: $timepicker.$isDisabled(hour, 0)
            });
          }
          var minutes = [];
          var minute;
          for (i = 0; i < options.length; i++) {
            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);
            minutes.push({
              date: minute,
              label: formatDate(minute, minutesFormat),
              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),
              disabled: $timepicker.$isDisabled(minute, 1)
            });
          }
          var seconds = [];
          var second;
          for (i = 0; i < options.length; i++) {
            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);
            seconds.push({
              date: second,
              label: formatDate(second, secondsFormat),
              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),
              disabled: $timepicker.$isDisabled(second, 2)
            });
          }
          var rows = [];
          for (i = 0; i < options.length; i++) {
            if (showSeconds) {
              rows.push([ hours[i], minutes[i], seconds[i] ]);
            } else {
              rows.push([ hours[i], minutes[i] ]);
            }
          }
          scope.rows = rows;
          scope.showSeconds = showSeconds;
          scope.showAM = showAM;
          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;
          scope.timeSeparator = timeSeparator;
          $timepicker.$isBuilt = true;
        };
        $timepicker.$isSelected = function(date, index) {
          if (!$timepicker.$date) return false; else if (index === 0) {
            return date.getHours() === $timepicker.$date.getHours();
          } else if (index === 1) {
            return date.getMinutes() === $timepicker.$date.getMinutes();
          } else if (index === 2) {
            return date.getSeconds() === $timepicker.$date.getSeconds();
          }
        };
        $timepicker.$isDisabled = function(date, index) {
          var selectedTime;
          if (index === 0) {
            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;
          } else if (index === 1) {
            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;
          } else if (index === 2) {
            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;
          }
          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;
        };
        scope.$arrowAction = function(value, index) {
          if (options.arrowBehavior === 'picker') {
            $timepicker.$setTimeByStep(value, index);
          } else {
            $timepicker.$moveIndex(value, index);
          }
        };
        $timepicker.$setTimeByStep = function(value, index) {
          var newDate = new Date($timepicker.$date || startDate);
          var hours = newDate.getHours();
          var minutes = newDate.getMinutes();
          var seconds = newDate.getSeconds();
          if (index === 0) {
            newDate.setHours(hours - parseInt(options.hourStep, 10) * value);
          } else if (index === 1) {
            newDate.setMinutes(minutes - parseInt(options.minuteStep, 10) * value);
          } else if (index === 2) {
            newDate.setSeconds(seconds - parseInt(options.secondStep, 10) * value);
          }
          $timepicker.select(newDate, index, true);
        };
        $timepicker.$moveIndex = function(value, index) {
          var targetDate;
          if (index === 0) {
            targetDate = new Date(1970, 0, 1, viewDate.hour + value * options.length, viewDate.minute, viewDate.second);
            angular.extend(viewDate, {
              hour: targetDate.getHours()
            });
          } else if (index === 1) {
            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + value * options.length * options.minuteStep, viewDate.second);
            angular.extend(viewDate, {
              minute: targetDate.getMinutes()
            });
          } else if (index === 2) {
            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + value * options.length * options.secondStep);
            angular.extend(viewDate, {
              second: targetDate.getSeconds()
            });
          }
          $timepicker.$build();
        };
        $timepicker.$onMouseDown = function(evt) {
          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();
          evt.stopPropagation();
          if (isTouch) {
            var targetEl = angular.element(evt.target);
            if (targetEl[0].nodeName.toLowerCase() !== 'button') {
              targetEl = targetEl.parent();
            }
            targetEl.triggerHandler('click');
          }
        };
        $timepicker.$onKeyDown = function(evt) {
          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;
          evt.preventDefault();
          evt.stopPropagation();
          if (evt.keyCode === 13) {
            $timepicker.hide(true);
            return;
          }
          var newDate = new Date($timepicker.$date);
          var hours = newDate.getHours();
          var hoursLength = formatDate(newDate, hoursFormat).length;
          var minutes = newDate.getMinutes();
          var minutesLength = formatDate(newDate, minutesFormat).length;
          var seconds = newDate.getSeconds();
          var secondsLength = formatDate(newDate, secondsFormat).length;
          var sepLength = 1;
          var lateralMove = /(37|39)/.test(evt.keyCode);
          var count = 2 + showSeconds * 1 + showAM * 1;
          if (lateralMove) {
            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1; else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;
          }
          var selectRange = [ 0, hoursLength ];
          var incr = 0;
          if (evt.keyCode === 38) incr = -1;
          if (evt.keyCode === 40) incr = +1;
          var isSeconds = selectedIndex === 2 && showSeconds;
          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;
          if (selectedIndex === 0) {
            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));
            hoursLength = formatDate(newDate, hoursFormat).length;
            selectRange = [ 0, hoursLength ];
          } else if (selectedIndex === 1) {
            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));
            minutesLength = formatDate(newDate, minutesFormat).length;
            selectRange = [ hoursLength + sepLength, minutesLength ];
          } else if (isSeconds) {
            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));
            secondsLength = formatDate(newDate, secondsFormat).length;
            selectRange = [ hoursLength + sepLength + minutesLength + sepLength, secondsLength ];
          } else if (isMeridian) {
            if (!lateralMove) $timepicker.switchMeridian();
            selectRange = [ hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2 ];
          }
          $timepicker.select(newDate, selectedIndex, true);
          createSelection(selectRange[0], selectRange[1]);
          parentScope.$digest();
        };
        function createSelection(start, length) {
          var end = start + length;
          if (element[0].createTextRange) {
            var selRange = element[0].createTextRange();
            selRange.collapse(true);
            selRange.moveStart('character', start);
            selRange.moveEnd('character', end);
            selRange.select();
          } else if (element[0].setSelectionRange) {
            element[0].setSelectionRange(start, end);
          } else if (angular.isUndefined(element[0].selectionStart)) {
            element[0].selectionStart = start;
            element[0].selectionEnd = end;
          }
        }
        function focusElement() {
          element[0].focus();
        }
        var _init = $timepicker.init;
        $timepicker.init = function() {
          if (isNative && options.useNative) {
            element.prop('type', 'time');
            element.css('-webkit-appearance', 'textfield');
            return;
          } else if (isTouch) {
            element.prop('type', 'text');
            element.attr('readonly', 'true');
            element.on('click', focusElement);
          }
          _init();
        };
        var _destroy = $timepicker.destroy;
        $timepicker.destroy = function() {
          if (isNative && options.useNative) {
            element.off('click', focusElement);
          }
          _destroy();
        };
        var _show = $timepicker.show;
        $timepicker.show = function() {
          if (!isTouch && element.attr('readonly') || element.attr('disabled')) return;
          _show();
          $timeout(function() {
            if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);
            if (options.keyboard) {
              if (element) element.on('keydown', $timepicker.$onKeyDown);
            }
          }, 0, false);
        };
        var _hide = $timepicker.hide;
        $timepicker.hide = function(blur) {
          if (!$timepicker.$isShown) return;
          if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);
          if (options.keyboard) {
            if (element) element.off('keydown', $timepicker.$onKeyDown);
          }
          _hide(blur);
        };
        return $timepicker;
      }
      timepickerFactory.defaults = defaults;
      return timepickerFactory;
    } ];
  }).directive('bsTimepicker', [ '$window', '$parse', '$q', '$dateFormatter', '$dateParser', '$timepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {
    var defaults = $timepicker.defaults;
    var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);
    return {
      restrict: 'EAC',
      require: 'ngModel',
      link: function postLink(scope, element, attr, controller) {
        var options = {
          scope: scope
        };
        angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent', 'defaultDate' ], function(key) {
          if (angular.isDefined(attr[key])) options[key] = attr[key];
        });
        var falseValueRegExp = /^(false|0|)$/i;
        angular.forEach([ 'html', 'container', 'autoclose', 'useNative', 'roundDisplay' ], function(key) {
          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {
            options[key] = false;
          }
        });
        angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide' ], function(key) {
          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);
          if (angular.isDefined(attr[bsKey])) {
            options[key] = scope.$eval(attr[bsKey]);
          }
        });
        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';
        var timepicker = $timepicker(element, controller, options);
        options = timepicker.$options;
        var lang = options.lang;
        var formatDate = function(date, format, timezone) {
          return $dateFormatter.formatDate(date, format, lang, timezone);
        };
        if (attr.bsShow) {
          scope.$watch(attr.bsShow, function(newValue, oldValue) {
            if (!timepicker || !angular.isDefined(newValue)) return;
            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);
            if (newValue === true) {
              timepicker.show();
            } else {
              timepicker.hide();
            }
          });
        }
        var dateParser = $dateParser({
          format: options.timeFormat,
          lang: lang
        });
        angular.forEach([ 'minTime', 'maxTime' ], function(key) {
          if (angular.isDefined(attr[key])) {
            attr.$observe(key, function(newValue) {
              timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);
              if (!isNaN(timepicker.$options[key])) timepicker.$build();
              validateAgainstMinMaxTime(controller.$dateValue);
            });
          }
        });
        scope.$watch(attr.ngModel, function(newValue, oldValue) {
          timepicker.update(controller.$dateValue);
        }, true);
        function validateAgainstMinMaxTime(parsedTime) {
          if (!angular.isDate(parsedTime)) return;
          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;
          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;
          var isValid = isMinValid && isMaxValid;
          controller.$setValidity('date', isValid);
          controller.$setValidity('min', isMinValid);
          controller.$setValidity('max', isMaxValid);
          if (!isValid) {
            return;
          }
          controller.$dateValue = parsedTime;
        }
        controller.$parsers.unshift(function(viewValue) {
          var date;
          if (!viewValue) {
            controller.$setValidity('date', true);
            return null;
          }
          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);
          if (!parsedTime || isNaN(parsedTime.getTime())) {
            controller.$setValidity('date', false);
            return undefined;
          }
          validateAgainstMinMaxTime(parsedTime);
          if (options.timeType === 'string') {
            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);
            return formatDate(date, options.modelTimeFormat || options.timeFormat);
          }
          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);
          if (options.timeType === 'number') {
            return date.getTime();
          } else if (options.timeType === 'unix') {
            return date.getTime() / 1e3;
          } else if (options.timeType === 'iso') {
            return date.toISOString();
          }
          return new Date(date);
        });
        controller.$formatters.push(function(modelValue) {
          var date;
          if (angular.isUndefined(modelValue) || modelValue === null) {
            date = NaN;
          } else if (angular.isDate(modelValue)) {
            date = modelValue;
          } else if (options.timeType === 'string') {
            date = dateParser.parse(modelValue, null, options.modelTimeFormat);
          } else if (options.timeType === 'unix') {
            date = new Date(modelValue * 1e3);
          } else {
            date = new Date(modelValue);
          }
          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);
          return getTimeFormattedString();
        });
        controller.$render = function() {
          element.val(getTimeFormattedString());
        };
        function getTimeFormattedString() {
          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);
        }
        scope.$on('$destroy', function() {
          if (timepicker) timepicker.destroy();
          options = null;
          timepicker = null;
        });
      }
    };
  } ]);
  angular.module('mgcrea.ngStrap.tab', []).provider('$tab', function() {
    var defaults = this.defaults = {
      animation: 'am-fade',
      template: 'tab/tab.tpl.html',
      navClass: 'nav-tabs',
      activeClass: 'active'
    };
    var controller = this.controller = function($scope, $element, $attrs) {
      var self = this;
      self.$options = angular.copy(defaults);
      angular.forEach([ 'animation', 'navClass', 'activeClass' ], function(key) {
        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];
      });
      $scope.$navClass = self.$options.navClass;
      $scope.$activeClass = self.$options.activeClass;
      self.$panes = $scope.$panes = [];
      self.$activePaneChangeListeners = self.$viewChangeListeners = [];
      self.$push = function(pane) {
        if (angular.isUndefined(self.$panes.$active)) {
          $scope.$setActive(pane.name || 0);
        }
        self.$panes.push(pane);
      };
      self.$remove = function(pane) {
        var index = self.$panes.indexOf(pane);
        var active = self.$panes.$active;
        var activeIndex;
        if (angular.isString(active)) {
          activeIndex = self.$panes.map(function(pane) {
            return pane.name;
          }).indexOf(active);
        } else {
          activeIndex = self.$panes.$active;
        }
        self.$panes.splice(index, 1);
        if (index < activeIndex) {
          activeIndex--;
        } else if (index === activeIndex && activeIndex === self.$panes.length) {
          activeIndex--;
        }
        if (activeIndex >= 0 && activeIndex < self.$panes.length) {
          self.$setActive(self.$panes[activeIndex].name || activeIndex);
        } else {
          self.$setActive();
        }
      };
      self.$setActive = $scope.$setActive = function(value) {
        self.$panes.$active = value;
        self.$activePaneChangeListeners.forEach(function(fn) {
          fn();
        });
      };
      self.$isActive = $scope.$isActive = function($pane, $index) {
        return self.$panes.$active === $pane.name || self.$panes.$active === $index;
      };
    };
    this.$get = function() {
      var $tab = {};
      $tab.defaults = defaults;
      $tab.controller = controller;
      return $tab;
    };
  }).directive('bsTabs', [ '$window', '$animate', '$tab', '$parse', function($window, $animate, $tab, $parse) {
    var defaults = $tab.defaults;
    return {
      require: [ '?ngModel', 'bsTabs' ],
      transclude: true,
      scope: true,
      controller: [ '$scope', '$element', '$attrs', $tab.controller ],
      templateUrl: function(element, attr) {
        return attr.template || defaults.template;
      },
      link: function postLink(scope, element, attrs, controllers) {
        var ngModelCtrl = controllers[0];
        var bsTabsCtrl = controllers[1];
        if (ngModelCtrl) {
          bsTabsCtrl.$activePaneChangeListeners.push(function() {
            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);
          });
          ngModelCtrl.$formatters.push(function(modelValue) {
            bsTabsCtrl.$setActive(modelValue);
            return modelValue;
          });
        }
        if (attrs.bsActivePane) {
          var parsedBsActivePane = $parse(attrs.bsActivePane);
          bsTabsCtrl.$activePaneChangeListeners.push(function() {
            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);
          });
          scope.$watch(attrs.bsActivePane, function(newValue, oldValue) {
            bsTabsCtrl.$setActive(newValue);
          }, true);
        }
      }
    };
  } ]).directive('bsPane', [ '$window', '$animate', '$sce', function($window, $animate, $sce) {
    return {
      require: [ '^?ngModel', '^bsTabs' ],
      scope: true,
      link: function postLink(scope, element, attrs, controllers) {
        var bsTabsCtrl = controllers[1];
        element.addClass('tab-pane');
        attrs.$observe('title', function(newValue, oldValue) {
          scope.title = $sce.trustAsHtml(newValue);
        });
        scope.name = attrs.name;
        if (bsTabsCtrl.$options.animation) {
          element.addClass(bsTabsCtrl.$options.animation);
        }
        attrs.$observe('disabled', function(newValue, oldValue) {
          scope.disabled = scope.$eval(newValue);
        });
        bsTabsCtrl.$push(scope);
        scope.$on('$destroy', function() {
          bsTabsCtrl.$remove(scope);
        });
        function render() {
          var index = bsTabsCtrl.$panes.indexOf(scope);
          $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);
        }
        bsTabsCtrl.$activePaneChangeListeners.push(function() {
          render();
        });
        render();
      }
    };
  } ]);
  angular.module('mgcrea.ngStrap.select', [ 'mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions' ]).provider('$select', function() {
    var defaults = this.defaults = {
      animation: 'am-fade',
      prefixClass: 'select',
      prefixEvent: '$select',
      placement: 'bottom-left',
      templateUrl: 'select/select.tpl.html',
      trigger: 'focus',
      container: false,
      keyboard: true,
      html: false,
      delay: 0,
      multiple: false,
      allNoneButtons: false,
      sort: true,
      caretHtml: '<span class="caret"></span>',
      placeholder: 'Choose',
      allText: 'All',
      noneText: 'None',
      maxLength: 3,
      maxLengthHtml: 'selected',
      iconCheckmark: 'fa fa-check',
      toggle: false
    };
    this.$get = [ '$window', '$document', '$rootScope', '$tooltip', '$timeout', function($window, $document, $rootScope, $tooltip, $timeout) {
      var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);
      var isTouch = 'createTouch' in $window.document && isNative;
      function SelectFactory(element, controller, config) {
        var $select = {};
        var options = angular.extend({}, defaults, config);
        $select = $tooltip(element, options);
        var scope = $select.$scope;
        scope.$matches = [];
        if (options.multiple) {
          scope.$activeIndex = [];
        } else {
          scope.$activeIndex = -1;
        }
        scope.$isMultiple = options.multiple;
        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;
        scope.$iconCheckmark = options.iconCheckmark;
        scope.$allText = options.allText;
        scope.$noneText = options.noneText;
        scope.$activate = function(index) {
          scope.$$postDigest(function() {
            $select.activate(index);
          });
        };
        scope.$select = function(index, evt) {
          scope.$$postDigest(function() {
            $select.select(index);
          });
        };
        scope.$isVisible = function() {
          return $select.$isVisible();
        };
        scope.$isActive = function(index) {
          return $select.$isActive(index);
        };
        scope.$selectAll = function() {
          for (var i = 0; i < scope.$matches.length; i++) {
            if (!scope.$isActive(i)) {
              scope.$select(i);
            }
          }
        };
        scope.$selectNone = function() {
          for (var i = 0; i < scope.$matches.length; i++) {
            if (scope.$isActive(i)) {
              scope.$select(i);
            }
          }
        };
        $select.update = function(matches) {
          scope.$matches = matches;
          $select.$updateActiveIndex();
        };
        $select.activate = function(index) {
          if (options.multiple) {
            if ($select.$isActive(index)) {
              scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);
            } else {
              scope.$activeIndex.push(index);
            }
            if (options.sort) scope.$activeIndex.sort(function(a, b) {
              return a - b;
            });
          } else {
            scope.$activeIndex = index;
          }
          return scope.$activeIndex;
        };
        $select.select = function(index) {
          if (angular.isUndefined(index) || index < 0 || index >= scope.$matches.length) {
            return;
          }
          var value = scope.$matches[index].value;
          scope.$apply(function() {
            $select.activate(index);
            if (options.multiple) {
              controller.$setViewValue(scope.$activeIndex.map(function(index) {
                if (angular.isUndefined(scope.$matches[index])) {
                  return null;
                }
                return scope.$matches[index].value;
              }));
            } else {
              if (options.toggle) {
                controller.$setViewValue(value === controller.$modelValue ? undefined : value);
              } else {
                controller.$setViewValue(value);
              }
              $select.hide();
            }
          });
          scope.$emit(options.prefixEvent + '.select', value, index, $select);
          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {
            options.onSelect(value, index, $select);
          }
        };
        $select.$updateActiveIndex = function() {
          if (options.multiple) {
            if (angular.isArray(controller.$modelValue)) {
              scope.$activeIndex = controller.$modelValue.map(function(value) {
                return $select.$getIndex(value);
              });
            } else {
              scope.$activeIndex = [];
            }
          } else {
            if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {
              scope.$activeIndex = $select.$getIndex(controller.$modelValue);
            } else {
              scope.$activeIndex = -1;
            }
          }
        };
        $select.$isVisible = function() {
          if (!options.minLength || !controller) {
            return scope.$matches.length;
          }
          return scope.$matches.length && controller.$viewValue.length >= options.minLength;
        };
        $select.$isActive = function(index) {
          if (options.multiple) {
            return scope.$activeIndex.indexOf(index) !== -1;
          }
          return scope.$activeIndex === index;
        };
        $select.$getIndex = function(value) {
          var index;
          for (index = scope.$matches.length; index--; ) {
            if (angular.equals(scope.$matches[index].value, value)) break;
          }
          return index;
        };
        $select.$onMouseDown = function(evt) {
          evt.preventDefault();
          evt.stopPropagation();
          if (isTouch) {
            var targetEl = angular.element(evt.target);
            var anchor;
            if (evt.target.nodeName !== 'A') {
              var anchorCandidate = targetEl.parent();
              while (!anchor && anchorCandidate.length > 0) {
                if (anchorCandidate[0].nodeName === 'A') {
                  anchor = anchorCandidate;
                }
                anchorCandidate = anchorCandidate.parent();
              }
            }
            if (anchor) {
              angular.element(anchor).triggerHandler('click');
            } else {
              targetEl.triggerHandler('click');
            }
          }
        };
        $select.$onKeyDown = function(evt) {
          if (!/(9|13|38|40)/.test(evt.keyCode)) return;
          if (evt.keyCode !== 9) {
            evt.preventDefault();
            evt.stopPropagation();
          }
          if (options.multiple && evt.keyCode === 9) {
            return $select.hide();
          }
          if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {
            return $select.select(scope.$activeIndex);
          }
          if (!options.multiple) {
            if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--; else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1; else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++; else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;
            scope.$digest();
          }
        };
        $select.$isIE = function() {
          var ua = $window.navigator.userAgent;
          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;
        };
        $select.$selectScrollFix = function(e) {
          if ($document[0].activeElement.tagName === 'UL') {
            e.preventDefault();
            e.stopImmediatePropagation();
            e.target.focus();
          }
        };
        var _show = $select.show;
        $select.show = function() {
          _show();
          if (options.multiple) {
            $select.$element.addClass('select-multiple');
          }
          $timeout(function() {
            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);
            if (options.keyboard) {
              element.on('keydown', $select.$onKeyDown);
            }
          }, 0, false);
        };
        var _hide = $select.hide;
        $select.hide = function() {
          if (!options.multiple && angular.isUndefined(controller.$modelValue)) {
            scope.$activeIndex = -1;
          }
          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);
          if (options.keyboard) {
            element.off('keydown', $select.$onKeyDown);
          }
          _hide(true);
        };
        return $select;
      }
      SelectFactory.defaults = defaults;
      return SelectFactory;
    } ];
  }).directive('bsSelect', [ '$window', '$parse', '$q', '$select', '$parseOptions', function($window, $parse, $q, $select, $parseOptions) {
    var defaults = $select.defaults;
    return {
      restrict: 'EAC',
      require: 'ngModel',
      link: function postLink(scope, element, attr, controller) {
        var options = {
          scope: scope,
          placeholder: defaults.placeholder
        };
        angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent', 'toggle' ], function(key) {
          if (angular.isDefined(attr[key])) options[key] = attr[key];
        });
        var falseValueRegExp = /^(false|0|)$/i;
        angular.forEach([ 'html', 'container', 'allNoneButtons', 'sort' ], function(key) {
          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {
            options[key] = false;
          }
        });
        angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect' ], function(key) {
          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);
          if (angular.isDefined(attr[bsKey])) {
            options[key] = scope.$eval(attr[bsKey]);
          }
        });
        var dataMultiple = element.attr('data-multiple');
        if (angular.isDefined(dataMultiple)) {
          if (falseValueRegExp.test(dataMultiple)) {
            options.multiple = false;
          } else {
            options.multiple = dataMultiple;
          }
        }
        if (element[0].nodeName.toLowerCase() === 'select') {
          var inputEl = element;
          inputEl.css('display', 'none');
          element = angular.element('<button type="button" class="btn btn-default"></button>');
          inputEl.after(element);
        }
        var parsedOptions = $parseOptions(attr.bsOptions);
        var select = $select(element, controller, options);
        if (select.$isIE()) {
          element[0].addEventListener('blur', select.$selectScrollFix);
        }
        var watchedOptions = parsedOptions.$match[7].replace(/\|.+/, '').trim();
        scope.$watch(watchedOptions, function(newValue, oldValue) {
          parsedOptions.valuesFn(scope, controller).then(function(values) {
            select.update(values);
            controller.$render();
          });
        }, true);
        scope.$watch(attr.ngModel, function(newValue, oldValue) {
          select.$updateActiveIndex();
          controller.$render();
        }, true);
        controller.$render = function() {
          var selected;
          var index;
          if (options.multiple && angular.isArray(controller.$modelValue)) {
            selected = controller.$modelValue.map(function(value) {
              index = select.$getIndex(value);
              return index !== -1 ? select.$scope.$matches[index].label : false;
            }).filter(angular.isDefined);
            if (selected.length > (options.maxLength || defaults.maxLength)) {
              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);
            } else {
              selected = selected.join(', ');
            }
          } else {
            index = select.$getIndex(controller.$modelValue);
            selected = index !== -1 ? select.$scope.$matches[index].label : false;
          }
          element.html((selected || options.placeholder) + (options.caretHtml || defaults.caretHtml));
        };
        if (options.multiple) {
          controller.$isEmpty = function(value) {
            return !value || value.length === 0;
          };
        }
        scope.$on('$destroy', function() {
          if (select) select.destroy();
          options = null;
          select = null;
        });
      }
    };
  } ]);
  angular.module('mgcrea.ngStrap.scrollspy', [ 'mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions' ]).provider('$scrollspy', function() {
    var spies = this.$$spies = {};
    var defaults = this.defaults = {
      debounce: 150,
      throttle: 100,
      offset: 100
    };
    this.$get = [ '$window', '$document', '$rootScope', 'dimensions', 'debounce', 'throttle', function($window, $document, $rootScope, dimensions, debounce, throttle) {
      var windowEl = angular.element($window);
      var docEl = angular.element($document.prop('documentElement'));
      var bodyEl = angular.element($window.document.body);
      function nodeName(element, name) {
        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();
      }
      function ScrollSpyFactory(config) {
        var options = angular.extend({}, defaults, config);
        if (!options.element) options.element = bodyEl;
        var isWindowSpy = nodeName(options.element, 'body');
        var scrollEl = isWindowSpy ? windowEl : options.element;
        var scrollId = isWindowSpy ? 'window' : options.id;
        if (spies[scrollId]) {
          spies[scrollId].$$count++;
          return spies[scrollId];
        }
        var $scrollspy = {};
        var unbindViewContentLoaded;
        var unbindIncludeContentLoaded;
        var trackedElements = $scrollspy.$trackedElements = [];
        var sortedElements = [];
        var activeTarget;
        var debouncedCheckPosition;
        var throttledCheckPosition;
        var debouncedCheckOffsets;
        var viewportHeight;
        var scrollTop;
        $scrollspy.init = function() {
          this.$$count = 1;
          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);
          throttledCheckPosition = throttle(this.checkPosition, options.throttle);
          scrollEl.on('click', this.checkPositionWithEventLoop);
          windowEl.on('resize', debouncedCheckPosition);
          scrollEl.on('scroll', throttledCheckPosition);
          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);
          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);
          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);
          debouncedCheckOffsets();
          if (scrollId) {
            spies[scrollId] = $scrollspy;
          }
        };
        $scrollspy.destroy = function() {
          this.$$count--;
          if (this.$$count > 0) {
            return;
          }
          scrollEl.off('click', this.checkPositionWithEventLoop);
          windowEl.off('resize', debouncedCheckPosition);
          scrollEl.off('scroll', throttledCheckPosition);
          unbindViewContentLoaded();
          unbindIncludeContentLoaded();
          if (scrollId) {
            delete spies[scrollId];
          }
        };
        $scrollspy.checkPosition = function() {
          if (!sortedElements.length) return;
          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;
          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));
          if (scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {
            return $scrollspy.$activateElement(sortedElements[0]);
          }
          for (var i = sortedElements.length; i--; ) {
            if (angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;
            if (activeTarget === sortedElements[i].target) continue;
            if (scrollTop < sortedElements[i].offsetTop) continue;
            if (sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;
            return $scrollspy.$activateElement(sortedElements[i]);
          }
        };
        $scrollspy.checkPositionWithEventLoop = function() {
          setTimeout($scrollspy.checkPosition, 1);
        };
        $scrollspy.$activateElement = function(element) {
          if (activeTarget) {
            var activeElement = $scrollspy.$getTrackedElement(activeTarget);
            if (activeElement) {
              activeElement.source.removeClass('active');
              if (nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {
                activeElement.source.parent().parent().removeClass('active');
              }
            }
          }
          activeTarget = element.target;
          element.source.addClass('active');
          if (nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {
            element.source.parent().parent().addClass('active');
          }
        };
        $scrollspy.$getTrackedElement = function(target) {
          return trackedElements.filter(function(obj) {
            return obj.target === target;
          })[0];
        };
        $scrollspy.checkOffsets = function() {
          angular.forEach(trackedElements, function(trackedElement) {
            var targetElement = document.querySelector(trackedElement.target);
            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;
            if (options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;
          });
          sortedElements = trackedElements.filter(function(el) {
            return el.offsetTop !== null;
          }).sort(function(a, b) {
            return a.offsetTop - b.offsetTop;
          });
          debouncedCheckPosition();
        };
        $scrollspy.trackElement = function(target, source) {
          trackedElements.push({
            target: target,
            source: source
          });
        };
        $scrollspy.untrackElement = function(target, source) {
          var toDelete;
          for (var i = trackedElements.length; i--; ) {
            if (trackedElements[i].target === target && trackedElements[i].source === source) {
              toDelete = i;
              break;
            }
          }
          trackedElements.splice(toDelete, 1);
        };
        $scrollspy.activate = function(i) {
          trackedElements[i].addClass('active');
        };
        $scrollspy.init();
        return $scrollspy;
      }
      return ScrollSpyFactory;
    } ];
  }).directive('bsScrollspy', [ '$rootScope', 'debounce', 'dimensions', '$scrollspy', function($rootScope, debounce, dimensions, $scrollspy) {
    return {
      restrict: 'EAC',
      link: function postLink(scope, element, attr) {
        var options = {
          scope: scope
        };
        angular.forEach([ 'offset', 'target' ], function(key) {
          if (angular.isDefined(attr[key])) options[key] = attr[key];
        });
        var scrollspy = $scrollspy(options);
        scrollspy.trackElement(options.target, element);
        scope.$on('$destroy', function() {
          if (scrollspy) {
            scrollspy.untrackElement(options.target, element);
            scrollspy.destroy();
          }
          options = null;
          scrollspy = null;
        });
      }
    };
  } ]).directive('bsScrollspyList', [ '$rootScope', 'debounce', 'dimensions', '$scrollspy', function($rootScope, debounce, dimensions, $scrollspy) {
    return {
      restrict: 'A',
      compile: function postLink(element, attr) {
        var children = element[0].querySelectorAll('li > a[href]');
        angular.forEach(children, function(child) {
          var childEl = angular.element(child);
          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));
        });
      }
    };
  } ]);
  angular.module('mgcrea.ngStrap.popover', [ 'mgcrea.ngStrap.tooltip' ]).provider('$popover', function() {
    var defaults = this.defaults = {
      animation: 'am-fade',
      customClass: '',
      container: false,
      target: false,
      placement: 'right',
      templateUrl: 'popover/popover.tpl.html',
      contentTemplate: false,
      trigger: 'click',
      keyboard: true,
      html: false,
      title: '',
      content: '',
      delay: 0,
      autoClose: false
    };
    this.$get = [ '$tooltip', function($tooltip) {
      function PopoverFactory(element, config) {
        var options = angular.extend({}, defaults, config);
        var $popover = $tooltip(element, options);
        if (options.content) {
          $popover.$scope.content = options.content;
        }
        return $popover;
      }
      return PopoverFactory;
    } ];
  }).directive('bsPopover', [ '$window', '$sce', '$popover', function($window, $sce, $popover) {
    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;
    return {
      restrict: 'EAC',
      scope: true,
      link: function postLink(scope, element, attr) {
        var popover;
        var options = {
          scope: scope
        };
        angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent', 'bsEnabled' ], function(key) {
          if (angular.isDefined(attr[key])) options[key] = attr[key];
        });
        var falseValueRegExp = /^(false|0|)$/i;
        angular.forEach([ 'html', 'container', 'autoClose' ], function(key) {
          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;
        });
        angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide' ], function(key) {
          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);
          if (angular.isDefined(attr[bsKey])) {
            options[key] = scope.$eval(attr[bsKey]);
          }
        });
        var dataTarget = element.attr('data-target');
        if (angular.isDefined(dataTarget)) {
          if (falseValueRegExp.test(dataTarget)) {
            options.target = false;
          } else {
            options.target = dataTarget;
          }
        }
        angular.forEach([ 'title', 'content' ], function(key) {
          if (attr[key]) {
            attr.$observe(key, function(newValue, oldValue) {
              scope[key] = $sce.trustAsHtml(newValue);
              if (angular.isDefined(oldValue)) {
                requestAnimationFrame(function() {
                  if (popover) popover.$applyPlacement();
                });
              }
            });
          }
        });
        if (attr.bsPopover) {
          scope.$watch(attr.bsPopover, function(newValue, oldValue) {
            if (angular.isObject(newValue)) {
              angular.extend(scope, newValue);
            } else {
              scope.content = newValue;
            }
            if (angular.isDefined(oldValue)) {
              requestAnimationFrame(function() {
                if (popover) popover.$applyPlacement();
              });
            }
          }, true);
        }
        if (attr.bsShow) {
          scope.$watch(attr.bsShow, function(newValue, oldValue) {
            if (!popover || !angular.isDefined(newValue)) return;
            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);
            if (newValue === true) {
              popover.show();
            } else {
              popover.hide();
            }
          });
        }
        if (attr.bsEnabled) {
          scope.$watch(attr.bsEnabled, function(newValue) {
            if (!popover || !angular.isDefined(newValue)) return;
            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(popover),?/i);
            if (newValue === false) {
              popover.setEnabled(false);
            } else {
              popover.setEnabled(true);
            }
          });
        }
        if (attr.viewport) {
          scope.$watch(attr.viewport, function(newValue) {
            if (!popover || !angular.isDefined(newValue)) return;
            popover.setViewport(newValue);
          });
        }
        popover = $popover(element, options);
        scope.$on('$destroy', function() {
          if (popover) popover.destroy();
          options = null;
          popover = null;
        });
      }
    };
  } ]);
  angular.module('mgcrea.ngStrap.navbar', []).provider('$navbar', function() {
    var defaults = this.defaults = {
      activeClass: 'active',
      routeAttr: 'data-match-route',
      strict: false
    };
    this.$get = function() {
      return {
        defaults: defaults
      };
    };
  }).directive('bsNavbar', [ '$window', '$location', '$navbar', function($window, $location, $navbar) {
    var defaults = $navbar.defaults;
    return {
      restrict: 'A',
      link: function postLink(scope, element, attr, controller) {
        var options = angular.copy(defaults);
        angular.forEach(Object.keys(defaults), function(key) {
          if (angular.isDefined(attr[key])) options[key] = attr[key];
        });
        scope.$watch(function() {
          return $location.path();
        }, function(newValue, oldValue) {
          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');
          angular.forEach(liElements, function(li) {
            var liElement = angular.element(li);
            var pattern = liElement.attr(options.routeAttr).replace('/', '\\/');
            if (options.strict) {
              pattern = '^' + pattern + '$';
            }
            var regexp = new RegExp(pattern, 'i');
            if (regexp.test(newValue)) {
              liElement.addClass(options.activeClass);
            } else {
              liElement.removeClass(options.activeClass);
            }
          });
        });
      }
    };
  } ]);
  angular.module('mgcrea.ngStrap.modal', [ 'mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions' ]).provider('$modal', function() {
    var defaults = this.defaults = {
      animation: 'am-fade',
      backdropAnimation: 'am-fade',
      customClass: '',
      prefixClass: 'modal',
      prefixEvent: 'modal',
      placement: 'top',
      templateUrl: 'modal/modal.tpl.html',
      template: '',
      contentTemplate: false,
      container: false,
      element: null,
      backdrop: true,
      keyboard: true,
      html: false,
      show: true,
      size: null,
      zIndex: null
    };
    this.$get = [ '$window', '$rootScope', '$bsCompiler', '$animate', '$timeout', '$sce', 'dimensions', function($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {
      var forEach = angular.forEach;
      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;
      var bodyElement = angular.element($window.document.body);
      var backdropCount = 0;
      var dialogBaseZindex = 1050;
      var backdropBaseZindex = 1040;
      var validSizes = {
        lg: 'modal-lg',
        sm: 'modal-sm'
      };
      function ModalFactory(config) {
        var $modal = {};
        var options = $modal.$options = angular.extend({}, defaults, config);
        var promise = $modal.$promise = $bsCompiler.compile(options);
        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();
        if (!options.element && !options.container) {
          options.container = 'body';
        }
        if (options.zIndex) {
          dialogBaseZindex = parseInt(options.zIndex, 10);
          backdropBaseZindex = dialogBaseZindex - 10;
        }
        $modal.$id = options.id || options.element && options.element.attr('id') || '';
        forEach([ 'title', 'content' ], function(key) {
          if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);
        });
        scope.$hide = function() {
          scope.$$postDigest(function() {
            $modal.hide();
          });
        };
        scope.$show = function() {
          scope.$$postDigest(function() {
            $modal.show();
          });
        };
        scope.$toggle = function() {
          scope.$$postDigest(function() {
            $modal.toggle();
          });
        };
        $modal.$isShown = scope.$isShown = false;
        var compileData;
        var modalElement;
        var modalScope;
        var backdropElement = angular.element('<div class="' + options.prefixClass + '-backdrop"/>');
        backdropElement.css({
          position: 'fixed',
          top: '0px',
          left: '0px',
          bottom: '0px',
          right: '0px'
        });
        promise.then(function(data) {
          compileData = data;
          $modal.init();
        });
        $modal.init = function() {
          if (options.show) {
            scope.$$postDigest(function() {
              $modal.show();
            });
          }
        };
        $modal.destroy = function() {
          destroyModalElement();
          if (backdropElement) {
            backdropElement.remove();
            backdropElement = null;
          }
          scope.$destroy();
        };
        $modal.show = function() {
          if ($modal.$isShown) return;
          var parent;
          var after;
          if (angular.isElement(options.container)) {
            parent = options.container;
            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;
          } else {
            if (options.container) {
              parent = findElement(options.container);
              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;
            } else {
              parent = null;
              after = options.element;
            }
          }
          if (modalElement) destroyModalElement();
          modalScope = $modal.$scope.$new();
          modalElement = $modal.$element = compileData.link(modalScope, function(clonedElement, scope) {});
          if (options.backdrop) {
            modalElement.css({
              'z-index': dialogBaseZindex + backdropCount * 20
            });
            backdropElement.css({
              'z-index': backdropBaseZindex + backdropCount * 20
            });
            backdropCount++;
          }
          if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {
            return;
          }
          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {
            options.onBeforeShow($modal);
          }
          modalElement.css({
            display: 'block'
          }).addClass(options.placement);
          if (options.customClass) {
            modalElement.addClass(options.customClass);
          }
          if (options.size && validSizes[options.size]) {
            angular.element(findElement('.modal-dialog', modalElement[0])).addClass(validSizes[options.size]);
          }
          if (options.animation) {
            if (options.backdrop) {
              backdropElement.addClass(options.backdropAnimation);
            }
            modalElement.addClass(options.animation);
          }
          if (options.backdrop) {
            $animate.enter(backdropElement, bodyElement, null);
          }
          if (angular.version.minor <= 2) {
            $animate.enter(modalElement, parent, after, enterAnimateCallback);
          } else {
            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);
          }
          $modal.$isShown = scope.$isShown = true;
          safeDigest(scope);
          var el = modalElement[0];
          requestAnimationFrame(function() {
            el.focus();
          });
          bodyElement.addClass(options.prefixClass + '-open');
          if (options.animation) {
            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);
          }
          bindBackdropEvents();
          bindKeyboardEvents();
        };
        function enterAnimateCallback() {
          scope.$emit(options.prefixEvent + '.show', $modal);
          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {
            options.onShow($modal);
          }
        }
        $modal.hide = function() {
          if (!$modal.$isShown) return;
          if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {
            return;
          }
          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {
            options.onBeforeHide($modal);
          }
          if (angular.version.minor <= 2) {
            $animate.leave(modalElement, leaveAnimateCallback);
          } else {
            $animate.leave(modalElement).then(leaveAnimateCallback);
          }
          if (options.backdrop) {
            backdropCount--;
            $animate.leave(backdropElement);
          }
          $modal.$isShown = scope.$isShown = false;
          safeDigest(scope);
          unbindBackdropEvents();
          unbindKeyboardEvents();
        };
        function leaveAnimateCallback() {
          scope.$emit(options.prefixEvent + '.hide', $modal);
          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {
            options.onHide($modal);
          }
          if (findElement('.modal').length <= 0) {
            bodyElement.removeClass(options.prefixClass + '-open');
          }
          if (options.animation) {
            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);
          }
        }
        $modal.toggle = function() {
          if ($modal.$isShown) {
            $modal.hide();
          } else {
            $modal.show();
          }
        };
        $modal.focus = function() {
          modalElement[0].focus();
        };
        $modal.$onKeyUp = function(evt) {
          if (evt.which === 27 && $modal.$isShown) {
            $modal.hide();
            evt.stopPropagation();
          }
        };
        function bindBackdropEvents() {
          if (options.backdrop) {
            modalElement.on('click', hideOnBackdropClick);
            backdropElement.on('click', hideOnBackdropClick);
            backdropElement.on('wheel', preventEventDefault);
          }
        }
        function unbindBackdropEvents() {
          if (options.backdrop) {
            modalElement.off('click', hideOnBackdropClick);
            backdropElement.off('click', hideOnBackdropClick);
            backdropElement.off('wheel', preventEventDefault);
          }
        }
        function bindKeyboardEvents() {
          if (options.keyboard) {
            modalElement.on('keyup', $modal.$onKeyUp);
          }
        }
        function unbindKeyboardEvents() {
          if (options.keyboard) {
            modalElement.off('keyup', $modal.$onKeyUp);
          }
        }
        function hideOnBackdropClick(evt) {
          if (evt.target !== evt.currentTarget) return;
          if (options.backdrop === 'static') {
            $modal.focus();
          } else {
            $modal.hide();
          }
        }
        function preventEventDefault(evt) {
          evt.preventDefault();
        }
        function destroyModalElement() {
          if ($modal.$isShown && modalElement !== null) {
            unbindBackdropEvents();
            unbindKeyboardEvents();
          }
          if (modalScope) {
            modalScope.$destroy();
            modalScope = null;
          }
          if (modalElement) {
            modalElement.remove();
            modalElement = $modal.$element = null;
          }
        }
        return $modal;
      }
      function safeDigest(scope) {
        scope.$$phase || scope.$root && scope.$root.$$phase || scope.$digest();
      }
      function findElement(query, element) {
        return angular.element((element || document).querySelectorAll(query));
      }
      return ModalFactory;
    } ];
  }).directive('bsModal', [ '$window', '$sce', '$parse', '$modal', function($window, $sce, $parse, $modal) {
    return {
      restrict: 'EAC',
      scope: true,
      link: function postLink(scope, element, attr, transclusion) {
        var options = {
          scope: scope,
          element: element,
          show: false
        };
        angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass', 'size', 'zIndex' ], function(key) {
          if (angular.isDefined(attr[key])) options[key] = attr[key];
        });
        if (options.modalClass) {
          options.customClass = options.modalClass;
        }
        var falseValueRegExp = /^(false|0|)$/i;
        angular.forEach([ 'backdrop', 'keyboard', 'html', 'container' ], function(key) {
          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;
        });
        angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide' ], function(key) {
          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);
          if (angular.isDefined(attr[bsKey])) {
            options[key] = scope.$eval(attr[bsKey]);
          }
        });
        angular.forEach([ 'title', 'content' ], function(key) {
          if (attr[key]) {
            attr.$observe(key, function(newValue, oldValue) {
              scope[key] = $sce.trustAsHtml(newValue);
            });
          }
        });
        if (attr.bsModal) {
          scope.$watch(attr.bsModal, function(newValue, oldValue) {
            if (angular.isObject(newValue)) {
              angular.extend(scope, newValue);
            } else {
              scope.content = newValue;
            }
          }, true);
        }
        var modal = $modal(options);
        element.on(attr.trigger || 'click', modal.toggle);
        scope.$on('$destroy', function() {
          if (modal) modal.destroy();
          options = null;
          modal = null;
        });
      }
    };
  } ]);
  if (angular.version.minor < 3 && angular.version.dot < 14) {
    angular.module('ng').factory('$$rAF', [ '$window', '$timeout', function($window, $timeout) {
      var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame;
      var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.mozCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
      var rafSupported = !!requestAnimationFrame;
      var raf = rafSupported ? function(fn) {
        var id = requestAnimationFrame(fn);
        return function() {
          cancelAnimationFrame(id);
        };
      } : function(fn) {
        var timer = $timeout(fn, 16.66, false);
        return function() {
          $timeout.cancel(timer);
        };
      };
      raf.supported = rafSupported;
      return raf;
    } ]);
  }
  angular.module('mgcrea.ngStrap.helpers.parseOptions', []).provider('$parseOptions', function() {
    var defaults = this.defaults = {
      regexp: /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/
    };
    this.$get = [ '$parse', '$q', function($parse, $q) {
      function ParseOptionsFactory(attr, config) {
        var $parseOptions = {};
        var options = angular.extend({}, defaults, config);
        $parseOptions.$values = [];
        var match;
        var displayFn;
        var valueName;
        var keyName;
        var groupByFn;
        var valueFn;
        var valuesFn;
        $parseOptions.init = function() {
          $parseOptions.$match = match = attr.match(options.regexp);
          displayFn = $parse(match[2] || match[1]);
          valueName = match[4] || match[6];
          keyName = match[5];
          groupByFn = $parse(match[3] || '');
          valueFn = $parse(match[2] ? match[1] : valueName);
          valuesFn = $parse(match[7]);
        };
        $parseOptions.valuesFn = function(scope, controller) {
          return $q.when(valuesFn(scope, controller)).then(function(values) {
            if (!angular.isArray(values)) {
              values = [];
            }
            $parseOptions.$values = values.length ? parseValues(values, scope) : [];
            return $parseOptions.$values;
          });
        };
        $parseOptions.displayValue = function(modelValue) {
          var scope = {};
          scope[valueName] = modelValue;
          return displayFn(scope);
        };
        function parseValues(values, scope) {
          return values.map(function(match, index) {
            var locals = {};
            var label;
            var value;
            locals[valueName] = match;
            label = displayFn(scope, locals);
            value = valueFn(scope, locals);
            return {
              label: label,
              value: value,
              index: index
            };
          });
        }
        $parseOptions.init();
        return $parseOptions;
      }
      return ParseOptionsFactory;
    } ];
  });
  angular.module('mgcrea.ngStrap.helpers.dimensions', []).factory('dimensions', function() {
    var fn = {};
    var nodeName = fn.nodeName = function(element, name) {
      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();
    };
    fn.css = function(element, prop, extra) {
      var value;
      if (element.currentStyle) {
        value = element.currentStyle[prop];
      } else if (window.getComputedStyle) {
        value = window.getComputedStyle(element)[prop];
      } else {
        value = element.style[prop];
      }
      return extra === true ? parseFloat(value) || 0 : value;
    };
    fn.offset = function(element) {
      var boxRect = element.getBoundingClientRect();
      var docElement = element.ownerDocument;
      return {
        width: boxRect.width || element.offsetWidth,
        height: boxRect.height || element.offsetHeight,
        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),
        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)
      };
    };
    fn.setOffset = function(element, options, i) {
      var curPosition;
      var curLeft;
      var curCSSTop;
      var curTop;
      var curOffset;
      var curCSSLeft;
      var calculatePosition;
      var position = fn.css(element, 'position');
      var curElem = angular.element(element);
      var props = {};
      if (position === 'static') {
        element.style.position = 'relative';
      }
      curOffset = fn.offset(element);
      curCSSTop = fn.css(element, 'top');
      curCSSLeft = fn.css(element, 'left');
      calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
      if (calculatePosition) {
        curPosition = fn.position(element);
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (angular.isFunction(options)) {
        options = options.call(element, i, curOffset);
      }
      if (options.top !== null) {
        props.top = options.top - curOffset.top + curTop;
      }
      if (options.left !== null) {
        props.left = options.left - curOffset.left + curLeft;
      }
      if ('using' in options) {
        options.using.call(curElem, props);
      } else {
        curElem.css({
          top: props.top + 'px',
          left: props.left + 'px'
        });
      }
    };
    fn.position = function(element) {
      var offsetParentRect = {
        top: 0,
        left: 0
      };
      var offsetParentEl;
      var offset;
      if (fn.css(element, 'position') === 'fixed') {
        offset = element.getBoundingClientRect();
      } else {
        offsetParentEl = offsetParentElement(element);
        offset = fn.offset(element);
        if (!nodeName(offsetParentEl, 'html')) {
          offsetParentRect = fn.offset(offsetParentEl);
        }
        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);
        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);
      }
      return {
        width: element.offsetWidth,
        height: element.offsetHeight,
        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),
        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)
      };
    };
    function offsetParentElement(element) {
      var docElement = element.ownerDocument;
      var offsetParent = element.offsetParent || docElement;
      if (nodeName(offsetParent, '#document')) return docElement.documentElement;
      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docElement.documentElement;
    }
    fn.height = function(element, outer) {
      var value = element.offsetHeight;
      if (outer) {
        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);
      } else {
        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);
      }
      return value;
    };
    fn.width = function(element, outer) {
      var value = element.offsetWidth;
      if (outer) {
        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);
      } else {
        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);
      }
      return value;
    };
    return fn;
  });
  angular.module('mgcrea.ngStrap.helpers.debounce', []).factory('debounce', [ '$timeout', function($timeout) {
    return function(func, wait, immediate) {
      var timeout = null;
      return function() {
        var context = this;
        var args = arguments;
        var callNow = immediate && !timeout;
        if (timeout) {
          $timeout.cancel(timeout);
        }
        timeout = $timeout(function later() {
          timeout = null;
          if (!immediate) {
            func.apply(context, args);
          }
        }, wait, false);
        if (callNow) {
          func.apply(context, args);
        }
        return timeout;
      };
    };
  } ]).factory('throttle', [ '$timeout', function($timeout) {
    return function(func, wait, options) {
      var timeout = null;
      if (!options) options = {};
      return function() {
        var context = this;
        var args = arguments;
        if (!timeout) {
          if (options.leading !== false) {
            func.apply(context, args);
          }
          timeout = $timeout(function later() {
            timeout = null;
            if (options.trailing !== false) {
              func.apply(context, args);
            }
          }, wait, false);
        }
      };
    };
  } ]);
  angular.module('mgcrea.ngStrap.helpers.dateParser', []).provider('$dateParser', [ '$localeProvider', function($localeProvider) {
    function ParseDate() {
      this.year = 1970;
      this.month = 0;
      this.day = 1;
      this.hours = 0;
      this.minutes = 0;
      this.seconds = 0;
      this.milliseconds = 0;
    }
    ParseDate.prototype.setMilliseconds = function(value) {
      this.milliseconds = value;
    };
    ParseDate.prototype.setSeconds = function(value) {
      this.seconds = value;
    };
    ParseDate.prototype.setMinutes = function(value) {
      this.minutes = value;
    };
    ParseDate.prototype.setHours = function(value) {
      this.hours = value;
    };
    ParseDate.prototype.getHours = function() {
      return this.hours;
    };
    ParseDate.prototype.setDate = function(value) {
      this.day = value;
    };
    ParseDate.prototype.setMonth = function(value) {
      this.month = value;
    };
    ParseDate.prototype.setFullYear = function(value) {
      this.year = value;
    };
    ParseDate.prototype.fromDate = function(value) {
      this.year = value.getFullYear();
      this.month = value.getMonth();
      this.day = value.getDate();
      this.hours = value.getHours();
      this.minutes = value.getMinutes();
      this.seconds = value.getSeconds();
      this.milliseconds = value.getMilliseconds();
      return this;
    };
    ParseDate.prototype.toDate = function() {
      return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);
    };
    var proto = ParseDate.prototype;
    function noop() {}
    function isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    function indexOfCaseInsensitive(array, value) {
      var len = array.length;
      var str = value.toString().toLowerCase();
      for (var i = 0; i < len; i++) {
        if (array[i].toLowerCase() === str) {
          return i;
        }
      }
      return -1;
    }
    var defaults = this.defaults = {
      format: 'shortDate',
      strict: false
    };
    this.$get = [ '$locale', 'dateFilter', function($locale, dateFilter) {
      var DateParserFactory = function(config) {
        var options = angular.extend({}, defaults, config);
        var $dateParser = {};
        var regExpMap = {
          sss: '[0-9]{3}',
          ss: '[0-5][0-9]',
          s: options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',
          mm: '[0-5][0-9]',
          m: options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',
          HH: '[01][0-9]|2[0-3]',
          H: options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',
          hh: '[0][1-9]|[1][012]',
          h: options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',
          a: 'AM|PM',
          EEEE: $locale.DATETIME_FORMATS.DAY.join('|'),
          EEE: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
          dd: '0[1-9]|[12][0-9]|3[01]',
          d: options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',
          MMMM: $locale.DATETIME_FORMATS.MONTH.join('|'),
          MMM: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
          MM: '0[1-9]|1[012]',
          M: options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',
          yyyy: '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',
          yy: '[0-9]{2}',
          y: options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'
        };
        var setFnMap = {
          sss: proto.setMilliseconds,
          ss: proto.setSeconds,
          s: proto.setSeconds,
          mm: proto.setMinutes,
          m: proto.setMinutes,
          HH: proto.setHours,
          H: proto.setHours,
          hh: proto.setHours,
          h: proto.setHours,
          EEEE: noop,
          EEE: noop,
          dd: proto.setDate,
          d: proto.setDate,
          a: function(value) {
            var hours = this.getHours() % 12;
            return this.setHours(value.match(/pm/i) ? hours + 12 : hours);
          },
          MMMM: function(value) {
            return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value));
          },
          MMM: function(value) {
            return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value));
          },
          MM: function(value) {
            return this.setMonth(1 * value - 1);
          },
          M: function(value) {
            return this.setMonth(1 * value - 1);
          },
          yyyy: proto.setFullYear,
          yy: function(value) {
            return this.setFullYear(2e3 + 1 * value);
          },
          y: function(value) {
            return 1 * value <= 50 && value.length === 2 ? this.setFullYear(2e3 + 1 * value) : this.setFullYear(1 * value);
          }
        };
        var regex;
        var setMap;
        $dateParser.init = function() {
          $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;
          regex = regExpForFormat($dateParser.$format);
          setMap = setMapForFormat($dateParser.$format);
        };
        $dateParser.isValid = function(date) {
          if (angular.isDate(date)) return !isNaN(date.getTime());
          return regex.test(date);
        };
        $dateParser.parse = function(value, baseDate, format, timezone) {
          if (format) format = $locale.DATETIME_FORMATS[format] || format;
          if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);
          var formatRegex = format ? regExpForFormat(format) : regex;
          var formatSetMap = format ? setMapForFormat(format) : setMap;
          var matches = formatRegex.exec(value);
          if (!matches) return false;
          var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));
          for (var i = 0; i < matches.length - 1; i++) {
            if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);
          }
          var newDate = date.toDate();
          if (parseInt(date.day, 10) !== newDate.getDate()) {
            return false;
          }
          return newDate;
        };
        $dateParser.getDateForAttribute = function(key, value) {
          var date;
          if (value === 'today') {
            var today = new Date();
            date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, key === 'minDate' ? 0 : -1);
          } else if (angular.isString(value) && value.match(/^".+"$/)) {
            date = new Date(value.substr(1, value.length - 2));
          } else if (isNumeric(value)) {
            date = new Date(parseInt(value, 10));
          } else if (angular.isString(value) && value.length === 0) {
            date = key === 'minDate' ? -Infinity : +Infinity;
          } else {
            date = new Date(value);
          }
          return date;
        };
        $dateParser.getTimeForAttribute = function(key, value) {
          var time;
          if (value === 'now') {
            time = new Date().setFullYear(1970, 0, 1);
          } else if (angular.isString(value) && value.match(/^".+"$/)) {
            time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);
          } else if (isNumeric(value)) {
            time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);
          } else if (angular.isString(value) && value.length === 0) {
            time = key === 'minTime' ? -Infinity : +Infinity;
          } else {
            time = $dateParser.parse(value, new Date(1970, 0, 1, 0));
          }
          return time;
        };
        $dateParser.daylightSavingAdjust = function(date) {
          if (!date) {
            return null;
          }
          date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
          return date;
        };
        $dateParser.timezoneOffsetAdjust = function(date, timezone, undo) {
          if (!date) {
            return null;
          }
          if (timezone && timezone === 'UTC') {
            date = new Date(date.getTime());
            date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());
          }
          return date;
        };
        function regExpForFormat(format) {
          var re = buildDateAbstractRegex(format);
          return buildDateParseRegex(re);
        }
        function buildDateAbstractRegex(format) {
          var escapedFormat = escapeReservedSymbols(format);
          var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\'');
          var literalRegex = /('(?:\\'|.)*?')/;
          var formatParts = escapedLiteralFormat.split(literalRegex);
          var dateElements = Object.keys(regExpMap);
          var dateRegexParts = [];
          angular.forEach(formatParts, function(part) {
            if (isFormatStringLiteral(part)) {
              part = trimLiteralEscapeChars(part);
            } else {
              for (var i = 0; i < dateElements.length; i++) {
                part = part.split(dateElements[i]).join('${' + i + '}');
              }
            }
            dateRegexParts.push(part);
          });
          return dateRegexParts.join('');
        }
        function escapeReservedSymbols(text) {
          return text.replace(/\\/g, '[\\\\]').replace(/-/g, '[-]').replace(/\./g, '[.]').replace(/\*/g, '[*]').replace(/\+/g, '[+]').replace(/\?/g, '[?]').replace(/\$/g, '[$]').replace(/\^/g, '[^]').replace(/\//g, '[/]').replace(/\\s/g, '[\\s]');
        }
        function isFormatStringLiteral(text) {
          return /^'.*'$/.test(text);
        }
        function trimLiteralEscapeChars(text) {
          return text.replace(/^'(.*)'$/, '$1');
        }
        function buildDateParseRegex(abstractRegex) {
          var dateElements = Object.keys(regExpMap);
          var re = abstractRegex;
          for (var i = 0; i < dateElements.length; i++) {
            re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');
          }
          return new RegExp('^' + re + '$', [ 'i' ]);
        }
        function setMapForFormat(format) {
          var re = buildDateAbstractRegex(format);
          return buildDateParseValuesMap(re);
        }
        function buildDateParseValuesMap(abstractRegex) {
          var dateElements = Object.keys(regExpMap);
          var valuesRegex = new RegExp('\\${(\\d+)}', 'g');
          var valuesMatch;
          var keyIndex;
          var valueKey;
          var valueFunction;
          var valuesFunctionMap = [];
          while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {
            keyIndex = valuesMatch[1];
            valueKey = dateElements[keyIndex];
            valueFunction = setFnMap[valueKey];
            valuesFunctionMap.push(valueFunction);
          }
          return valuesFunctionMap;
        }
        $dateParser.init();
        return $dateParser;
      };
      return DateParserFactory;
    } ];
  } ]);
  angular.module('mgcrea.ngStrap.helpers.dateFormatter', []).service('$dateFormatter', [ '$locale', 'dateFilter', function($locale, dateFilter) {
    this.getDefaultLocale = function() {
      return $locale.id;
    };
    this.getDatetimeFormat = function(format, lang) {
      return $locale.DATETIME_FORMATS[format] || format;
    };
    this.weekdaysShort = function(lang) {
      return $locale.DATETIME_FORMATS.SHORTDAY;
    };
    function splitTimeFormat(format) {
      return /(h+)([:\.])?(m+)([:\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);
    }
    this.hoursFormat = function(timeFormat) {
      return splitTimeFormat(timeFormat)[0];
    };
    this.minutesFormat = function(timeFormat) {
      return splitTimeFormat(timeFormat)[2];
    };
    this.secondsFormat = function(timeFormat) {
      return splitTimeFormat(timeFormat)[4];
    };
    this.timeSeparator = function(timeFormat) {
      return splitTimeFormat(timeFormat)[1];
    };
    this.showSeconds = function(timeFormat) {
      return !!splitTimeFormat(timeFormat)[4];
    };
    this.showAM = function(timeFormat) {
      return !!splitTimeFormat(timeFormat)[5];
    };
    this.formatDate = function(date, format, lang, timezone) {
      return dateFilter(date, format, timezone);
    };
  } ]);
  angular.module('mgcrea.ngStrap.core', []).service('$bsCompiler', bsCompilerService);
  function bsCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {
    this.compile = function(options) {
      if (options.template && /\.html$/.test(options.template)) {
        console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');
        options.templateUrl = options.template;
        options.template = '';
      }
      var templateUrl = options.templateUrl;
      var template = options.template || '';
      var controller = options.controller;
      var controllerAs = options.controllerAs;
      var resolve = options.resolve || {};
      var locals = options.locals || {};
      var transformTemplate = options.transformTemplate || angular.identity;
      var bindToController = options.bindToController;
      angular.forEach(resolve, function(value, key) {
        if (angular.isString(value)) {
          resolve[key] = $injector.get(value);
        } else {
          resolve[key] = $injector.invoke(value);
        }
      });
      angular.extend(resolve, locals);
      if (template) {
        resolve.$template = $q.when(template);
      } else if (templateUrl) {
        resolve.$template = fetchTemplate(templateUrl);
      } else {
        throw new Error('Missing `template` / `templateUrl` option.');
      }
      if (options.titleTemplate) {
        resolve.$template = $q.all([ resolve.$template, fetchTemplate(options.titleTemplate) ]).then(function(templates) {
          var templateEl = angular.element(templates[0]);
          findElement('[ng-bind="title"]', templateEl[0]).removeAttr('ng-bind').html(templates[1]);
          return templateEl[0].outerHTML;
        });
      }
      if (options.contentTemplate) {
        resolve.$template = $q.all([ resolve.$template, fetchTemplate(options.contentTemplate) ]).then(function(templates) {
          var templateEl = angular.element(templates[0]);
          var contentEl = findElement('[ng-bind="content"]', templateEl[0]).removeAttr('ng-bind').html(templates[1]);
          if (!options.templateUrl) contentEl.next().remove();
          return templateEl[0].outerHTML;
        });
      }
      return $q.all(resolve).then(function(locals) {
        var template = transformTemplate(locals.$template);
        if (options.html) {
          template = template.replace(/ng-bind="/gi, 'ng-bind-html="');
        }
        var element = angular.element('<div>').html(template.trim()).contents();
        var linkFn = $compile(element);
        return {
          locals: locals,
          element: element,
          link: function link(scope) {
            locals.$scope = scope;
            if (controller) {
              var invokeCtrl = $controller(controller, locals, true);
              if (bindToController) {
                angular.extend(invokeCtrl.instance, locals);
              }
              var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();
              element.data('$ngControllerController', ctrl);
              element.children().data('$ngControllerController', ctrl);
              if (controllerAs) {
                scope[controllerAs] = ctrl;
              }
            }
            return linkFn.apply(null, arguments);
          }
        };
      });
    };
    function findElement(query, element) {
      return angular.element((element || document).querySelectorAll(query));
    }
    var fetchPromises = {};
    function fetchTemplate(template) {
      if (fetchPromises[template]) return fetchPromises[template];
      return fetchPromises[template] = $http.get(template, {
        cache: $templateCache
      }).then(function(res) {
        return res.data;
      });
    }
  }
  angular.module('mgcrea.ngStrap.dropdown', [ 'mgcrea.ngStrap.tooltip' ]).provider('$dropdown', function() {
    var defaults = this.defaults = {
      animation: 'am-fade',
      prefixClass: 'dropdown',
      prefixEvent: 'dropdown',
      placement: 'bottom-left',
      templateUrl: 'dropdown/dropdown.tpl.html',
      trigger: 'click',
      container: false,
      keyboard: true,
      html: false,
      delay: 0
    };
    this.$get = [ '$window', '$rootScope', '$tooltip', '$timeout', function($window, $rootScope, $tooltip, $timeout) {
      var bodyEl = angular.element($window.document.body);
      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;
      function DropdownFactory(element, config) {
        var $dropdown = {};
        var options = angular.extend({}, defaults, config);
        $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();
        $dropdown = $tooltip(element, options);
        var parentEl = element.parent();
        $dropdown.$onKeyDown = function(evt) {
          if (!/(38|40)/.test(evt.keyCode)) return;
          evt.preventDefault();
          evt.stopPropagation();
          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));
          if (!items.length) return;
          var index;
          angular.forEach(items, function(el, i) {
            if (matchesSelector && matchesSelector.call(el, ':focus')) index = i;
          });
          if (evt.keyCode === 38 && index > 0) index--; else if (evt.keyCode === 40 && index < items.length - 1) index++; else if (angular.isUndefined(index)) index = 0;
          items.eq(index)[0].focus();
        };
        var show = $dropdown.show;
        $dropdown.show = function() {
          show();
          $timeout(function() {
            if (options.keyboard && $dropdown.$element) $dropdown.$element.on('keydown', $dropdown.$onKeyDown);
            bodyEl.on('click', onBodyClick);
          }, 0, false);
          if (parentEl.hasClass('dropdown')) parentEl.addClass('open');
        };
        var hide = $dropdown.hide;
        $dropdown.hide = function() {
          if (!$dropdown.$isShown) return;
          if (options.keyboard && $dropdown.$element) $dropdown.$element.off('keydown', $dropdown.$onKeyDown);
          bodyEl.off('click', onBodyClick);
          if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');
          hide();
        };
        var destroy = $dropdown.destroy;
        $dropdown.destroy = function() {
          bodyEl.off('click', onBodyClick);
          destroy();
        };
        function onBodyClick(evt) {
          if (evt.target === element[0]) return;
          return evt.target !== element[0] && $dropdown.hide();
        }
        return $dropdown;
      }
      return DropdownFactory;
    } ];
  }).directive('bsDropdown', [ '$window', '$sce', '$dropdown', function($window, $sce, $dropdown) {
    return {
      restrict: 'EAC',
      scope: true,
      compile: function(tElement, tAttrs) {
        if (!tAttrs.bsDropdown) {
          var nextSibling = tElement[0].nextSibling;
          while (nextSibling && nextSibling.nodeType !== 1) {
            nextSibling = nextSibling.nextSibling;
          }
          if (nextSibling && nextSibling.className.split(' ').indexOf('dropdown-menu') >= 0) {
            tAttrs.template = nextSibling.outerHTML;
            tAttrs.templateUrl = undefined;
            nextSibling.parentNode.removeChild(nextSibling);
          }
        }
        return function postLink(scope, element, attr) {
          var options = {
            scope: scope
          };
          angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose' ], function(key) {
            if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];
          });
          var falseValueRegExp = /^(false|0|)$/i;
          angular.forEach([ 'html', 'container' ], function(key) {
            if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;
          });
          angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide' ], function(key) {
            var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);
            if (angular.isDefined(attr[bsKey])) {
              options[key] = scope.$eval(attr[bsKey]);
            }
          });
          if (attr.bsDropdown) {
            scope.$watch(attr.bsDropdown, function(newValue, oldValue) {
              scope.content = newValue;
            }, true);
          }
          var dropdown = $dropdown(element, options);
          if (attr.bsShow) {
            scope.$watch(attr.bsShow, function(newValue, oldValue) {
              if (!dropdown || !angular.isDefined(newValue)) return;
              if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);
              if (newValue === true) {
                dropdown.show();
              } else {
                dropdown.hide();
              }
            });
          }
          scope.$on('$destroy', function() {
            if (dropdown) dropdown.destroy();
            options = null;
            dropdown = null;
          });
        };
      }
    };
  } ]);
  angular.module('mgcrea.ngStrap.button', []).provider('$button', function() {
    var defaults = this.defaults = {
      activeClass: 'active',
      toggleEvent: 'click'
    };
    this.$get = function() {
      return {
        defaults: defaults
      };
    };
  }).directive('bsCheckboxGroup', function() {
    return {
      restrict: 'A',
      require: 'ngModel',
      compile: function postLink(element, attr) {
        element.attr('data-toggle', 'buttons');
        element.removeAttr('ng-model');
        var children = element[0].querySelectorAll('input[type="checkbox"]');
        angular.forEach(children, function(child) {
          var childEl = angular.element(child);
          childEl.attr('bs-checkbox', '');
          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));
        });
      }
    };
  }).directive('bsCheckbox', [ '$button', '$$rAF', function($button, $$rAF) {
    var defaults = $button.defaults;
    var constantValueRegExp = /^(true|false|\d+)$/;
    return {
      restrict: 'A',
      require: 'ngModel',
      link: function postLink(scope, element, attr, controller) {
        var options = defaults;
        var isInput = element[0].nodeName === 'INPUT';
        var activeElement = isInput ? element.parent() : element;
        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;
        if (constantValueRegExp.test(attr.trueValue)) {
          trueValue = scope.$eval(attr.trueValue);
        }
        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;
        if (constantValueRegExp.test(attr.falseValue)) {
          falseValue = scope.$eval(attr.falseValue);
        }
        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';
        if (hasExoticValues) {
          controller.$parsers.push(function(viewValue) {
            return viewValue ? trueValue : falseValue;
          });
          controller.$formatters.push(function(modelValue) {
            return angular.equals(modelValue, trueValue);
          });
        }
        controller.$render = function() {
          var isActive = !!controller.$viewValue;
          $$rAF(function() {
            if (isInput) element[0].checked = isActive;
            activeElement.toggleClass(options.activeClass, isActive);
          });
        };
        element.bind(options.toggleEvent, function() {
          scope.$apply(function() {
            if (!isInput) {
              controller.$setViewValue(!activeElement.hasClass('active'));
            }
            controller.$render();
          });
        });
      }
    };
  } ]).directive('bsRadioGroup', function() {
    return {
      restrict: 'A',
      require: 'ngModel',
      compile: function postLink(element, attr) {
        element.attr('data-toggle', 'buttons');
        element.removeAttr('ng-model');
        var children = element[0].querySelectorAll('input[type="radio"]');
        angular.forEach(children, function(child) {
          angular.element(child).attr('bs-radio', '');
          angular.element(child).attr('ng-model', attr.ngModel);
        });
      }
    };
  }).directive('bsRadio', [ '$button', '$$rAF', function($button, $$rAF) {
    var defaults = $button.defaults;
    var constantValueRegExp = /^(true|false|\d+)$/;
    return {
      restrict: 'A',
      require: 'ngModel',
      link: function postLink(scope, element, attr, controller) {
        var options = defaults;
        var isInput = element[0].nodeName === 'INPUT';
        var activeElement = isInput ? element.parent() : element;
        var value;
        attr.$observe('value', function(v) {
          if (typeof v !== 'boolean' && constantValueRegExp.test(v)) {
            value = scope.$eval(v);
          } else {
            value = v;
          }
          controller.$render();
        });
        controller.$render = function() {
          var isActive = angular.equals(controller.$viewValue, value);
          $$rAF(function() {
            if (isInput) element[0].checked = isActive;
            activeElement.toggleClass(options.activeClass, isActive);
          });
        };
        element.bind(options.toggleEvent, function() {
          scope.$apply(function() {
            controller.$setViewValue(value);
            controller.$render();
          });
        });
      }
    };
  } ]);
  angular.module('mgcrea.ngStrap.datepicker', [ 'mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip' ]).provider('$datepicker', function() {
    var defaults = this.defaults = {
      animation: 'am-fade',
      prefixClass: 'datepicker',
      placement: 'bottom-left',
      templateUrl: 'datepicker/datepicker.tpl.html',
      trigger: 'focus',
      container: false,
      keyboard: true,
      html: false,
      delay: 0,
      useNative: false,
      dateType: 'date',
      dateFormat: 'shortDate',
      timezone: null,
      modelDateFormat: null,
      dayFormat: 'dd',
      monthFormat: 'MMM',
      yearFormat: 'yyyy',
      monthTitleFormat: 'MMMM yyyy',
      yearTitleFormat: 'yyyy',
      strictFormat: false,
      autoclose: false,
      minDate: -Infinity,
      maxDate: +Infinity,
      startView: 0,
      minView: 0,
      startWeek: 0,
      daysOfWeekDisabled: '',
      hasToday: false,
      hasClear: false,
      iconLeft: 'glyphicon glyphicon-chevron-left',
      iconRight: 'glyphicon glyphicon-chevron-right'
    };
    this.$get = [ '$window', '$document', '$rootScope', '$sce', '$dateFormatter', 'datepickerViews', '$tooltip', '$timeout', function($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {
      var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);
      var isTouch = 'createTouch' in $window.document && isNative;
      if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();
      function DatepickerFactory(element, controller, config) {
        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));
        var parentScope = config.scope;
        var options = $datepicker.$options;
        var scope = $datepicker.$scope;
        if (options.startView) options.startView -= options.minView;
        var pickerViews = datepickerViews($datepicker);
        $datepicker.$views = pickerViews.views;
        var viewDate = pickerViews.viewDate;
        scope.$mode = options.startView;
        scope.$iconLeft = options.iconLeft;
        scope.$iconRight = options.iconRight;
        scope.$hasToday = options.hasToday;
        scope.$hasClear = options.hasClear;
        var $picker = $datepicker.$views[scope.$mode];
        scope.$select = function(date, disabled) {
          if (disabled) return;
          $datepicker.select(date);
        };
        scope.$selectPane = function(value) {
          $datepicker.$selectPane(value);
        };
        scope.$toggleMode = function() {
          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);
        };
        scope.$setToday = function() {
          if (options.autoclose) {
            $datepicker.setMode(0);
            $datepicker.select(new Date());
          } else {
            $datepicker.select(new Date(), true);
          }
        };
        scope.$clear = function() {
          if (options.autoclose) {
            $datepicker.setMode(0);
            $datepicker.select(null);
          } else {
            $datepicker.select(null, true);
          }
        };
        $datepicker.update = function(date) {
          if (angular.isDate(date) && !isNaN(date.getTime())) {
            $datepicker.$date = date;
            $picker.update.call($picker, date);
          }
          $datepicker.$build(true);
        };
        $datepicker.updateDisabledDates = function(dateRanges) {
          options.disabledDateRanges = dateRanges;
          for (var i = 0, l = scope.rows.length; i < l; i++) {
            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);
          }
        };
        $datepicker.select = function(date, keep) {
          if (angular.isDate(date)) {
            if (!angular.isDate(controller.$dateValue) || isNaN(controller.$dateValue.getTime())) {
              controller.$dateValue = new Date(date);
            }
          } else {
            controller.$dateValue = null;
          }
          if (!scope.$mode || keep) {
            controller.$setViewValue(angular.copy(date));
            controller.$render();
            if (options.autoclose && !keep) {
              $timeout(function() {
                $datepicker.hide(true);
              });
            }
          } else {
            angular.extend(viewDate, {
              year: date.getFullYear(),
              month: date.getMonth(),
              date: date.getDate()
            });
            $datepicker.setMode(scope.$mode - 1);
            $datepicker.$build();
          }
        };
        $datepicker.setMode = function(mode) {
          scope.$mode = mode;
          $picker = $datepicker.$views[scope.$mode];
          $datepicker.$build();
        };
        $datepicker.$build = function(pristine) {
          if (pristine === true && $picker.built) return;
          if (pristine === false && !$picker.built) return;
          $picker.build.call($picker);
        };
        $datepicker.$updateSelected = function() {
          for (var i = 0, l = scope.rows.length; i < l; i++) {
            angular.forEach(scope.rows[i], updateSelected);
          }
        };
        $datepicker.$isSelected = function(date) {
          return $picker.isSelected(date);
        };
        $datepicker.$setDisabledEl = function(el) {
          el.disabled = $picker.isDisabled(el.date);
        };
        $datepicker.$selectPane = function(value) {
          var steps = $picker.steps;
          var targetDate = new Date(Date.UTC(viewDate.year + (steps.year || 0) * value, viewDate.month + (steps.month || 0) * value, 1));
          angular.extend(viewDate, {
            year: targetDate.getUTCFullYear(),
            month: targetDate.getUTCMonth(),
            date: targetDate.getUTCDate()
          });
          $datepicker.$build();
        };
        $datepicker.$onMouseDown = function(evt) {
          evt.preventDefault();
          evt.stopPropagation();
          if (isTouch) {
            var targetEl = angular.element(evt.target);
            if (targetEl[0].nodeName.toLowerCase() !== 'button') {
              targetEl = targetEl.parent();
            }
            targetEl.triggerHandler('click');
          }
        };
        $datepicker.$onKeyDown = function(evt) {
          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;
          evt.preventDefault();
          evt.stopPropagation();
          if (evt.keyCode === 13) {
            if (!scope.$mode) {
              $datepicker.hide(true);
            } else {
              scope.$apply(function() {
                $datepicker.setMode(scope.$mode - 1);
              });
            }
            return;
          }
          $picker.onKeyDown(evt);
          parentScope.$digest();
        };
        function updateSelected(el) {
          el.selected = $datepicker.$isSelected(el.date);
        }
        function focusElement() {
          element[0].focus();
        }
        var _init = $datepicker.init;
        $datepicker.init = function() {
          if (isNative && options.useNative) {
            element.prop('type', 'date');
            element.css('-webkit-appearance', 'textfield');
            return;
          } else if (isTouch) {
            element.prop('type', 'text');
            element.attr('readonly', 'true');
            element.on('click', focusElement);
          }
          _init();
        };
        var _destroy = $datepicker.destroy;
        $datepicker.destroy = function() {
          if (isNative && options.useNative) {
            element.off('click', focusElement);
          }
          _destroy();
        };
        var _show = $datepicker.show;
        $datepicker.show = function() {
          if (!isTouch && element.attr('readonly') || element.attr('disabled')) return;
          _show();
          $timeout(function() {
            if (!$datepicker.$isShown) return;
            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);
            if (options.keyboard) {
              element.on('keydown', $datepicker.$onKeyDown);
            }
          }, 0, false);
        };
        var _hide = $datepicker.hide;
        $datepicker.hide = function(blur) {
          if (!$datepicker.$isShown) return;
          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);
          if (options.keyboard) {
            element.off('keydown', $datepicker.$onKeyDown);
          }
          _hide(blur);
        };
        return $datepicker;
      }
      DatepickerFactory.defaults = defaults;
      return DatepickerFactory;
    } ];
  }).directive('bsDatepicker', [ '$window', '$parse', '$q', '$dateFormatter', '$dateParser', '$datepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {
    var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);
    return {
      restrict: 'EAC',
      require: 'ngModel',
      link: function postLink(scope, element, attr, controller) {
        var options = {
          scope: scope
        };
        angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent', 'hasToday', 'hasClear' ], function(key) {
          if (angular.isDefined(attr[key])) options[key] = attr[key];
        });
        var falseValueRegExp = /^(false|0|)$/i;
        angular.forEach([ 'html', 'container', 'autoclose', 'useNative', 'hasToday', 'hasClear' ], function(key) {
          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {
            options[key] = false;
          }
        });
        angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide' ], function(key) {
          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);
          if (angular.isDefined(attr[bsKey])) {
            options[key] = scope.$eval(attr[bsKey]);
          }
        });
        var datepicker = $datepicker(element, controller, options);
        options = datepicker.$options;
        if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';
        var lang = options.lang;
        var formatDate = function(date, format) {
          return $dateFormatter.formatDate(date, format, lang);
        };
        var dateParser = $dateParser({
          format: options.dateFormat,
          lang: lang,
          strict: options.strictFormat
        });
        if (attr.bsShow) {
          scope.$watch(attr.bsShow, function(newValue, oldValue) {
            if (!datepicker || !angular.isDefined(newValue)) return;
            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);
            if (newValue === true) {
              datepicker.show();
            } else {
              datepicker.hide();
            }
          });
        }
        angular.forEach([ 'minDate', 'maxDate' ], function(key) {
          if (angular.isDefined(attr[key])) {
            attr.$observe(key, function(newValue) {
              datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);
              if (!isNaN(datepicker.$options[key])) datepicker.$build(false);
              validateAgainstMinMaxDate(controller.$dateValue);
            });
          }
        });
        if (angular.isDefined(attr.dateFormat)) {
          attr.$observe('dateFormat', function(newValue) {
            datepicker.$options.dateFormat = newValue;
          });
        }
        scope.$watch(attr.ngModel, function(newValue, oldValue) {
          datepicker.update(controller.$dateValue);
        }, true);
        function normalizeDateRanges(ranges) {
          if (!ranges || !ranges.length) return null;
          return ranges;
        }
        if (angular.isDefined(attr.disabledDates)) {
          scope.$watch(attr.disabledDates, function(disabledRanges, previousValue) {
            disabledRanges = normalizeDateRanges(disabledRanges);
            previousValue = normalizeDateRanges(previousValue);
            if (disabledRanges) {
              datepicker.updateDisabledDates(disabledRanges);
            }
          });
        }
        function validateAgainstMinMaxDate(parsedDate) {
          if (!angular.isDate(parsedDate)) return;
          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;
          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;
          var isValid = isMinValid && isMaxValid;
          controller.$setValidity('date', isValid);
          controller.$setValidity('min', isMinValid);
          controller.$setValidity('max', isMaxValid);
          if (isValid) controller.$dateValue = parsedDate;
        }
        controller.$parsers.unshift(function(viewValue) {
          var date;
          if (!viewValue) {
            controller.$setValidity('date', true);
            return null;
          }
          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);
          if (!parsedDate || isNaN(parsedDate.getTime())) {
            controller.$setValidity('date', false);
            return;
          }
          validateAgainstMinMaxDate(parsedDate);
          if (options.dateType === 'string') {
            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);
            return formatDate(date, options.modelDateFormat || options.dateFormat);
          }
          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);
          if (options.dateType === 'number') {
            return date.getTime();
          } else if (options.dateType === 'unix') {
            return date.getTime() / 1e3;
          } else if (options.dateType === 'iso') {
            return date.toISOString();
          }
          return new Date(date);
        });
        controller.$formatters.push(function(modelValue) {
          var date;
          if (angular.isUndefined(modelValue) || modelValue === null) {
            date = NaN;
          } else if (angular.isDate(modelValue)) {
            date = modelValue;
          } else if (options.dateType === 'string') {
            date = dateParser.parse(modelValue, null, options.modelDateFormat);
          } else if (options.dateType === 'unix') {
            date = new Date(modelValue * 1e3);
          } else {
            date = new Date(modelValue);
          }
          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);
          return getDateFormattedString();
        });
        controller.$render = function() {
          element.val(getDateFormattedString());
        };
        function getDateFormattedString() {
          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);
        }
        scope.$on('$destroy', function() {
          if (datepicker) datepicker.destroy();
          options = null;
          datepicker = null;
        });
      }
    };
  } ]).provider('datepickerViews', function() {
    function split(arr, size) {
      var arrays = [];
      while (arr.length > 0) {
        arrays.push(arr.splice(0, size));
      }
      return arrays;
    }
    function mod(n, m) {
      return (n % m + m) % m;
    }
    this.$get = [ '$dateFormatter', '$dateParser', '$sce', function($dateFormatter, $dateParser, $sce) {
      return function(picker) {
        var scope = picker.$scope;
        var options = picker.$options;
        var lang = options.lang;
        var formatDate = function(date, format) {
          return $dateFormatter.formatDate(date, format, lang);
        };
        var dateParser = $dateParser({
          format: options.dateFormat,
          lang: lang,
          strict: options.strictFormat
        });
        var weekDaysMin = $dateFormatter.weekdaysShort(lang);
        var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));
        var weekDaysLabelsHtml = $sce.trustAsHtml('<th class="dow text-center">' + weekDaysLabels.join('</th><th class="dow text-center">') + '</th>');
        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());
        var viewDate = {
          year: startDate.getFullYear(),
          month: startDate.getMonth(),
          date: startDate.getDate()
        };
        var views = [ {
          format: options.dayFormat,
          split: 7,
          steps: {
            month: 1
          },
          update: function(date, force) {
            if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {
              angular.extend(viewDate, {
                year: picker.$date.getFullYear(),
                month: picker.$date.getMonth(),
                date: picker.$date.getDate()
              });
              picker.$build();
            } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {
              viewDate.date = picker.$date.getDate();
              picker.$updateSelected();
            }
          },
          build: function() {
            var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);
            var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();
            var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);
            var firstDateOffset = firstDate.getTimezoneOffset();
            var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();
            if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 6e4);
            var days = [];
            var day;
            for (var i = 0; i < 42; i++) {
              day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));
              days.push({
                date: day,
                isToday: day.toDateString() === today,
                label: formatDate(day, this.format),
                selected: picker.$date && this.isSelected(day),
                muted: day.getMonth() !== viewDate.month,
                disabled: this.isDisabled(day)
              });
            }
            scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);
            scope.showLabels = true;
            scope.labels = weekDaysLabelsHtml;
            scope.rows = split(days, this.split);
            scope.isTodayDisabled = this.isDisabled(new Date());
            this.built = true;
          },
          isSelected: function(date) {
            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();
          },
          isDisabled: function(date) {
            var time = date.getTime();
            if (time < options.minDate || time > options.maxDate) return true;
            if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;
            if (options.disabledDateRanges) {
              for (var i = 0; i < options.disabledDateRanges.length; i++) {
                if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {
                  return true;
                }
              }
            }
            return false;
          },
          onKeyDown: function(evt) {
            if (!picker.$date) {
              return;
            }
            var actualTime = picker.$date.getTime();
            var newDate;
            if (evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5); else if (evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5); else if (evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5); else if (evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);
            if (!this.isDisabled(newDate)) picker.select(newDate, true);
          }
        }, {
          name: 'month',
          format: options.monthFormat,
          split: 4,
          steps: {
            year: 1
          },
          update: function(date, force) {
            if (!this.built || date.getFullYear() !== viewDate.year) {
              angular.extend(viewDate, {
                year: picker.$date.getFullYear(),
                month: picker.$date.getMonth(),
                date: picker.$date.getDate()
              });
              picker.$build();
            } else if (date.getMonth() !== viewDate.month) {
              angular.extend(viewDate, {
                month: picker.$date.getMonth(),
                date: picker.$date.getDate()
              });
              picker.$updateSelected();
            }
          },
          build: function() {
            var months = [];
            var month;
            for (var i = 0; i < 12; i++) {
              month = new Date(viewDate.year, i, 1);
              months.push({
                date: month,
                label: formatDate(month, this.format),
                selected: picker.$isSelected(month),
                disabled: this.isDisabled(month)
              });
            }
            scope.title = formatDate(month, options.yearTitleFormat);
            scope.showLabels = false;
            scope.rows = split(months, this.split);
            this.built = true;
          },
          isSelected: function(date) {
            return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();
          },
          isDisabled: function(date) {
            var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);
            return lastDate < options.minDate || date.getTime() > options.maxDate;
          },
          onKeyDown: function(evt) {
            if (!picker.$date) {
              return;
            }
            var actualMonth = picker.$date.getMonth();
            var newDate = new Date(picker.$date);
            if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1); else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4); else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1); else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);
            if (!this.isDisabled(newDate)) picker.select(newDate, true);
          }
        }, {
          name: 'year',
          format: options.yearFormat,
          split: 4,
          steps: {
            year: 12
          },
          update: function(date, force) {
            if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {
              angular.extend(viewDate, {
                year: picker.$date.getFullYear(),
                month: picker.$date.getMonth(),
                date: picker.$date.getDate()
              });
              picker.$build();
            } else if (date.getFullYear() !== viewDate.year) {
              angular.extend(viewDate, {
                year: picker.$date.getFullYear(),
                month: picker.$date.getMonth(),
                date: picker.$date.getDate()
              });
              picker.$updateSelected();
            }
          },
          build: function() {
            var firstYear = viewDate.year - viewDate.year % (this.split * 3);
            var years = [];
            var year;
            for (var i = 0; i < 12; i++) {
              year = new Date(firstYear + i, 0, 1);
              years.push({
                date: year,
                label: formatDate(year, this.format),
                selected: picker.$isSelected(year),
                disabled: this.isDisabled(year)
              });
            }
            scope.title = years[0].label + '-' + years[years.length - 1].label;
            scope.showLabels = false;
            scope.rows = split(years, this.split);
            this.built = true;
          },
          isSelected: function(date) {
            return picker.$date && date.getFullYear() === picker.$date.getFullYear();
          },
          isDisabled: function(date) {
            var lastDate = +new Date(date.getFullYear() + 1, 0, 0);
            return lastDate < options.minDate || date.getTime() > options.maxDate;
          },
          onKeyDown: function(evt) {
            if (!picker.$date) {
              return;
            }
            var actualYear = picker.$date.getFullYear();
            var newDate = new Date(picker.$date);
            if (evt.keyCode === 37) newDate.setYear(actualYear - 1); else if (evt.keyCode === 38) newDate.setYear(actualYear - 4); else if (evt.keyCode === 39) newDate.setYear(actualYear + 1); else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);
            if (!this.isDisabled(newDate)) picker.select(newDate, true);
          }
        } ];
        return {
          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,
          viewDate: viewDate
        };
      };
    } ];
  });
  angular.module('mgcrea.ngStrap.collapse', []).provider('$collapse', function() {
    var defaults = this.defaults = {
      animation: 'am-collapse',
      disallowToggle: false,
      activeClass: 'in',
      startCollapsed: false,
      allowMultiple: false
    };
    var controller = this.controller = function($scope, $element, $attrs) {
      var self = this;
      self.$options = angular.copy(defaults);
      angular.forEach([ 'animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple' ], function(key) {
        if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];
      });
      var falseValueRegExp = /^(false|0|)$/i;
      angular.forEach([ 'disallowToggle', 'startCollapsed', 'allowMultiple' ], function(key) {
        if (angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {
          self.$options[key] = false;
        }
      });
      self.$toggles = [];
      self.$targets = [];
      self.$viewChangeListeners = [];
      self.$registerToggle = function(element) {
        self.$toggles.push(element);
      };
      self.$registerTarget = function(element) {
        self.$targets.push(element);
      };
      self.$unregisterToggle = function(element) {
        var index = self.$toggles.indexOf(element);
        self.$toggles.splice(index, 1);
      };
      self.$unregisterTarget = function(element) {
        var index = self.$targets.indexOf(element);
        self.$targets.splice(index, 1);
        if (self.$options.allowMultiple) {
          deactivateItem(element);
        }
        fixActiveItemIndexes(index);
        self.$viewChangeListeners.forEach(function(fn) {
          fn();
        });
      };
      self.$targets.$active = !self.$options.startCollapsed ? [ 0 ] : [];
      self.$setActive = $scope.$setActive = function(value) {
        if (angular.isArray(value)) {
          self.$targets.$active = value;
        } else if (!self.$options.disallowToggle && isActive(value)) {
          deactivateItem(value);
        } else {
          activateItem(value);
        }
        self.$viewChangeListeners.forEach(function(fn) {
          fn();
        });
      };
      self.$activeIndexes = function() {
        if (self.$options.allowMultiple) {
          return self.$targets.$active;
        }
        return self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;
      };
      function fixActiveItemIndexes(index) {
        var activeIndexes = self.$targets.$active;
        for (var i = 0; i < activeIndexes.length; i++) {
          if (index < activeIndexes[i]) {
            activeIndexes[i] = activeIndexes[i] - 1;
          }
          if (activeIndexes[i] === self.$targets.length) {
            activeIndexes[i] = self.$targets.length - 1;
          }
        }
      }
      function isActive(value) {
        var activeItems = self.$targets.$active;
        return activeItems.indexOf(value) !== -1;
      }
      function deactivateItem(value) {
        var index = self.$targets.$active.indexOf(value);
        if (index !== -1) {
          self.$targets.$active.splice(index, 1);
        }
      }
      function activateItem(value) {
        if (!self.$options.allowMultiple) {
          self.$targets.$active.splice(0, 1);
        }
        if (self.$targets.$active.indexOf(value) === -1) {
          self.$targets.$active.push(value);
        }
      }
    };
    this.$get = function() {
      var $collapse = {};
      $collapse.defaults = defaults;
      $collapse.controller = controller;
      return $collapse;
    };
  }).directive('bsCollapse', [ '$window', '$animate', '$collapse', function($window, $animate, $collapse) {
    return {
      require: [ '?ngModel', 'bsCollapse' ],
      controller: [ '$scope', '$element', '$attrs', $collapse.controller ],
      link: function postLink(scope, element, attrs, controllers) {
        var ngModelCtrl = controllers[0];
        var bsCollapseCtrl = controllers[1];
        if (ngModelCtrl) {
          bsCollapseCtrl.$viewChangeListeners.push(function() {
            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());
          });
          ngModelCtrl.$formatters.push(function(modelValue) {
            if (angular.isArray(modelValue)) {
              bsCollapseCtrl.$setActive(modelValue);
            } else {
              var activeIndexes = bsCollapseCtrl.$activeIndexes();
              if (angular.isArray(activeIndexes)) {
                if (activeIndexes.indexOf(modelValue * 1) === -1) {
                  bsCollapseCtrl.$setActive(modelValue * 1);
                }
              } else if (activeIndexes !== modelValue * 1) {
                bsCollapseCtrl.$setActive(modelValue * 1);
              }
            }
            return modelValue;
          });
        }
      }
    };
  } ]).directive('bsCollapseToggle', function() {
    return {
      require: [ '^?ngModel', '^bsCollapse' ],
      link: function postLink(scope, element, attrs, controllers) {
        var bsCollapseCtrl = controllers[1];
        element.attr('data-toggle', 'collapse');
        bsCollapseCtrl.$registerToggle(element);
        scope.$on('$destroy', function() {
          bsCollapseCtrl.$unregisterToggle(element);
        });
        element.on('click', function() {
          if (!attrs.disabled) {
            var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);
            bsCollapseCtrl.$setActive(index * 1);
            scope.$apply();
          }
        });
      }
    };
  }).directive('bsCollapseTarget', [ '$animate', function($animate) {
    return {
      require: [ '^?ngModel', '^bsCollapse' ],
      link: function postLink(scope, element, attrs, controllers) {
        var bsCollapseCtrl = controllers[1];
        element.addClass('collapse');
        if (bsCollapseCtrl.$options.animation) {
          element.addClass(bsCollapseCtrl.$options.animation);
        }
        bsCollapseCtrl.$registerTarget(element);
        scope.$on('$destroy', function() {
          bsCollapseCtrl.$unregisterTarget(element);
        });
        function render() {
          var index = bsCollapseCtrl.$targets.indexOf(element);
          var active = bsCollapseCtrl.$activeIndexes();
          var action = 'removeClass';
          if (angular.isArray(active)) {
            if (active.indexOf(index) !== -1) {
              action = 'addClass';
            }
          } else if (index === active) {
            action = 'addClass';
          }
          $animate[action](element, bsCollapseCtrl.$options.activeClass);
        }
        bsCollapseCtrl.$viewChangeListeners.push(function() {
          render();
        });
        render();
      }
    };
  } ]);
  angular.module('mgcrea.ngStrap.aside', [ 'mgcrea.ngStrap.modal' ]).provider('$aside', function() {
    var defaults = this.defaults = {
      animation: 'am-fade-and-slide-right',
      prefixClass: 'aside',
      prefixEvent: 'aside',
      placement: 'right',
      templateUrl: 'aside/aside.tpl.html',
      contentTemplate: false,
      container: false,
      element: null,
      backdrop: true,
      keyboard: true,
      html: false,
      show: true
    };
    this.$get = [ '$modal', function($modal) {
      function AsideFactory(config) {
        var $aside = {};
        var options = angular.extend({}, defaults, config);
        $aside = $modal(options);
        return $aside;
      }
      return AsideFactory;
    } ];
  }).directive('bsAside', [ '$window', '$sce', '$aside', function($window, $sce, $aside) {
    return {
      restrict: 'EAC',
      scope: true,
      link: function postLink(scope, element, attr, transclusion) {
        var options = {
          scope: scope,
          element: element,
          show: false
        };
        angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation' ], function(key) {
          if (angular.isDefined(attr[key])) options[key] = attr[key];
        });
        var falseValueRegExp = /^(false|0|)$/i;
        angular.forEach([ 'backdrop', 'keyboard', 'html', 'container' ], function(key) {
          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;
        });
        angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide' ], function(key) {
          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);
          if (angular.isDefined(attr[bsKey])) {
            options[key] = scope.$eval(attr[bsKey]);
          }
        });
        angular.forEach([ 'title', 'content' ], function(key) {
          if (attr[key]) {
            attr.$observe(key, function(newValue, oldValue) {
              scope[key] = $sce.trustAsHtml(newValue);
            });
          }
        });
        if (attr.bsAside) {
          scope.$watch(attr.bsAside, function(newValue, oldValue) {
            if (angular.isObject(newValue)) {
              angular.extend(scope, newValue);
            } else {
              scope.content = newValue;
            }
          }, true);
        }
        var aside = $aside(options);
        element.on(attr.trigger || 'click', aside.toggle);
        scope.$on('$destroy', function() {
          if (aside) aside.destroy();
          options = null;
          aside = null;
        });
      }
    };
  } ]);
  angular.module('mgcrea.ngStrap.alert', [ 'mgcrea.ngStrap.modal' ]).provider('$alert', function() {
    var defaults = this.defaults = {
      animation: 'am-fade',
      prefixClass: 'alert',
      prefixEvent: 'alert',
      placement: null,
      templateUrl: 'alert/alert.tpl.html',
      container: false,
      element: null,
      backdrop: false,
      keyboard: true,
      show: true,
      duration: false,
      type: false,
      dismissable: true
    };
    this.$get = [ '$modal', '$timeout', function($modal, $timeout) {
      function AlertFactory(config) {
        var $alert = {};
        var options = angular.extend({}, defaults, config);
        $alert = $modal(options);
        $alert.$scope.dismissable = !!options.dismissable;
        if (options.type) {
          $alert.$scope.type = options.type;
        }
        var show = $alert.show;
        if (options.duration) {
          $alert.show = function() {
            show();
            $timeout(function() {
              $alert.hide();
            }, options.duration * 1e3);
          };
        }
        return $alert;
      }
      return AlertFactory;
    } ];
  }).directive('bsAlert', [ '$window', '$sce', '$alert', function($window, $sce, $alert) {
    return {
      restrict: 'EAC',
      scope: true,
      link: function postLink(scope, element, attr, transclusion) {
        var options = {
          scope: scope,
          element: element,
          show: false
        };
        angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable' ], function(key) {
          if (angular.isDefined(attr[key])) options[key] = attr[key];
        });
        var falseValueRegExp = /^(false|0|)$/i;
        angular.forEach([ 'keyboard', 'html', 'container', 'dismissable' ], function(key) {
          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;
        });
        angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide' ], function(key) {
          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);
          if (angular.isDefined(attr[bsKey])) {
            options[key] = scope.$eval(attr[bsKey]);
          }
        });
        if (!scope.hasOwnProperty('title')) {
          scope.title = '';
        }
        angular.forEach([ 'title', 'content', 'type' ], function(key) {
          if (attr[key]) {
            attr.$observe(key, function(newValue, oldValue) {
              scope[key] = $sce.trustAsHtml(newValue);
            });
          }
        });
        if (attr.bsAlert) {
          scope.$watch(attr.bsAlert, function(newValue, oldValue) {
            if (angular.isObject(newValue)) {
              angular.extend(scope, newValue);
            } else {
              scope.content = newValue;
            }
          }, true);
        }
        var alert = $alert(options);
        element.on(attr.trigger || 'click', alert.toggle);
        scope.$on('$destroy', function() {
          if (alert) alert.destroy();
          options = null;
          alert = null;
        });
      }
    };
  } ]);
  angular.module('mgcrea.ngStrap.affix', [ 'mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce' ]).provider('$affix', function() {
    var defaults = this.defaults = {
      offsetTop: 'auto',
      inlineStyles: true,
      setWidth: true
    };
    this.$get = [ '$window', 'debounce', 'dimensions', function($window, debounce, dimensions) {
      var bodyEl = angular.element($window.document.body);
      var windowEl = angular.element($window);
      function AffixFactory(element, config) {
        var $affix = {};
        var options = angular.extend({}, defaults, config);
        var targetEl = options.target;
        var reset = 'affix affix-top affix-bottom';
        var setWidth = false;
        var initialAffixTop = 0;
        var initialOffsetTop = 0;
        var offsetTop = 0;
        var offsetBottom = 0;
        var affixed = null;
        var unpin = null;
        var parent = element.parent();
        if (options.offsetParent) {
          if (options.offsetParent.match(/^\d+$/)) {
            for (var i = 0; i < options.offsetParent * 1 - 1; i++) {
              parent = parent.parent();
            }
          } else {
            parent = angular.element(options.offsetParent);
          }
        }
        $affix.init = function() {
          this.$parseOffsets();
          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;
          setWidth = options.setWidth && !element[0].style.width;
          targetEl.on('scroll', this.checkPosition);
          targetEl.on('click', this.checkPositionWithEventLoop);
          windowEl.on('resize', this.$debouncedOnResize);
          this.checkPosition();
          this.checkPositionWithEventLoop();
        };
        $affix.destroy = function() {
          targetEl.off('scroll', this.checkPosition);
          targetEl.off('click', this.checkPositionWithEventLoop);
          windowEl.off('resize', this.$debouncedOnResize);
        };
        $affix.checkPositionWithEventLoop = function() {
          setTimeout($affix.checkPosition, 1);
        };
        $affix.checkPosition = function() {
          var scrollTop = getScrollTop();
          var position = dimensions.offset(element[0]);
          var elementHeight = dimensions.height(element[0]);
          var affix = getRequiredAffixClass(unpin, position, elementHeight);
          if (affixed === affix) return;
          affixed = affix;
          if (affix === 'top') {
            unpin = null;
            if (setWidth) {
              element.css('width', '');
            }
            if (options.inlineStyles) {
              element.css('position', options.offsetParent ? '' : 'relative');
              element.css('top', '');
            }
          } else if (affix === 'bottom') {
            if (options.offsetUnpin) {
              unpin = -(options.offsetUnpin * 1);
            } else {
              unpin = position.top - scrollTop;
            }
            if (setWidth) {
              element.css('width', '');
            }
            if (options.inlineStyles) {
              element.css('position', options.offsetParent ? '' : 'relative');
              element.css('top', options.offsetParent ? '' : bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop + 'px');
            }
          } else {
            unpin = null;
            if (setWidth) {
              element.css('width', element[0].offsetWidth + 'px');
            }
            if (options.inlineStyles) {
              element.css('position', 'fixed');
              element.css('top', initialAffixTop + 'px');
            }
          }
          element.removeClass(reset).addClass('affix' + (affix !== 'middle' ? '-' + affix : ''));
        };
        $affix.$onResize = function() {
          $affix.$parseOffsets();
          $affix.checkPosition();
        };
        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);
        $affix.$parseOffsets = function() {
          var initialPosition = element[0].style.position;
          var initialTop = element[0].style.top;
          if (options.inlineStyles) {
            element.css('position', options.offsetParent ? '' : 'relative');
            element.css('top', '');
          }
          if (options.offsetTop) {
            if (options.offsetTop === 'auto') {
              options.offsetTop = '+0';
            }
            if (options.offsetTop.match(/^[-+]\d+$/)) {
              initialAffixTop = -options.offsetTop * 1;
              if (options.offsetParent) {
                offsetTop = dimensions.offset(parent[0]).top + options.offsetTop * 1;
              } else {
                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + options.offsetTop * 1;
              }
            } else {
              offsetTop = options.offsetTop * 1;
            }
          }
          if (options.offsetBottom) {
            if (options.offsetParent && options.offsetBottom.match(/^[-+]\d+$/)) {
              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + options.offsetBottom * 1 + 1;
            } else {
              offsetBottom = options.offsetBottom * 1;
            }
          }
          if (options.inlineStyles) {
            element.css('position', initialPosition);
            element.css('top', initialTop);
          }
        };
        function getRequiredAffixClass(_unpin, position, elementHeight) {
          var scrollTop = getScrollTop();
          var scrollHeight = getScrollHeight();
          if (scrollTop <= offsetTop) {
            return 'top';
          } else if (_unpin !== null) {
            return scrollTop + _unpin <= position.top ? 'middle' : 'bottom';
          } else if (offsetBottom !== null && position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom) {
            return 'bottom';
          }
          return 'middle';
        }
        function getScrollTop() {
          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;
        }
        function getScrollHeight() {
          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;
        }
        $affix.init();
        return $affix;
      }
      return AffixFactory;
    } ];
  }).directive('bsAffix', [ '$affix', '$window', '$timeout', function($affix, $window, $timeout) {
    return {
      restrict: 'EAC',
      require: '^?bsAffixTarget',
      link: function postLink(scope, element, attr, affixTarget) {
        var options = {
          scope: scope,
          target: affixTarget ? affixTarget.$element : angular.element($window)
        };
        angular.forEach([ 'offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles', 'setWidth' ], function(key) {
          if (angular.isDefined(attr[key])) {
            var option = attr[key];
            if (/true/i.test(option)) option = true;
            if (/false/i.test(option)) option = false;
            options[key] = option;
          }
        });
        var affix;
        $timeout(function() {
          affix = $affix(element, options);
        });
        scope.$on('$destroy', function() {
          if (affix) affix.destroy();
          options = null;
          affix = null;
        });
      }
    };
  } ]).directive('bsAffixTarget', function() {
    return {
      controller: [ '$element', function($element) {
        this.$element = $element;
      } ]
    };
  });
  angular.module('mgcrea.ngStrap', [ 'mgcrea.ngStrap.modal', 'mgcrea.ngStrap.aside', 'mgcrea.ngStrap.alert', 'mgcrea.ngStrap.button', 'mgcrea.ngStrap.select', 'mgcrea.ngStrap.datepicker', 'mgcrea.ngStrap.timepicker', 'mgcrea.ngStrap.navbar', 'mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.popover', 'mgcrea.ngStrap.dropdown', 'mgcrea.ngStrap.typeahead', 'mgcrea.ngStrap.scrollspy', 'mgcrea.ngStrap.affix', 'mgcrea.ngStrap.tab', 'mgcrea.ngStrap.collapse' ]);
})(window, document);

/***/ }),

/***/ 1227:
/***/ (function(module, exports) {

/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 0.13.4 - 2015-09-03
 * License: MIT
 */
angular.module("ui.bootstrap", ["ui.bootstrap.tpls","ui.bootstrap.position","ui.bootstrap.dateparser","ui.bootstrap.datepicker","ui.bootstrap.tabs"]);
angular.module("ui.bootstrap.tpls", ["template/datepicker/datepicker.html","template/datepicker/day.html","template/datepicker/month.html","template/datepicker/popup.html","template/datepicker/year.html","template/tabs/tab.html","template/tabs/tabset.html"]);
angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods that can be use to retrieve position of DOM elements.
 * It is meant to be used where we need to absolute-position DOM elements in
 * relation to other, existing elements (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory('$position', ['$document', '$window', function($document, $window) {
    function getStyle(el, cssprop) {
      if (el.currentStyle) { //IE
        return el.currentStyle[cssprop];
      } else if ($window.getComputedStyle) {
        return $window.getComputedStyle(el)[cssprop];
      }
      // finally try and get inline style
      return el.style[cssprop];
    }

    /**
     * Checks if a given element is statically positioned
     * @param element - raw DOM element
     */
    function isStaticPositioned(element) {
      return (getStyle(element, 'position') || 'static' ) === 'static';
    }

    /**
     * returns the closest, non-statically positioned parentOffset of a given element
     * @param element
     */
    var parentOffsetEl = function(element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };

    return {
      /**
       * Provides read-only equivalent of jQuery's position function:
       * http://api.jquery.com/position/
       */
      position: function(element) {
        var elBCR = this.offset(element);
        var offsetParentBCR = { top: 0, left: 0 };
        var offsetParentEl = parentOffsetEl(element[0]);
        if (offsetParentEl != $document[0]) {
          offsetParentBCR = this.offset(angular.element(offsetParentEl));
          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }

        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: elBCR.top - offsetParentBCR.top,
          left: elBCR.left - offsetParentBCR.left
        };
      },

      /**
       * Provides read-only equivalent of jQuery's offset function:
       * http://api.jquery.com/offset/
       */
      offset: function(element) {
        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
        };
      },

      /**
       * Provides coordinates for the targetEl in relation to hostEl
       */
      positionElements: function(hostEl, targetEl, positionStr, appendToBody) {
        var positionStrParts = positionStr.split('-');
        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';

        var hostElPos,
          targetElWidth,
          targetElHeight,
          targetElPos;

        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);

        targetElWidth = targetEl.prop('offsetWidth');
        targetElHeight = targetEl.prop('offsetHeight');

        var shiftWidth = {
          center: function() {
            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
          },
          left: function() {
            return hostElPos.left;
          },
          right: function() {
            return hostElPos.left + hostElPos.width;
          }
        };

        var shiftHeight = {
          center: function() {
            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
          },
          top: function() {
            return hostElPos.top;
          },
          bottom: function() {
            return hostElPos.top + hostElPos.height;
          }
        };

        switch (pos0) {
          case 'right':
            targetElPos = {
              top: shiftHeight[pos1](),
              left: shiftWidth[pos0]()
            };
            break;
          case 'left':
            targetElPos = {
              top: shiftHeight[pos1](),
              left: hostElPos.left - targetElWidth
            };
            break;
          case 'bottom':
            targetElPos = {
              top: shiftHeight[pos0](),
              left: shiftWidth[pos1]()
            };
            break;
          default:
            targetElPos = {
              top: hostElPos.top - targetElHeight,
              left: shiftWidth[pos1]()
            };
            break;
        }

        return targetElPos;
      }
    };
  }]);

angular.module('ui.bootstrap.dateparser', [])

.service('dateParser', ['$log', '$locale', 'orderByFilter', function($log, $locale, orderByFilter) {
  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
  var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

  this.parsers = {};

  var formatCodeToRegex = {
    'yyyy': {
      regex: '\\d{4}',
      apply: function(value) { this.year = +value; }
    },
    'yy': {
      regex: '\\d{2}',
      apply: function(value) { this.year = +value + 2000; }
    },
    'y': {
      regex: '\\d{1,4}',
      apply: function(value) { this.year = +value; }
    },
    'MMMM': {
      regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
      apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }
    },
    'MMM': {
      regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
      apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }
    },
    'MM': {
      regex: '0[1-9]|1[0-2]',
      apply: function(value) { this.month = value - 1; }
    },
    'M': {
      regex: '[1-9]|1[0-2]',
      apply: function(value) { this.month = value - 1; }
    },
    'dd': {
      regex: '[0-2][0-9]{1}|3[0-1]{1}',
      apply: function(value) { this.date = +value; }
    },
    'd': {
      regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
      apply: function(value) { this.date = +value; }
    },
    'EEEE': {
      regex: $locale.DATETIME_FORMATS.DAY.join('|')
    },
    'EEE': {
      regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')
    },
    'HH': {
      regex: '(?:0|1)[0-9]|2[0-3]',
      apply: function(value) { this.hours = +value; }
    },
    'hh': {
      regex: '0[0-9]|1[0-2]',
      apply: function(value) { this.hours = +value; }
    },
    'H': {
      regex: '1?[0-9]|2[0-3]',
      apply: function(value) { this.hours = +value; }
    },
    'h': {
      regex: '[0-9]|1[0-2]',
      apply: function(value) { this.hours = +value; }
    },
    'mm': {
      regex: '[0-5][0-9]',
      apply: function(value) { this.minutes = +value; }
    },
    'm': {
      regex: '[0-9]|[1-5][0-9]',
      apply: function(value) { this.minutes = +value; }
    },
    'sss': {
      regex: '[0-9][0-9][0-9]',
      apply: function(value) { this.milliseconds = +value; }
    },
    'ss': {
      regex: '[0-5][0-9]',
      apply: function(value) { this.seconds = +value; }
    },
    's': {
      regex: '[0-9]|[1-5][0-9]',
      apply: function(value) { this.seconds = +value; }
    },
    'a': {
      regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
      apply: function(value) {
        if (this.hours === 12) {
          this.hours = 0;
        }

        if (value === 'PM') {
          this.hours += 12;
        }
      }
    }
  };

  function createParser(format) {
    var map = [], regex = format.split('');

    angular.forEach(formatCodeToRegex, function(data, code) {
      var index = format.indexOf(code);

      if (index > -1) {
        format = format.split('');

        regex[index] = '(' + data.regex + ')';
        format[index] = '$'; // Custom symbol to define consumed part of format
        for (var i = index + 1, n = index + code.length; i < n; i++) {
          regex[i] = '';
          format[i] = '$';
        }
        format = format.join('');

        map.push({ index: index, apply: data.apply });
      }
    });

    return {
      regex: new RegExp('^' + regex.join('') + '$'),
      map: orderByFilter(map, 'index')
    };
  }

  this.parse = function(input, format, baseDate) {
    if (!angular.isString(input) || !format) {
      return input;
    }

    format = $locale.DATETIME_FORMATS[format] || format;
    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');

    if (!this.parsers[format]) {
      this.parsers[format] = createParser(format);
    }

    var parser = this.parsers[format],
        regex = parser.regex,
        map = parser.map,
        results = input.match(regex);

    if (results && results.length) {
      var fields, dt;
      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
        fields = {
          year: baseDate.getFullYear(),
          month: baseDate.getMonth(),
          date: baseDate.getDate(),
          hours: baseDate.getHours(),
          minutes: baseDate.getMinutes(),
          seconds: baseDate.getSeconds(),
          milliseconds: baseDate.getMilliseconds()
        };
      } else {
        if (baseDate) {
          $log.warn('dateparser:', 'baseDate is not a valid date');
        }
        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
      }

      for (var i = 1, n = results.length; i < n; i++) {
        var mapper = map[i-1];
        if (mapper.apply) {
          mapper.apply.call(fields, results[i]);
        }
      }

      if (isValid(fields.year, fields.month, fields.date)) {
        dt = new Date(fields.year, fields.month, fields.date,
          fields.hours, fields.minutes, fields.seconds,
          fields.milliseconds || 0);
      }

      return dt;
    }
  };

  // Check if date is valid for specific month (and year for February).
  // Month: 0 = Jan, 1 = Feb, etc
  function isValid(year, month, date) {
    if (date < 1) {
      return false;
    }

    if (month === 1 && date > 28) {
      return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);
    }

    if (month === 3 || month === 5 || month === 8 || month === 10) {
      return date < 31;
    }

    return true;
  }
}]);

angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])

.value('$datepickerSuppressError', false)

.constant('datepickerConfig', {
  formatDay: 'dd',
  formatMonth: 'MMMM',
  formatYear: 'yyyy',
  formatDayHeader: 'EEE',
  formatDayTitle: 'MMMM yyyy',
  formatMonthTitle: 'yyyy',
  datepickerMode: 'day',
  minMode: 'day',
  maxMode: 'year',
  showWeeks: true,
  startingDay: 0,
  yearRange: 20,
  minDate: null,
  maxDate: null,
  shortcutPropagation: false
})

.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'datepickerConfig', '$datepickerSuppressError', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;

  // Modes chain
  this.modes = ['day', 'month', 'year'];

  // Configuration attributes
  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',
                   'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {
    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
  });

  // Watchable date attributes
  angular.forEach(['minDate', 'maxDate'], function(key) {
    if ($attrs[key]) {
      $scope.$parent.$watch($parse($attrs[key]), function(value) {
        self[key] = value ? new Date(value) : null;
        self.refreshView();
      });
    } else {
      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
    }
  });

  angular.forEach(['minMode', 'maxMode'], function(key) {
    if ($attrs[key]) {
      $scope.$parent.$watch($parse($attrs[key]), function(value) {
        self[key] = angular.isDefined(value) ? value : $attrs[key];
        $scope[key] = self[key];
        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {
          $scope.datepickerMode = self[key];
        }
      });
    } else {
      self[key] = datepickerConfig[key] || null;
      $scope[key] = self[key];
    }
  });

  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

  if (angular.isDefined($attrs.initDate)) {
    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
    $scope.$parent.$watch($attrs.initDate, function(initDate) {
      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
        self.activeDate = initDate;
        self.refreshView();
      }
    });
  } else {
    this.activeDate = new Date();
  }

  $scope.isActive = function(dateObject) {
    if (self.compare(dateObject.date, self.activeDate) === 0) {
      $scope.activeDateId = dateObject.uid;
      return true;
    }
    return false;
  };

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;

    ngModelCtrl.$render = function() {
      self.render();
    };
  };

  this.render = function() {
    if (ngModelCtrl.$viewValue) {
      var date = new Date(ngModelCtrl.$viewValue),
          isValid = !isNaN(date);

      if (isValid) {
        this.activeDate = date;
      } else if (!$datepickerSuppressError) {
        $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
      }
    }
    this.refreshView();
  };

  this.refreshView = function() {
    if (this.element) {
      this._refreshView();

      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));
    }
  };

  this.createDateObject = function(date, format) {
    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
    return {
      date: date,
      label: dateFilter(date, format),
      selected: model && this.compare(date, model) === 0,
      disabled: this.isDisabled(date),
      current: this.compare(date, new Date()) === 0,
      customClass: this.customClass(date)
    };
  };

  this.isDisabled = function(date) {
    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));
  };

  this.customClass = function(date) {
    return $scope.customClass({date: date, mode: $scope.datepickerMode});
  };

  // Split array into smaller arrays
  this.split = function(arr, size) {
    var arrays = [];
    while (arr.length > 0) {
      arrays.push(arr.splice(0, size));
    }
    return arrays;
  };

  // Fix a hard-reprodusible bug with timezones
  // The bug depends on OS, browser, current timezone and current date
  // i.e.
  // var date = new Date(2014, 0, 1);
  // console.log(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours());
  // can result in "2013 11 31 23" because of the bug.
  this.fixTimeZone = function(date) {
    var hours = date.getHours();
    date.setHours(hours === 23 ? hours + 2 : 0);
  };

  $scope.select = function(date) {
    if ($scope.datepickerMode === self.minMode) {
      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
      ngModelCtrl.$setViewValue(dt);
      ngModelCtrl.$render();
    } else {
      self.activeDate = date;
      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
    }
  };

  $scope.move = function(direction) {
    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
    self.activeDate.setFullYear(year, month, 1);
    self.refreshView();
  };

  $scope.toggleMode = function(direction) {
    direction = direction || 1;

    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {
      return;
    }

    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
  };

  // Key event mapper
  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

  var focusElement = function() {
    self.element[0].focus();
  };

  // Listen for focus requests from popup directive
  $scope.$on('datepicker.focus', focusElement);

  $scope.keydown = function(evt) {
    var key = $scope.keys[evt.which];

    if (!key || evt.shiftKey || evt.altKey) {
      return;
    }

    evt.preventDefault();
    if (!self.shortcutPropagation) {
      evt.stopPropagation();
    }

    if (key === 'enter' || key === 'space') {
      if (self.isDisabled(self.activeDate)) {
        return; // do nothing
      }
      $scope.select(self.activeDate);
      focusElement();
    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
      $scope.toggleMode(key === 'up' ? 1 : -1);
      focusElement();
    } else {
      self.handleKeyDown(key, evt);
      self.refreshView();
    }
  };
}])

.directive('datepicker', function() {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/datepicker.html';
    },
    scope: {
      datepickerMode: '=?',
      dateDisabled: '&',
      customClass: '&',
      shortcutPropagation: '&?'
    },
    require: ['datepicker', '^ngModel'],
    controller: 'DatepickerController',
    controllerAs: 'datepicker',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      datepickerCtrl.init(ngModelCtrl);
    }
  };
})

.directive('daypicker', ['dateFilter', function(dateFilter) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/day.html',
    require: '^datepicker',
    link: function(scope, element, attrs, ctrl) {
      scope.showWeeks = ctrl.showWeeks;

      ctrl.step = { months: 1 };
      ctrl.element = element;

      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function getDaysInMonth(year, month) {
        return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];
      }

      function getDates(startDate, n) {
        var dates = new Array(n), current = new Date(startDate), i = 0, date;
        while (i < n) {
          date = new Date(current);
          ctrl.fixTimeZone(date);
          dates[i++] = date;
          current.setDate(current.getDate() + 1);
        }
        return dates;
      }

      ctrl._refreshView = function() {
        var year = ctrl.activeDate.getFullYear(),
          month = ctrl.activeDate.getMonth(),
          firstDayOfMonth = new Date(year, month, 1),
          difference = ctrl.startingDay - firstDayOfMonth.getDay(),
          numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,
          firstDate = new Date(firstDayOfMonth);

        if (numDisplayedFromPreviousMonth > 0) {
          firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
        }

        // 42 is the number of days on a six-month calendar
        var days = getDates(firstDate, 42);
        for (var i = 0; i < 42; i ++) {
          days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {
            secondary: days[i].getMonth() !== month,
            uid: scope.uniqueId + '-' + i
          });
        }

        scope.labels = new Array(7);
        for (var j = 0; j < 7; j++) {
          scope.labels[j] = {
            abbr: dateFilter(days[j].date, ctrl.formatDayHeader),
            full: dateFilter(days[j].date, 'EEEE')
          };
        }

        scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle);
        scope.rows = ctrl.split(days, 7);

        if (scope.showWeeks) {
          scope.weekNumbers = [];
          var thursdayIndex = (4 + 7 - ctrl.startingDay) % 7,
              numWeeks = scope.rows.length;
          for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
            scope.weekNumbers.push(
              getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
          }
        }
      };

      ctrl.compare = function(date1, date2) {
        return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
      };

      function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
        var time = checkDate.getTime();
        checkDate.setMonth(0); // Compare with Jan 1
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      }

      ctrl.handleKeyDown = function(key, evt) {
        var date = ctrl.activeDate.getDate();

        if (key === 'left') {
          date = date - 1;   // up
        } else if (key === 'up') {
          date = date - 7;   // down
        } else if (key === 'right') {
          date = date + 1;   // down
        } else if (key === 'down') {
          date = date + 7;
        } else if (key === 'pageup' || key === 'pagedown') {
          var month = ctrl.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);
          ctrl.activeDate.setMonth(month, 1);
          date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);
        } else if (key === 'home') {
          date = 1;
        } else if (key === 'end') {
          date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth());
        }
        ctrl.activeDate.setDate(date);
      };

      ctrl.refreshView();
    }
  };
}])

.directive('monthpicker', ['dateFilter', function(dateFilter) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/month.html',
    require: '^datepicker',
    link: function(scope, element, attrs, ctrl) {
      ctrl.step = { years: 1 };
      ctrl.element = element;

      ctrl._refreshView = function() {
        var months = new Array(12),
            year = ctrl.activeDate.getFullYear(),
            date;

        for (var i = 0; i < 12; i++) {
          date = new Date(year, i, 1);
          ctrl.fixTimeZone(date);
          months[i] = angular.extend(ctrl.createDateObject(date, ctrl.formatMonth), {
            uid: scope.uniqueId + '-' + i
          });
        }

        scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle);
        scope.rows = ctrl.split(months, 3);
      };

      ctrl.compare = function(date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
      };

      ctrl.handleKeyDown = function(key, evt) {
        var date = ctrl.activeDate.getMonth();

        if (key === 'left') {
          date = date - 1;   // up
        } else if (key === 'up') {
          date = date - 3;   // down
        } else if (key === 'right') {
          date = date + 1;   // down
        } else if (key === 'down') {
          date = date + 3;
        } else if (key === 'pageup' || key === 'pagedown') {
          var year = ctrl.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);
          ctrl.activeDate.setFullYear(year);
        } else if (key === 'home') {
          date = 0;
        } else if (key === 'end') {
          date = 11;
        }
        ctrl.activeDate.setMonth(date);
      };

      ctrl.refreshView();
    }
  };
}])

.directive('yearpicker', ['dateFilter', function(dateFilter) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/year.html',
    require: '^datepicker',
    link: function(scope, element, attrs, ctrl) {
      var range = ctrl.yearRange;

      ctrl.step = { years: range };
      ctrl.element = element;

      function getStartingYear( year ) {
        return parseInt((year - 1) / range, 10) * range + 1;
      }

      ctrl._refreshView = function() {
        var years = new Array(range), date;

        for (var i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i < range; i++) {
          date = new Date(start + i, 0, 1);
          ctrl.fixTimeZone(date);
          years[i] = angular.extend(ctrl.createDateObject(date, ctrl.formatYear), {
            uid: scope.uniqueId + '-' + i
          });
        }

        scope.title = [years[0].label, years[range - 1].label].join(' - ');
        scope.rows = ctrl.split(years, 5);
      };

      ctrl.compare = function(date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
      };

      ctrl.handleKeyDown = function(key, evt) {
        var date = ctrl.activeDate.getFullYear();

        if (key === 'left') {
          date = date - 1;   // up
        } else if (key === 'up') {
          date = date - 5;   // down
        } else if (key === 'right') {
          date = date + 1;   // down
        } else if (key === 'down') {
          date = date + 5;
        } else if (key === 'pageup' || key === 'pagedown') {
          date += (key === 'pageup' ? - 1 : 1) * ctrl.step.years;
        } else if (key === 'home') {
          date = getStartingYear(ctrl.activeDate.getFullYear());
        } else if (key === 'end') {
          date = getStartingYear(ctrl.activeDate.getFullYear()) + range - 1;
        }
        ctrl.activeDate.setFullYear(date);
      };

      ctrl.refreshView();
    }
  };
}])

.constant('datepickerPopupConfig', {
  datepickerPopup: 'yyyy-MM-dd',
  datepickerPopupTemplateUrl: 'template/datepicker/popup.html',
  datepickerTemplateUrl: 'template/datepicker/datepicker.html',
  html5Types: {
    date: 'yyyy-MM-dd',
    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
    'month': 'yyyy-MM'
  },
  currentText: 'Today',
  clearText: 'Clear',
  closeText: 'Done',
  closeOnDateSelection: true,
  appendToBody: false,
  showButtonBar: true,
  onOpenFocus: true
})

.directive('datepickerPopup', ['$compile', '$parse', '$document', '$rootScope', '$position', 'dateFilter', 'dateParser', 'datepickerPopupConfig', '$timeout',
function($compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {
  return {
    restrict: 'EA',
    require: 'ngModel',
    scope: {
      isOpen: '=?',
      currentText: '@',
      clearText: '@',
      closeText: '@',
      dateDisabled: '&',
      customClass: '&'
    },
    link: function(scope, element, attrs, ngModel) {
      var dateFormat,
          closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,
          appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody,
          onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus,
          datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl,
          datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl,
          cache = {};

      scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;

      scope.getText = function(key) {
        return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
      };

      scope.isDisabled = function(date) {
        if (date === 'today') {
          date = new Date();
        }

        return ((scope.watchData.minDate && scope.compare(date, cache.minDate) < 0) ||
          (scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0));
      };

      scope.compare = function(date1, date2) {
        return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
      };

      var isHtml5DateInput = false;
      if (datepickerPopupConfig.html5Types[attrs.type]) {
        dateFormat = datepickerPopupConfig.html5Types[attrs.type];
        isHtml5DateInput = true;
      } else {
        dateFormat = attrs.datepickerPopup || datepickerPopupConfig.datepickerPopup;
        attrs.$observe('datepickerPopup', function(value, oldValue) {
            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
            // Invalidate the $modelValue to ensure that formatters re-run
            // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
            if (newDateFormat !== dateFormat) {
              dateFormat = newDateFormat;
              ngModel.$modelValue = null;

              if (!dateFormat) {
                throw new Error('datepickerPopup must have a date format specified.');
              }
            }
        });
      }

      if (!dateFormat) {
        throw new Error('datepickerPopup must have a date format specified.');
      }

      if (isHtml5DateInput && attrs.datepickerPopup) {
        throw new Error('HTML5 date input types do not support custom formats.');
      }

      // popup element used to display calendar
      var popupEl = angular.element('<div datepicker-popup-wrap><div datepicker></div></div>');
      popupEl.attr({
        'ng-model': 'date',
        'ng-change': 'dateSelection(date)',
        'template-url': datepickerPopupTemplateUrl
      });

      function cameltoDash(string) {
        return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });
      }

      // datepicker element
      var datepickerEl = angular.element(popupEl.children()[0]);
      datepickerEl.attr('template-url', datepickerTemplateUrl);

      if (isHtml5DateInput) {
        if (attrs.type === 'month') {
          datepickerEl.attr('datepicker-mode', '"month"');
          datepickerEl.attr('min-mode', 'month');
        }
      }

      if (attrs.datepickerOptions) {
        var options = scope.$parent.$eval(attrs.datepickerOptions);
        if (options && options.initDate) {
          scope.initDate = options.initDate;
          datepickerEl.attr('init-date', 'initDate');
          delete options.initDate;
        }
        angular.forEach(options, function(value, option) {
          datepickerEl.attr( cameltoDash(option), value );
        });
      }

      scope.watchData = {};
      angular.forEach(['minMode', 'maxMode', 'minDate', 'maxDate', 'datepickerMode', 'initDate', 'shortcutPropagation'], function(key) {
        if (attrs[key]) {
          var getAttribute = $parse(attrs[key]);
          scope.$parent.$watch(getAttribute, function(value) {
            scope.watchData[key] = value;
            if (key === 'minDate' || key === 'maxDate') {
              cache[key] = new Date(value);
            }
          });
          datepickerEl.attr(cameltoDash(key), 'watchData.' + key);

          // Propagate changes from datepicker to outside
          if (key === 'datepickerMode') {
            var setAttribute = getAttribute.assign;
            scope.$watch('watchData.' + key, function(value, oldvalue) {
              if (angular.isFunction(setAttribute) && value !== oldvalue) {
                setAttribute(scope.$parent, value);
              }
            });
          }
        }
      });
      if (attrs.dateDisabled) {
        datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
      }

      if (attrs.showWeeks) {
        datepickerEl.attr('show-weeks', attrs.showWeeks);
      }

      if (attrs.customClass) {
        datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');
      }

      function parseDate(viewValue) {
        if (angular.isNumber(viewValue)) {
          // presumably timestamp to date object
          viewValue = new Date(viewValue);
        }

        if (!viewValue) {
          return null;
        } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {
          return viewValue;
        } else if (angular.isString(viewValue)) {
          var date = dateParser.parse(viewValue, dateFormat, scope.date);
          if (isNaN(date)) {
            return undefined;
          } else {
            return date;
          }
        } else {
          return undefined;
        }
      }

      function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;

        if (!attrs.ngRequired && !value) {
          return true;
        }

        if (angular.isNumber(value)) {
          value = new Date(value);
        }
        if (!value) {
          return true;
        } else if (angular.isDate(value) && !isNaN(value)) {
          return true;
        } else if (angular.isString(value)) {
          var date = dateParser.parse(value, dateFormat);
          return !isNaN(date);
        } else {
          return false;
        }
      }

      if (!isHtml5DateInput) {
        // Internal API to maintain the correct ng-invalid-[key] class
        ngModel.$$parserName = 'date';
        ngModel.$validators.date = validator;
        ngModel.$parsers.unshift(parseDate);
        ngModel.$formatters.push(function(value) {
          scope.date = value;
          return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);
        });
      } else {
        ngModel.$formatters.push(function(value) {
          scope.date = value;
          return value;
        });
      }

      // Inner change
      scope.dateSelection = function(dt) {
        if (angular.isDefined(dt)) {
          scope.date = dt;
        }
        var date = scope.date ? dateFilter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
        element.val(date);
        ngModel.$setViewValue(date);

        if (closeOnDateSelection) {
          scope.isOpen = false;
          element[0].focus();
        }
      };

      // Detect changes in the view from the text box
      ngModel.$viewChangeListeners.push(function() {
        scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);
      });

      var documentClickBind = function(event) {
        if (scope.isOpen && !(element[0].contains(event.target) || popupEl[0].contains(event.target))) {
          scope.$apply(function() {
            scope.isOpen = false;
          });
        }
      };

      var inputKeydownBind = function(evt) {
        if (evt.which === 27 && scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          scope.$apply(function() {
            scope.isOpen = false;
          });
          element[0].focus();
        } else if (evt.which === 40 && !scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          scope.$apply(function() {
            scope.isOpen = true;
          });
        }
      };
      element.bind('keydown', inputKeydownBind);

      scope.keydown = function(evt) {
        if (evt.which === 27) {
          scope.isOpen = false;
          element[0].focus();
        }
      };

      scope.$watch('isOpen', function(value) {
        if (value) {
          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
          scope.position.top = scope.position.top + element.prop('offsetHeight');

          $timeout(function() {
            if (onOpenFocus) {
              scope.$broadcast('datepicker.focus');
            }
            $document.bind('click', documentClickBind);
          }, 0, false);
        } else {
          $document.unbind('click', documentClickBind);
        }
      });

      scope.select = function(date) {
        if (date === 'today') {
          var today = new Date();
          if (angular.isDate(scope.date)) {
            date = new Date(scope.date);
            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
          } else {
            date = new Date(today.setHours(0, 0, 0, 0));
          }
        }
        scope.dateSelection(date);
      };

      scope.close = function() {
        scope.isOpen = false;
        element[0].focus();
      };

      var $popup = $compile(popupEl)(scope);
      // Prevent jQuery cache memory leak (template is now redundant after linking)
      popupEl.remove();

      if (appendToBody) {
        $document.find('body').append($popup);
      } else {
        element.after($popup);
      }

      scope.$on('$destroy', function() {
        if (scope.isOpen === true) {
          if (!$rootScope.$$phase) {
            scope.$apply(function() {
              scope.isOpen = false;
            });
          }
        }

        $popup.remove();
        element.unbind('keydown', inputKeydownBind);
        $document.unbind('click', documentClickBind);
      });
    }
  };
}])

.directive('datepickerPopupWrap', function() {
  return {
    restrict:'EA',
    replace: true,
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/popup.html';
    }
  };
});


/**
 * @ngdoc overview
 * @name ui.bootstrap.tabs
 *
 * @description
 * AngularJS version of the tabs directive.
 */

angular.module('ui.bootstrap.tabs', [])

.controller('TabsetController', ['$scope', function TabsetCtrl($scope) {
  var ctrl = this,
      tabs = ctrl.tabs = $scope.tabs = [];

  ctrl.select = function(selectedTab) {
    angular.forEach(tabs, function(tab) {
      if (tab.active && tab !== selectedTab) {
        tab.active = false;
        tab.onDeselect();
        selectedTab.selectCalled = false;
      }
    });
    selectedTab.active = true;
    // only call select if it has not already been called
    if (!selectedTab.selectCalled) {
      selectedTab.onSelect();
      selectedTab.selectCalled = true;
    }
  };

  ctrl.addTab = function addTab(tab) {
    tabs.push(tab);
    // we can't run the select function on the first tab
    // since that would select it twice
    if (tabs.length === 1 && tab.active !== false) {
      tab.active = true;
    } else if (tab.active) {
      ctrl.select(tab);
    } else {
      tab.active = false;
    }
  };

  ctrl.removeTab = function removeTab(tab) {
    var index = tabs.indexOf(tab);
    //Select a new tab if the tab to be removed is selected and not destroyed
    if (tab.active && tabs.length > 1 && !destroyed) {
      //If this is the last tab, select the previous tab. else, the next tab.
      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
      ctrl.select(tabs[newActiveIndex]);
    }
    tabs.splice(index, 1);
  };

  var destroyed;
  $scope.$on('$destroy', function() {
    destroyed = true;
  });
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabset
 * @restrict EA
 *
 * @description
 * Tabset is the outer container for the tabs directive
 *
 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
 * @param {boolean=} justified Whether or not to use justified styling for the tabs.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab heading="Tab 1"><b>First</b> Content!</tab>
      <tab heading="Tab 2"><i>Second</i> Content!</tab>
    </tabset>
    <hr />
    <tabset vertical="true">
      <tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</tab>
      <tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</tab>
    </tabset>
    <tabset justified="true">
      <tab heading="Justified Tab 1"><b>First</b> Justified Content!</tab>
      <tab heading="Justified Tab 2"><i>Second</i> Justified Content!</tab>
    </tabset>
  </file>
</example>
 */
.directive('tabset', function() {
  return {
    restrict: 'EA',
    transclude: true,
    replace: true,
    scope: {
      type: '@'
    },
    controller: 'TabsetController',
    templateUrl: 'template/tabs/tabset.html',
    link: function(scope, element, attrs) {
      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
    }
  };
})

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tab
 * @restrict EA
 *
 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
 * @param {string=} select An expression to evaluate when the tab is selected.
 * @param {boolean=} active A binding, telling whether or not this tab is selected.
 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
 *
 * @description
 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <div ng-controller="TabsDemoCtrl">
      <button class="btn btn-small" ng-click="items[0].active = true">
        Select item 1, using active binding
      </button>
      <button class="btn btn-small" ng-click="items[1].disabled = !items[1].disabled">
        Enable/disable item 2, using disabled binding
      </button>
      <br />
      <tabset>
        <tab heading="Tab 1">First Tab</tab>
        <tab select="alertMe()">
          <tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>
          Second Tab, with alert callback and html heading!
        </tab>
        <tab ng-repeat="item in items"
          heading="{{item.title}}"
          disabled="item.disabled"
          active="item.active">
          {{item.content}}
        </tab>
      </tabset>
    </div>
  </file>
  <file name="script.js">
    function TabsDemoCtrl($scope) {
      $scope.items = [
        { title:"Dynamic Title 1", content:"Dynamic Item 0" },
        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }
      ];

      $scope.alertMe = function() {
        setTimeout(function() {
          alert("You've selected the alert tab!");
        });
      };
    };
  </file>
</example>
 */

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabHeading
 * @restrict EA
 *
 * @description
 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab>
        <tab-heading><b>HTML</b> in my titles?!</tab-heading>
        And some content, too!
      </tab>
      <tab>
        <tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>
        That's right.
      </tab>
    </tabset>
  </file>
</example>
 */
.directive('tab', ['$parse', '$log', function($parse, $log) {
  return {
    require: '^tabset',
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/tabs/tab.html',
    transclude: true,
    scope: {
      active: '=?',
      heading: '@',
      onSelect: '&select', //This callback is called in contentHeadingTransclude
                          //once it inserts the tab's content into the dom
      onDeselect: '&deselect'
    },
    controller: function() {
      //Empty controller so other directives can require being 'under' a tab
    },
    link: function(scope, elm, attrs, tabsetCtrl, transclude) {
      scope.$watch('active', function(active) {
        if (active) {
          tabsetCtrl.select(scope);
        }
      });

      scope.disabled = false;
      if (attrs.disable) {
        scope.$parent.$watch($parse(attrs.disable), function(value) {
          scope.disabled = !! value;
        });
      }

      // Deprecation support of "disabled" parameter
      // fix(tab): IE9 disabled attr renders grey text on enabled tab #2677
      // This code is duplicated from the lines above to make it easy to remove once
      // the feature has been completely deprecated
      if (attrs.disabled) {
        $log.warn('Use of "disabled" attribute has been deprecated, please use "disable"');
        scope.$parent.$watch($parse(attrs.disabled), function(value) {
          scope.disabled = !! value;
        });
      }

      scope.select = function() {
        if (!scope.disabled) {
          scope.active = true;
        }
      };

      tabsetCtrl.addTab(scope);
      scope.$on('$destroy', function() {
        tabsetCtrl.removeTab(scope);
      });

      //We need to transclude later, once the content container is ready.
      //when this link happens, we're inside a tab heading.
      scope.$transcludeFn = transclude;
    }
  };
}])

.directive('tabHeadingTransclude', function() {
  return {
    restrict: 'A',
    require: '^tab',
    link: function(scope, elm, attrs, tabCtrl) {
      scope.$watch('headingElement', function updateHeadingElement(heading) {
        if (heading) {
          elm.html('');
          elm.append(heading);
        }
      });
    }
  };
})

.directive('tabContentTransclude', function() {
  return {
    restrict: 'A',
    require: '^tabset',
    link: function(scope, elm, attrs) {
      var tab = scope.$eval(attrs.tabContentTransclude);

      //Now our tab is ready to be transcluded: both the tab heading area
      //and the tab content area are loaded.  Transclude 'em both.
      tab.$transcludeFn(tab.$parent, function(contents) {
        angular.forEach(contents, function(node) {
          if (isTabHeading(node)) {
            //Let tabHeadingTransclude know.
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };

  function isTabHeading(node) {
    return node.tagName && (
      node.hasAttribute('tab-heading') ||
      node.hasAttribute('data-tab-heading') ||
      node.hasAttribute('x-tab-heading') ||
      node.tagName.toLowerCase() === 'tab-heading' ||
      node.tagName.toLowerCase() === 'data-tab-heading' ||
      node.tagName.toLowerCase() === 'x-tab-heading'
    );
  }
});

angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/datepicker.html",
    "<div ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n" +
    "  <daypicker ng-switch-when=\"day\" tabindex=\"0\"></daypicker>\n" +
    "  <monthpicker ng-switch-when=\"month\" tabindex=\"0\"></monthpicker>\n" +
    "  <yearpicker ng-switch-when=\"year\" tabindex=\"0\"></yearpicker>\n" +
    "</div>");
}]);

angular.module("template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/day.html",
    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "    <tr>\n" +
    "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" +
    "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default btn-sm\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/month.html",
    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/popup.html",
    "<ul class=\"dropdown-menu\" ng-if=\"isOpen\" style=\"display: block\" ng-style=\"{top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" +
    "	<li ng-transclude></li>\n" +
    "	<li ng-if=\"showButtonBar\" style=\"padding:10px 9px 2px\">\n" +
    "		<span class=\"btn-group pull-left\">\n" +
    "			<button type=\"button\" class=\"btn btn-sm btn-info\" ng-click=\"select('today')\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" +
    "			<button type=\"button\" class=\"btn btn-sm btn-danger\" ng-click=\"select(null)\">{{ getText('clear') }}</button>\n" +
    "		</span>\n" +
    "		<button type=\"button\" class=\"btn btn-sm btn-success pull-right\" ng-click=\"close()\">{{ getText('close') }}</button>\n" +
    "	</li>\n" +
    "</ul>\n" +
    "");
}]);

angular.module("template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/year.html",
    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th colspan=\"3\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\">\n" +
    "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tab.html",
    "<li ng-class=\"{active: active, disabled: disabled}\">\n" +
    "  <a href ng-click=\"select()\" tab-heading-transclude>{{heading}}</a>\n" +
    "</li>\n" +
    "");
}]);

angular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tabset.html",
    "<div>\n" +
    "  <ul class=\"nav nav-{{type || 'tabs'}} nav-tabs-alt\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
    "  <div class=\"tab-content\">\n" +
    "    <div class=\"tab-pane\" \n" +
    "         ng-repeat=\"tab in tabs\" \n" +
    "         ng-class=\"{active: tab.active}\"\n" +
    "         tab-content-transclude=\"tab\">\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);


/***/ }),

/***/ 1228:
/***/ (function(module, exports) {

/*
*  AngularJs Fullcalendar Wrapper for the JQuery FullCalendar
*  API @ http://arshaw.com/fullcalendar/
*
*  Angular Calendar Directive that takes in the [eventSources] nested array object as the ng-model and watches it deeply changes.
*       Can also take in multiple event urls as a source object(s) and feed the events per view.
*       The calendar will watch any eventSource array and update itself when a change is made.
*
*/

angular.module('ui.calendar', [])

    .constant('uiCalendarConfig', {
        calendars : {}
    })
    .controller('uiCalendarCtrl', ['$scope', '$locale',
        function ($scope, $locale) {

            var sources = $scope.eventSources;
            var extraEventSignature = $scope.calendarWatchEvent ? $scope.calendarWatchEvent : angular.noop;

            var wrapFunctionWithScopeApply = function (functionToWrap) {
                return function () {
                    // This may happen outside of angular context, so create one if outside.
                    if ($scope.$root.$$phase) {
                        return functionToWrap.apply(this, arguments);
                    }

                    var args = arguments;
                    var that = this;
                    return $scope.$root.$apply(
                        function () {
                            return functionToWrap.apply(that, args);
                        }
                    );
                };
            };

            var eventSerialId = 1;
            // @return {String} fingerprint of the event object and its properties
            this.eventFingerprint = function (e) {
                if (!e._id) {
                    e._id = eventSerialId++;
                }

                var extraSignature = extraEventSignature({
                    event : e
                }) || '';
                var start = moment.isMoment(e.start) ? e.start.unix() : (e.start ? moment(e.start).unix() : '');
                var end = moment.isMoment(e.end) ? e.end.unix() : (e.end ? moment(e.end).unix() : '');

                // This extracts all the information we need from the event. http://jsperf.com/angular-calendar-events-fingerprint/3
                return [e._id, e.id || '', e.title || '', e.url || '', start, end, e.allDay || '', e.className || '', extraSignature].join('');
            };

            var sourceSerialId = 1;
            var sourceEventsSerialId = 1;
            // @return {String} fingerprint of the source object and its events array
            this.sourceFingerprint = function (source) {
                var fp = '' + (source.__id || (source.__id = sourceSerialId++));
                var events = angular.isObject(source) && source.events;

                if (events) {
                    fp = fp + '-' + (events.__id || (events.__id = sourceEventsSerialId++));
                }
                return fp;
            };

            // @return {Array} all events from all sources
            this.allEvents = function () {
                return Array.prototype.concat.apply(
                    [],
                    (sources || []).reduce(
                        function (previous, source) {
                            if (angular.isArray(source)) {
                                previous.push(source);
                            } else if (angular.isObject(source) && angular.isArray(source.events)) {
                                var extEvent = Object.keys(source).filter(
                                    function (key) {
                                        return (key !== '_id' && key !== 'events');
                                    }
                                );

                                source.events.forEach(
                                    function (event) {
                                        angular.extend(event, extEvent);
                                    }
                                );

                                previous.push(source.events);
                            }
                            return previous;
                        },
                        []
                    )
                );
            };

            // Track changes in array of objects by assigning id tokens to each element and watching the scope for changes in the tokens
            // @param {Array|Function} arraySource array of objects to watch
            // @param tokenFn {Function} that returns the token for a given object
            // @return {Object}
            //  subscribe: function(scope, function(newTokens, oldTokens))
            //    called when source has changed. return false to prevent individual callbacks from firing
            //  onAdded/Removed/Changed:
            //    when set to a callback, called each item where a respective change is detected
            this.changeWatcher = function (arraySource, tokenFn) {
                var self;

                var getTokens = function () {
                    return ((angular.isFunction(arraySource) ? arraySource() : arraySource) || []).reduce(
                        function (rslt, el) {
                            var token = tokenFn(el);
                            map[token] = el;
                            rslt.push(token);
                            return rslt;
                        },
                        []
                    );
                };

                // @param {Array} a
                // @param {Array} b
                // @return {Array} elements in that are in a but not in b
                // @example
                //  subtractAsSets([6, 100, 4, 5], [4, 5, 7]) // [6, 100]
                var subtractAsSets = function (a, b) {
                    var obj = (b || []).reduce(
                        function (rslt, val) {
                            rslt[val] = true;
                            return rslt;
                        },
                        Object.create(null)
                    );
                    return (a || []).filter(
                        function (val) {
                            return !obj[val];
                        }
                    );
                };

                // Map objects to tokens and vice-versa
                var map = {};

                // Compare newTokens to oldTokens and call onAdded, onRemoved, and onChanged handlers for each affected event respectively.
                var applyChanges = function (newTokens, oldTokens) {
                    var i;
                    var token;
                    var replacedTokens = {};
                    var removedTokens = subtractAsSets(oldTokens, newTokens);
                    for (i = 0; i < removedTokens.length; i++) {
                        var removedToken = removedTokens[i];
                        var el = map[removedToken];
                        delete map[removedToken];
                        var newToken = tokenFn(el);
                        // if the element wasn't removed but simply got a new token, its old token will be different from the current one
                        if (newToken === removedToken) {
                            self.onRemoved(el);
                        } else {
                            replacedTokens[newToken] = removedToken;
                            self.onChanged(el);
                        }
                    }

                    var addedTokens = subtractAsSets(newTokens, oldTokens);
                    for (i = 0; i < addedTokens.length; i++) {
                        token = addedTokens[i];
                        if (!replacedTokens[token]) {
                            self.onAdded(map[token]);
                        }
                    }
                };

                self = {
                    subscribe : function (scope, onArrayChanged) {
                        scope.$watch(getTokens, function (newTokens, oldTokens) {
                            var notify = !(onArrayChanged && onArrayChanged(newTokens, oldTokens) === false);
                            if (notify) {
                                applyChanges(newTokens, oldTokens);
                            }
                        }, true);
                    },
                    onAdded : angular.noop,
                    onChanged : angular.noop,
                    onRemoved : angular.noop
                };
                return self;
            };

            this.getFullCalendarConfig = function (calendarSettings, uiCalendarConfig) {
                var config = {};

                angular.extend(config, uiCalendarConfig);
                angular.extend(config, calendarSettings);

                angular.forEach(config, function (value, key) {
                    if (typeof value === 'function') {
                        config[key] = wrapFunctionWithScopeApply(config[key]);
                    }
                });

                return config;
            };

            this.getLocaleConfig = function (fullCalendarConfig) {
                if (!fullCalendarConfig.lang || fullCalendarConfig.useNgLocale) {
                    // Configure to use locale names by default
                    var tValues = function (data) {
                        // convert {0: "Jan", 1: "Feb", ...} to ["Jan", "Feb", ...]
                        return (Object.keys(data) || []).reduce(
                            function (rslt, el) {
                                rslt.push(data[el]);
                                return rslt;
                            },
                            []
                        );
                    };

                    var dtf = $locale.DATETIME_FORMATS;
                    return {
                        monthNames : tValues(dtf.MONTH),
                        monthNamesShort : tValues(dtf.SHORTMONTH),
                        dayNames : tValues(dtf.DAY),
                        dayNamesShort : tValues(dtf.SHORTDAY)
                    };
                }

                return {};
            };
        }
    ])
    .directive('uiCalendar', ['uiCalendarConfig',
        function (uiCalendarConfig) {

            return {
                restrict : 'A',
                scope : {
                    eventSources : '=ngModel',
                    calendarWatchEvent : '&'
                },
                controller : 'uiCalendarCtrl',
                link : function (scope, elm, attrs, controller) {
                    var sources = scope.eventSources;
                    var sourcesChanged = false;
                    var calendar;
                    var eventSourcesWatcher = controller.changeWatcher(sources, controller.sourceFingerprint);
                    var eventsWatcher = controller.changeWatcher(controller.allEvents, controller.eventFingerprint);
                    var options = null;

                    function getOptions () {
                        var calendarSettings = attrs.uiCalendar ? scope.$parent.$eval(attrs.uiCalendar) : {};
                        var fullCalendarConfig = controller.getFullCalendarConfig(calendarSettings, uiCalendarConfig);
                        var localeFullCalendarConfig = controller.getLocaleConfig(fullCalendarConfig);
                        angular.extend(localeFullCalendarConfig, fullCalendarConfig);
                        options = {
                            eventSources : sources
                        };
                        angular.extend(options, localeFullCalendarConfig);
                        //remove calendars from options
                        options.calendars = null;

                        var options2 = {};
                        for (var o in options) {
                            if (o !== 'eventSources') {
                                options2[o] = options[o];
                            }
                        }
                        return JSON.stringify(options2);
                    }

                    scope.destroyCalendar = function () {
                        if (calendar && calendar.fullCalendar) {
                            calendar.fullCalendar('destroy');
                        }
                        if (attrs.calendar) {
                            calendar = uiCalendarConfig.calendars[attrs.calendar] = angular.element(elm).html('');
                        } else {
                            calendar = angular.element(elm).html('');
                        }
                    };

                    scope.initCalendar = function () {
                        if (!calendar) {
                            calendar = angular.element(elm).html('');
                        }
                        calendar.fullCalendar(options);
                        if (attrs.calendar) {
                            uiCalendarConfig.calendars[attrs.calendar] = calendar;
                        }
                    };

                    scope.$on('$destroy', function () {
                        scope.destroyCalendar();
                    });

                    eventSourcesWatcher.onAdded = function (source) {
                        if (calendar && calendar.fullCalendar) {
                            calendar.fullCalendar(options);
                            if (attrs.calendar) {
                                uiCalendarConfig.calendars[attrs.calendar] = calendar;
                            }
                            calendar.fullCalendar('addEventSource', source);
                            sourcesChanged = true;
                        }
                    };

                    eventSourcesWatcher.onRemoved = function (source) {
                        if (calendar && calendar.fullCalendar) {
                            calendar.fullCalendar('removeEventSource', source);
                            sourcesChanged = true;
                        }
                    };

                    eventSourcesWatcher.onChanged = function () {
                        if (calendar && calendar.fullCalendar) {
                            calendar.fullCalendar('refetchEvents');
                            sourcesChanged = true;
                        }
                    };

                    eventsWatcher.onAdded = function (event) {
                        if (calendar && calendar.fullCalendar) {
                            calendar.fullCalendar('renderEvent', event, !!event.stick);
                        }
                    };

                    eventsWatcher.onRemoved = function (event) {
                        if (calendar && calendar.fullCalendar) {
                            calendar.fullCalendar('removeEvents', event._id);
                        }
                    };

                    eventsWatcher.onChanged = function (event) {
                        if (calendar && calendar.fullCalendar) {
                            var clientEvents = calendar.fullCalendar('clientEvents', event._id);
                            for (var i = 0; i < clientEvents.length; i++) {
                                var clientEvent = clientEvents[i];
                                clientEvent = angular.extend(clientEvent, event);
                                calendar.fullCalendar('updateEvent', clientEvent);
                            }
                        }
                    };

                    eventSourcesWatcher.subscribe(scope);
                    eventsWatcher.subscribe(scope, function () {
                        if (sourcesChanged === true) {
                            sourcesChanged = false;
                            // return false to prevent onAdded/Removed/Changed handlers from firing in this case
                            return false;
                        }
                    });

                    scope.$watch(getOptions, function (newValue, oldValue) {
                        if (newValue !== oldValue) {
                            scope.destroyCalendar();
                            scope.initCalendar();
                        } else if ((newValue && angular.isUndefined(calendar))) {
                            scope.initCalendar();
                        }
                    });
                }
            };
        }
    ]
);


/***/ }),

/***/ 1229:
/***/ (function(module, exports) {

/**
 * angular-strap
 * @version v2.3.12 - 2017-01-26
 * @link http://mgcrea.github.io/angular-strap
 * @author Olivier Louvignes <olivier@mg-crea.com> (https://github.com/mgcrea)
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
(function(window, document, undefined) {
  'use strict';
  angular.module('mgcrea.ngStrap.alert').run([ '$templateCache', function($templateCache) {
    $templateCache.put('alert/alert.tpl.html', '<div class="alert" ng-class="[type ? \'alert-\' + type : null]"><button type="button" class="close" ng-if="dismissable" ng-click="$hide()">&times;</button> <span ng-if="title"><strong ng-bind="title"></strong>&nbsp;<span ng-bind-html="content"></span> </span><span ng-if="!title" ng-bind-html="content"></span></div>');
  } ]);
  angular.module('mgcrea.ngStrap.aside').run([ '$templateCache', function($templateCache) {
    $templateCache.put('aside/aside.tpl.html', '<div class="aside" tabindex="-1" role="dialog"><div class="aside-dialog"><div class="aside-content"><div class="aside-header" ng-show="title"><button type="button" class="close" ng-click="$hide()">&times;</button><h4 class="aside-title" ng-bind="title"></h4></div><div class="aside-body" ng-bind="content"></div><div class="aside-footer"><button type="button" class="btn btn-default" ng-click="$hide()">Close</button></div></div></div></div>');
  } ]);
  angular.module('mgcrea.ngStrap.datepicker').run([ '$templateCache', function($templateCache) {
    $templateCache.put('datepicker/datepicker.tpl.html', '<div class="dropdown-menu datepicker" ng-class="\'datepicker-mode-\' + $mode" style="max-width: 320px"><table style="table-layout: fixed; height: 100%; width: 100%"><thead><tr class="text-center"><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$selectPane(-1)"><i class="{{$iconLeft}}"></i></button></th><th colspan="{{ rows[0].length - 2 }}"><button tabindex="-1" type="button" class="btn btn-default btn-block text-strong" ng-click="$toggleMode()"><strong style="text-transform: capitalize" ng-bind="title"></strong></button></th><th><button tabindex="-1" type="button" class="btn btn-default pull-right" ng-click="$selectPane(+1)"><i class="{{$iconRight}}"></i></button></th></tr><tr ng-if="showLabels" ng-bind-html="labels"></tr></thead><tbody><tr ng-repeat="(i, row) in rows" height="{{ 100 / rows.length }}%"><td class="text-center" ng-repeat="(j, el) in row"><button tabindex="-1" type="button" class="btn btn-default" style="width: 100%" ng-class="{\'btn-primary\': el.selected, \'btn-info btn-today\': el.isToday && !el.selected}" ng-click="$select(el.date, el.disabled)" ng-disabled="el.disabled"><span ng-class="{\'text-muted\': el.muted}" ng-bind="el.label"></span></button></td></tr></tbody><tfoot><tr><td colspan="{{ rows[0].length }}"><div class="btn-group btn-group-justified" role="group"><div class="btn-group" role="group" ng-if="$hasToday"><button type="button" class="btn btn-default today" ng-click="$setToday()" ng-disabled="isTodayDisabled"><strong style="text-transform: capitalize">Today</strong></button></div><div class="btn-group" role="group" ng-if="$hasClear"><button type="button" class="btn btn-default clear" ng-click="$clear()"><strong style="text-transform: capitalize">Clear</strong></button></div></div></td></tr></tfoot></table></div>');
  } ]);
  angular.module('mgcrea.ngStrap.dropdown').run([ '$templateCache', function($templateCache) {
    $templateCache.put('dropdown/dropdown.tpl.html', '<ul tabindex="-1" class="dropdown-menu" role="menu" ng-show="content && content.length"><li role="presentation" ng-class="{divider: item.divider, active: item.active}" ng-repeat="item in content"><a role="menuitem" tabindex="-1" ng-href="{{item.href}}" ng-if="!item.divider && item.href" target="{{item.target || \'\'}}" ng-bind="item.text"></a> <a role="menuitem" tabindex="-1" href="javascript:void(0)" ng-if="!item.divider && item.click" ng-click="$eval(item.click);$hide()" ng-bind="item.text"></a></li></ul>');
  } ]);
  angular.module('mgcrea.ngStrap.modal').run([ '$templateCache', function($templateCache) {
    $templateCache.put('modal/modal.tpl.html', '<div class="modal" tabindex="-1" role="dialog" aria-hidden="true"><div class="modal-dialog"><div class="modal-content"><div class="modal-header" ng-show="title"><button type="button" class="close" aria-label="Close" ng-click="$hide()"><span aria-hidden="true">&times;</span></button><h4 class="modal-title" ng-bind="title"></h4></div><div class="modal-body" ng-bind="content"></div><div class="modal-footer"><button type="button" class="btn btn-default" ng-click="$hide()">Close</button></div></div></div></div>');
  } ]);
  angular.module('mgcrea.ngStrap.popover').run([ '$templateCache', function($templateCache) {
    $templateCache.put('popover/popover.tpl.html', '<div class="popover" tabindex="-1"><div class="arrow"></div><h3 class="popover-title" ng-bind="title" ng-show="title"></h3><div class="popover-content" ng-bind="content"></div></div>');
  } ]);
  angular.module('mgcrea.ngStrap.select').run([ '$templateCache', function($templateCache) {
    $templateCache.put('select/select.tpl.html', '<ul tabindex="-1" class="select dropdown-menu" ng-show="$isVisible()" role="select"><li ng-if="$showAllNoneButtons"><div class="btn-group" style="margin-bottom: 5px; margin-left: 5px"><button type="button" class="btn btn-default btn-xs" ng-click="$selectAll()">{{$allText}}</button> <button type="button" class="btn btn-default btn-xs" ng-click="$selectNone()">{{$noneText}}</button></div></li><li role="presentation" ng-repeat="match in $matches" ng-class="{active: $isActive($index)}"><a style="cursor: default" role="menuitem" tabindex="-1" ng-click="$select($index, $event)"><i class="{{$iconCheckmark}} pull-right" ng-if="$isMultiple && $isActive($index)"></i> <span ng-bind="match.label"></span></a></li></ul>');
  } ]);
  angular.module('mgcrea.ngStrap.tab').run([ '$templateCache', function($templateCache) {
    $templateCache.put('tab/tab.tpl.html', '<ul class="nav" ng-class="$navClass" role="tablist"><li role="presentation" ng-repeat="$pane in $panes track by $index" ng-class="[ $isActive($pane, $index) ? $activeClass : \'\', $pane.disabled ? \'disabled\' : \'\' ]"><a role="tab" data-toggle="tab" ng-click="!$pane.disabled && $setActive($pane.name || $index)" data-index="{{ $index }}" ng-bind-html="$pane.title" aria-controls="$pane.title" href=""></a></li></ul><div ng-transclude class="tab-content"></div>');
  } ]);
  angular.module('mgcrea.ngStrap.timepicker').run([ '$templateCache', function($templateCache) {
    $templateCache.put('timepicker/timepicker.tpl.html', '<div class="dropdown-menu timepicker" style="min-width: 0px;width: auto"><table height="100%"><thead><tr class="text-center"><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(-1, 0)"><i class="{{ $iconUp }}"></i></button></th><th>&nbsp;</th><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(-1, 1)"><i class="{{ $iconUp }}"></i></button></th><th ng-if="showSeconds">&nbsp;</th><th ng-if="showSeconds"><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(-1, 2)"><i class="{{ $iconUp }}"></i></button></th></tr></thead><tbody><tr ng-repeat="(i, row) in rows"><td class="text-center"><button tabindex="-1" style="width: 100%" type="button" class="btn btn-default" ng-class="{\'btn-primary\': row[0].selected}" ng-click="$select(row[0].date, 0)" ng-disabled="row[0].disabled"><span ng-class="{\'text-muted\': row[0].muted}" ng-bind="row[0].label"></span></button></td><td><span ng-bind="i == midIndex ? timeSeparator : \' \'"></span></td><td class="text-center"><button tabindex="-1" ng-if="row[1].date" style="width: 100%" type="button" class="btn btn-default" ng-class="{\'btn-primary\': row[1].selected}" ng-click="$select(row[1].date, 1)" ng-disabled="row[1].disabled"><span ng-class="{\'text-muted\': row[1].muted}" ng-bind="row[1].label"></span></button></td><td ng-if="showSeconds"><span ng-bind="i == midIndex ? timeSeparator : \' \'"></span></td><td ng-if="showSeconds" class="text-center"><button tabindex="-1" ng-if="row[2].date" style="width: 100%" type="button" class="btn btn-default" ng-class="{\'btn-primary\': row[2].selected}" ng-click="$select(row[2].date, 2)" ng-disabled="row[2].disabled"><span ng-class="{\'text-muted\': row[2].muted}" ng-bind="row[2].label"></span></button></td><td ng-if="showAM">&nbsp;</td><td ng-if="showAM"><button tabindex="-1" ng-show="i == midIndex - !isAM * 1" style="width: 100%" type="button" ng-class="{\'btn-primary\': !!isAM}" class="btn btn-default" ng-click="$switchMeridian()" ng-disabled="el.disabled">AM</button> <button tabindex="-1" ng-show="i == midIndex + 1 - !isAM * 1" style="width: 100%" type="button" ng-class="{\'btn-primary\': !isAM}" class="btn btn-default" ng-click="$switchMeridian()" ng-disabled="el.disabled">PM</button></td></tr></tbody><tfoot><tr class="text-center"><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(1, 0)"><i class="{{ $iconDown }}"></i></button></th><th>&nbsp;</th><th><button tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(1, 1)"><i class="{{ $iconDown }}"></i></button></th><th ng-if="showSeconds">&nbsp;</th><th ng-if="showSeconds"><button ng-if="showSeconds" tabindex="-1" type="button" class="btn btn-default pull-left" ng-click="$arrowAction(1, 2)"><i class="{{ $iconDown }}"></i></button></th></tr></tfoot></table></div>');
  } ]);
  angular.module('mgcrea.ngStrap.tooltip').run([ '$templateCache', function($templateCache) {
    $templateCache.put('tooltip/tooltip.tpl.html', '<div class="tooltip in" ng-show="title"><div class="tooltip-arrow"></div><div class="tooltip-inner" ng-bind="title"></div></div>');
  } ]);
  angular.module('mgcrea.ngStrap.typeahead').run([ '$templateCache', function($templateCache) {
    $templateCache.put('typeahead/typeahead.tpl.html', '<ul tabindex="-1" class="typeahead dropdown-menu" ng-show="$isVisible()" role="select"><li role="presentation" ng-repeat="match in $matches" ng-class="{active: $index == $activeIndex}"><a role="menuitem" tabindex="-1" ng-click="$select($index, $event)" ng-bind="match.label"></a></li></ul>');
  } ]);
})(window, document);

/***/ }),

/***/ 1230:
/***/ (function(module, exports) {

/**
 * AngularStrap - Twitter Bootstrap directives for AngularJS
 * @version v0.7.5 - 2013-07-21
 * @link http://mgcrea.github.com/angular-strap
 * @author Olivier Louvignes <olivier@mg-crea.com>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
angular.module('$strap.config', []).value('$strapConfig', {});
angular.module('$strap.filters', ['$strap.config']);
angular.module('$strap.directives', ['$strap.config']);
angular.module('$strap', [
  '$strap.filters',
  '$strap.directives',
  '$strap.config'
]);
'use strict';
angular.module('$strap.directives').factory('$_modal', [
  '$rootScope',
  '$compile',
  '$http',
  '$timeout',
  '$q',
  '$templateCache',
  '$strapConfig',
  function ($rootScope, $compile, $http, $timeout, $q, $templateCache, $strapConfig) {
    var ModalFactory = function ModalFactory(config) {
      function Modal(config) {
        var options = angular.extend({ show: true }, $strapConfig.modal, config), scope = options.scope ? options.scope : $rootScope.$new(), templateUrl = options.template;
        return $q.when($templateCache.get(templateUrl) || $http.get(templateUrl, { cache: true }).then(function (res) {
          return res.data;
        })).then(function onSuccess(template) {
          var id = templateUrl.replace('.html', '').replace(/[\/|\.|:]/g, '-') + '-' + scope.$id;
          // grafana change, removed fade
          var $modal = $('<div class="modal hide" tabindex="-1"></div>').attr('id', id).html(template);
          if (options.modalClass)
            $modal.addClass(options.modalClass);
          $('body').append($modal);
          $timeout(function () {
            $compile($modal)(scope);
          });
          scope.$_modal = function (name) {
            $modal.modal(name);
          };
          angular.forEach([
            'show',
            'hide'
          ], function (name) {
            scope[name] = function () {
              $modal.modal(name);
            };
          });
          scope.dismiss = scope.hide;
          angular.forEach([
            'show',
            'shown',
            'hide',
            'hidden'
          ], function (name) {
            $modal.on(name, function (ev) {
              scope.$emit('modal-' + name, ev);
            });
          });
          $modal.on('shown', function (ev) {
            $('input[autofocus], textarea[autofocus]', $modal).first().trigger('focus');
          });
          $modal.on('hidden', function (ev) {
            if (!options.persist)
              scope.$destroy();
          });
          scope.$on('$destroy', function () {
            $modal.remove();
          });
          $modal.modal(options);
          return $modal;
        });
      }
      return new Modal(config);
    };
    return ModalFactory;
  }
]);
'use strict';
angular.module('$strap.directives').directive('bsTypeaheadOld', [
  '$parse',
  function ($parse) {
    return {
      restrict: 'A',
      require: '?ngModel',
      link: function postLink(scope, element, attrs, controller) {
        var getter = $parse(attrs.bsTypeaheadOld), setter = getter.assign, value = getter(scope);
        scope.$watch(attrs.bsTypeaheadOld, function (newValue, oldValue) {
          if (newValue !== oldValue) {
            value = newValue;
          }
        });
        element.attr('data-provide', 'typeahead');
        element.typeahead({
          source: function (query) {
            return angular.isFunction(value) ? value.apply(null, arguments) : value;
          },
          minLength: attrs.minLength || 1,
          items: attrs.items,
          updater: function (value) {
            if (controller) {
              scope.$apply(function () {
                controller.$setViewValue(value);
              });
            }
            scope.$emit('typeahead-updated', value);
            return value;
          }
        });
        var typeahead = element.data('typeahead');
        typeahead.lookup = function (ev) {
          var items;
          this.query = this.$element.val() || '';
          if (this.query.length < this.options.minLength) {
            return this.shown ? this.hide() : this;
          }
          items = $.isFunction(this.source) ? this.source(this.query, $.proxy(this.process, this)) : this.source;
          return items ? this.process(items) : this;
        };
        if (!!attrs.matchAll) {
          typeahead.matcher = function (item) {
            return true;
          };
        }
        if (attrs.minLength === '0') {
          setTimeout(function () {
            element.on('focus', function () {
              element.val().length === 0 && setTimeout(element.typeahead.bind(element, 'lookup'), 200);
            });
          });
        }
      }
    };
  }
]);


/***/ }),

/***/ 1231:
/***/ (function(module, exports, __webpack_require__) {

(function() {
    "undefined" == typeof Math.sgn && (Math.sgn = function(a) {
        return 0 == a ? 0 : a > 0 ? 1 : -1
    }
    );
    var a = {
        subtract: function(a, b) {
            return {
                x: a.x - b.x,
                y: a.y - b.y
            }
        },
        dotProduct: function(a, b) {
            return a.x * b.x + a.y * b.y
        },
        square: function(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y)
        },
        scale: function(a, b) {
            return {
                x: a.x * b,
                y: a.y * b
            }
        }
    }
      , b = 64
      , c = Math.pow(2, -b - 1)
      , d = function(b, c) {
        for (var d = [], e = f(b, c), h = c.length - 1, i = 2 * h - 1, j = g(e, i, d, 0), k = a.subtract(b, c[0]), m = a.square(k), n = 0, o = 0; o < j; o++) {
            k = a.subtract(b, l(c, h, d[o], null, null));
            var p = a.square(k);
            p < m && (m = p,
            n = d[o])
        }
        return k = a.subtract(b, c[h]),
        p = a.square(k),
        p < m && (m = p,
        n = 1),
        {
            location: n,
            distance: m
        }
    }
      , e = function(a, b) {
        var c = d(a, b);
        return {
            point: l(b, b.length - 1, c.location, null, null),
            location: c.location
        }
    }
      , f = function(b, c) {
        for (var d = c.length - 1, e = 2 * d - 1, f = [], g = [], h = [], i = [], k = [[1, .6, .3, .1], [.4, .6, .6, .4], [.1, .3, .6, 1]], l = 0; l <= d; l++)
            f[l] = a.subtract(c[l], b);
        for (var l = 0; l <= d - 1; l++)
            g[l] = a.subtract(c[l + 1], c[l]),
            g[l] = a.scale(g[l], 3);
        for (var m = 0; m <= d - 1; m++)
            for (var n = 0; n <= d; n++)
                h[m] || (h[m] = []),
                h[m][n] = a.dotProduct(g[m], f[n]);
        for (l = 0; l <= e; l++)
            i[l] || (i[l] = []),
            i[l].y = 0,
            i[l].x = parseFloat(l) / e;
        for (var o = d, p = d - 1, q = 0; q <= o + p; q++) {
            var r = Math.max(0, q - p)
              , s = Math.min(q, o);
            for (l = r; l <= s; l++)
                j = q - l,
                i[l + j].y += h[j][l] * k[j][l]
        }
        return i
    }
      , g = function(a, c, d, e) {
        var f, j, m = [], n = [], o = [], p = [];
        switch (h(a, c)) {
        case 0:
            return 0;
        case 1:
            if (e >= b)
                return d[0] = (a[0].x + a[c].x) / 2,
                1;
            if (i(a, c))
                return d[0] = k(a, c),
                1
        }
        l(a, c, .5, m, n),
        f = g(m, c, o, e + 1),
        j = g(n, c, p, e + 1);
        for (var q = 0; q < f; q++)
            d[q] = o[q];
        for (var q = 0; q < j; q++)
            d[q + f] = p[q];
        return f + j
    }
      , h = function(a, b) {
        var c, d, e = 0;
        c = d = Math.sgn(a[0].y);
        for (var f = 1; f <= b; f++)
            c = Math.sgn(a[f].y),
            c != d && e++,
            d = c;
        return e
    }
      , i = function(a, b) {
        var d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s;
        i = a[0].y - a[b].y,
        j = a[b].x - a[0].x,
        k = a[0].x * a[b].y - a[b].x * a[0].y;
        for (var t = max_distance_below = 0, u = 1; u < b; u++) {
            var v = i * a[u].x + j * a[u].y + k;
            v > t ? t = v : v < max_distance_below && (max_distance_below = v)
        }
        return n = 0,
        o = 1,
        p = 0,
        q = i,
        r = j,
        s = k - t,
        l = n * r - q * o,
        m = 1 / l,
        e = (o * s - r * p) * m,
        q = i,
        r = j,
        s = k - max_distance_below,
        l = n * r - q * o,
        m = 1 / l,
        f = (o * s - r * p) * m,
        g = Math.min(e, f),
        h = Math.max(e, f),
        d = h - g,
        d < c ? 1 : 0
    }
      , k = function(a, b) {
        var c = 1
          , d = 0
          , e = a[b].x - a[0].x
          , f = a[b].y - a[0].y
          , g = a[0].x - 0
          , h = a[0].y - 0
          , i = e * d - f * c
          , j = 1 / i
          , k = (e * h - f * g) * j;
        return 0 + c * k
    }
      , l = function(a, b, c, d, e) {
        for (var f = [[]], g = 0; g <= b; g++)
            f[0][g] = a[g];
        for (var h = 1; h <= b; h++)
            for (var g = 0; g <= b - h; g++)
                f[h] || (f[h] = []),
                f[h][g] || (f[h][g] = {}),
                f[h][g].x = (1 - c) * f[h - 1][g].x + c * f[h - 1][g + 1].x,
                f[h][g].y = (1 - c) * f[h - 1][g].y + c * f[h - 1][g + 1].y;
        if (null != d)
            for (g = 0; g <= b; g++)
                d[g] = f[g][0];
        if (null != e)
            for (g = 0; g <= b; g++)
                e[g] = f[b - g][g];
        return f[b][0]
    }
      , m = {}
      , n = function(a) {
        var b = m[a];
        if (!b) {
            b = [];
            var c = function() {
                return function(b) {
                    return Math.pow(b, a)
                }
            }
              , d = function() {
                return function(b) {
                    return Math.pow(1 - b, a)
                }
            }
              , e = function(a) {
                return function(b) {
                    return a
                }
            }
              , f = function() {
                return function(a) {
                    return a
                }
            }
              , g = function() {
                return function(a) {
                    return 1 - a
                }
            }
              , h = function(a) {
                return function(b) {
                    for (var c = 1, d = 0; d < a.length; d++)
                        c *= a[d](b);
                    return c
                }
            };
            b.push(new c);
            for (var i = 1; i < a; i++) {
                for (var j = [new e(a)], k = 0; k < a - i; k++)
                    j.push(new f);
                for (var k = 0; k < i; k++)
                    j.push(new g);
                b.push(new h(j))
            }
            b.push(new d),
            m[a] = b
        }
        return b
    }
      , o = function(a, b) {
        for (var c = n(a.length - 1), d = 0, e = 0, f = 0; f < a.length; f++)
            d += a[f].x * c[f](b),
            e += a[f].y * c[f](b);
        return {
            x: d,
            y: e
        }
    }
      , p = function(a, b) {
        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))
    }
      , q = function(a) {
        return a[0].x == a[1].x && a[0].y == a[1].y
    }
      , r = function(a, b, c) {
        if (q(a))
            return {
                point: a[0],
                location: b
            };
        for (var d = o(a, b), e = 0, f = b, g = c > 0 ? 1 : -1, h = null; e < Math.abs(c); )
            f += .005 * g,
            h = o(a, f),
            e += p(h, d),
            d = h;
        return {
            point: h,
            location: f
        }
    }
      , s = function(a) {
        if (q(a))
            return 0;
        for (var b = o(a, 0), c = 0, d = 0, e = 1, f = null; d < 1; )
            d += .005 * e,
            f = o(a, d),
            c += p(f, b),
            b = f;
        return c
    }
      , t = function(a, b, c) {
        return r(a, b, c).point
    }
      , u = function(a, b, c) {
        return r(a, b, c).location
    }
      , v = function(a, b) {
        var c = o(a, b)
          , d = o(a.slice(0, a.length - 1), b)
          , e = d.y - c.y
          , f = d.x - c.x;
        return 0 == e ? 1 / 0 : Math.atan(e / f)
    }
      , w = function(a, b, c) {
        var d = r(a, b, c);
        return d.location > 1 && (d.location = 1),
        d.location < 0 && (d.location = 0),
        v(a, d.location)
    }
      , x = function(a, b, c, d) {
        d = null == d ? 0 : d;
        var e = r(a, b, d)
          , f = v(a, e.location)
          , g = Math.atan(-1 / f)
          , h = c / 2 * Math.sin(g)
          , i = c / 2 * Math.cos(g);
        return [{
            x: e.point.x + i,
            y: e.point.y + h
        }, {
            x: e.point.x - i,
            y: e.point.y - h
        }]
    }
      , y = this.jsBezier = {
        distanceFromCurve: d,
        gradientAtPoint: v,
        gradientAtPointAlongCurveFrom: w,
        nearestPointOnCurve: e,
        pointOnCurve: o,
        pointAlongCurveFrom: t,
        perpendicularToCurveAt: x,
        locationAlongCurveFrom: u,
        getLength: s,
        version: "0.9.0"
    };
    "undefined" != typeof exports && (exports.jsBezier = y)
}
).call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this
      , b = a.Biltong = {
        version: "0.4.0"
    };
    "undefined" != typeof exports && (exports.Biltong = b);
    var c = function(a) {
        return "[object Array]" === Object.prototype.toString.call(a)
    }
      , d = function(a, b, d) {
        return a = c(a) ? a : [a.x, a.y],
        b = c(b) ? b : [b.x, b.y],
        d(a, b)
    }
      , e = b.gradient = function(a, b) {
        return d(a, b, function(a, b) {
            return b[0] == a[0] ? b[1] > a[1] ? 1 / 0 : -(1 / 0) : b[1] == a[1] ? b[0] > a[0] ? 0 : -0 : (b[1] - a[1]) / (b[0] - a[0])
        })
    }
      , f = (b.normal = function(a, b) {
        return -1 / e(a, b)
    }
    ,
    b.lineLength = function(a, b) {
        return d(a, b, function(a, b) {
            return Math.sqrt(Math.pow(b[1] - a[1], 2) + Math.pow(b[0] - a[0], 2))
        })
    }
    ,
    b.quadrant = function(a, b) {
        return d(a, b, function(a, b) {
            return b[0] > a[0] ? b[1] > a[1] ? 2 : 1 : b[0] == a[0] ? b[1] > a[1] ? 2 : 1 : b[1] > a[1] ? 3 : 4
        })
    }
    )
      , g = (b.theta = function(a, b) {
        return d(a, b, function(a, b) {
            var c = e(a, b)
              , d = Math.atan(c)
              , g = f(a, b);
            return 4 != g && 3 != g || (d += Math.PI),
            d < 0 && (d += 2 * Math.PI),
            d
        })
    }
    ,
    b.intersects = function(a, b) {
        var c = a.x
          , d = a.x + a.w
          , e = a.y
          , f = a.y + a.h
          , g = b.x
          , h = b.x + b.w
          , i = b.y
          , j = b.y + b.h;
        return c <= g && g <= d && e <= i && i <= f || c <= h && h <= d && e <= i && i <= f || c <= g && g <= d && e <= j && j <= f || c <= h && g <= d && e <= j && j <= f || g <= c && c <= h && i <= e && e <= j || g <= d && d <= h && i <= e && e <= j || g <= c && c <= h && i <= f && f <= j || g <= d && c <= h && i <= f && f <= j
    }
    ,
    b.encloses = function(a, b, c) {
        var d = a.x
          , e = a.x + a.w
          , f = a.y
          , g = a.y + a.h
          , h = b.x
          , i = b.x + b.w
          , j = b.y
          , k = b.y + b.h
          , l = function(a, b, d, e) {
            return c ? a <= b && d >= e : a < b && d > e
        };
        return l(d, h, e, i) && l(f, j, g, k)
    }
    ,
    [null, [1, -1], [1, 1], [-1, 1], [-1, -1]])
      , h = [null, [-1, -1], [-1, 1], [1, 1], [1, -1]];
    b.pointOnLine = function(a, b, c) {
        var d = e(a, b)
          , i = f(a, b)
          , j = c > 0 ? g[i] : h[i]
          , k = Math.atan(d)
          , l = Math.abs(c * Math.sin(k)) * j[1]
          , m = Math.abs(c * Math.cos(k)) * j[0];
        return {
            x: a.x + m,
            y: a.y + l
        }
    }
    ,
    b.perpendicularLineTo = function(a, b, c) {
        var d = e(a, b)
          , f = Math.atan(-1 / d)
          , g = c / 2 * Math.sin(f)
          , h = c / 2 * Math.cos(f);
        return [{
            x: b.x + h,
            y: b.y + g
        }, {
            x: b.x - h,
            y: b.y - g
        }]
    }
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this
      , b = {
        android: navigator.userAgent.toLowerCase().indexOf("android") > -1
    }
      , c = function(a, b, c) {
        c = c || a.parentNode;
        for (var d = c.querySelectorAll(b), e = 0; e < d.length; e++)
            if (d[e] === a)
                return !0;
        return !1
    }
      , d = function(a) {
        return "string" == typeof a || a.constructor === String ? document.getElementById(a) : a
    }
      , e = function(a) {
        return a.srcElement || a.target
    }
      , f = function(a, b, c, d) {
        if (d) {
            if ("undefined" != typeof a.path && a.path.indexOf)
                return {
                    path: a.path,
                    end: a.path.indexOf(c)
                };
            var e = {
                path: [],
                end: -1
            }
              , f = function(a) {
                e.path.push(a),
                a === c ? e.end = e.path.length - 1 : null != a.parentNode && f(a.parentNode)
            };
            return f(b),
            e
        }
        return {
            path: [b],
            end: 1
        }
    }
      , g = function(a, b) {
        for (var c = 0, d = a.length; c < d && a[c] != b; c++)
            ;
        c < a.length && a.splice(c, 1)
    }
      , h = 1
      , i = function(a, b, c) {
        var d = h++;
        return a.__ta = a.__ta || {},
        a.__ta[b] = a.__ta[b] || {},
        a.__ta[b][d] = c,
        c.__tauid = d,
        d
    }
      , j = function(a, b, c) {
        if (a.__ta && a.__ta[b] && delete a.__ta[b][c.__tauid],
        c.__taExtra) {
            for (var d = 0; d < c.__taExtra.length; d++)
                F(a, c.__taExtra[d][0], c.__taExtra[d][1]);
            c.__taExtra.length = 0
        }
        c.__taUnstore && c.__taUnstore()
    }
      , k = function(a, b, d, g) {
        if (null == a)
            return d;
        var h = a.split(",")
          , i = function(g) {
            i.__tauid = d.__tauid;
            var j = e(g)
              , k = j
              , l = f(g, j, b, null != a);
            if (l.end != -1)
                for (var m = 0; m < l.end; m++) {
                    k = l.path[m];
                    for (var n = 0; n < h.length; n++)
                        c(k, h[n], b) && d.apply(k, arguments)
                }
        };
        return l(d, g, i),
        i
    }
      , l = function(a, b, c) {
        a.__taExtra = a.__taExtra || [],
        a.__taExtra.push([b, c])
    }
      , m = function(a, b, c, d) {
        if (s && u[b]) {
            var e = k(d, a, c, u[b]);
            E(a, u[b], e, c)
        }
        "focus" === b && null == a.getAttribute("tabindex") && a.setAttribute("tabindex", "1"),
        E(a, b, k(d, a, c, b), c)
    }
      , n = function(a, b, c, d) {
        if (null == a.__taSmartClicks) {
            var f = function(b) {
                a.__tad = y(b)
            }
              , h = function(b) {
                a.__tau = y(b)
            }
              , i = function(b) {
                if (a.__tad && a.__tau && a.__tad[0] === a.__tau[0] && a.__tad[1] === a.__tau[1])
                    for (var c = 0; c < a.__taSmartClicks.length; c++)
                        a.__taSmartClicks[c].apply(e(b), [b])
            };
            m(a, "mousedown", f, d),
            m(a, "mouseup", h, d),
            m(a, "click", i, d),
            a.__taSmartClicks = []
        }
        a.__taSmartClicks.push(c),
        c.__taUnstore = function() {
            g(a.__taSmartClicks, c)
        }
    }
      , o = {
        tap: {
            touches: 1,
            taps: 1
        },
        dbltap: {
            touches: 1,
            taps: 2
        },
        contextmenu: {
            touches: 2,
            taps: 1
        }
    }
      , p = function(a, b) {
        return function(d, h, i, j) {
            if ("contextmenu" == h && t)
                m(d, h, i, j);
            else {
                if (null == d.__taTapHandler) {
                    var k = d.__taTapHandler = {
                        tap: [],
                        dbltap: [],
                        contextmenu: [],
                        down: !1,
                        taps: 0,
                        downSelectors: []
                    }
                      , l = function(g) {
                        for (var h = e(g), i = f(g, h, d, null != j), l = !1, m = 0; m < i.end; m++) {
                            if (l)
                                return;
                            h = i.path[m];
                            for (var n = 0; n < k.downSelectors.length; n++)
                                if (null == k.downSelectors[n] || c(h, k.downSelectors[n], d)) {
                                    k.down = !0,
                                    setTimeout(p, a),
                                    setTimeout(q, b),
                                    l = !0;
                                    break
                                }
                        }
                    }
                      , n = function(a) {
                        if (k.down) {
                            var b, g, h = e(a);
                            k.taps++;
                            var i = D(a);
                            for (var j in o)
                                if (o.hasOwnProperty(j)) {
                                    var l = o[j];
                                    if (l.touches === i && (1 === l.taps || l.taps === k.taps))
                                        for (var m = 0; m < k[j].length; m++) {
                                            g = f(a, h, d, null != k[j][m][1]);
                                            for (var n = 0; n < g.end; n++)
                                                if (b = g.path[n],
                                                null == k[j][m][1] || c(b, k[j][m][1], d)) {
                                                    k[j][m][0].apply(b, [a]);
                                                    break
                                                }
                                        }
                                }
                        }
                    }
                      , p = function() {
                        k.down = !1
                    }
                      , q = function() {
                        k.taps = 0
                    };
                    m(d, "mousedown", l),
                    m(d, "mouseup", n)
                }
                d.__taTapHandler.downSelectors.push(j),
                d.__taTapHandler[h].push([i, j]),
                i.__taUnstore = function() {
                    g(d.__taTapHandler[h], i)
                }
            }
        }
    }
      , q = function(a, b, c, d) {
        for (var e in c.__tamee[a])
            c.__tamee[a].hasOwnProperty(e) && c.__tamee[a][e].apply(d, [b])
    }
      , r = function() {
        var a = [];
        return function(b, d, f, g) {
            if (!b.__tamee) {
                b.__tamee = {
                    over: !1,
                    mouseenter: [],
                    mouseexit: []
                };
                var h = function(d) {
                    var f = e(d);
                    (null == g && f == b && !b.__tamee.over || c(f, g, b) && (null == f.__tamee || !f.__tamee.over)) && (q("mouseenter", d, b, f),
                    f.__tamee = f.__tamee || {},
                    f.__tamee.over = !0,
                    a.push(f))
                }
                  , j = function(d) {
                    for (var f = e(d), g = 0; g < a.length; g++)
                        f != a[g] || c(d.relatedTarget || d.toElement, "*", f) || (f.__tamee.over = !1,
                        a.splice(g, 1),
                        q("mouseexit", d, b, f))
                };
                E(b, "mouseover", k(g, b, h, "mouseover"), h),
                E(b, "mouseout", k(g, b, j, "mouseout"), j)
            }
            f.__taUnstore = function() {
                delete b.__tamee[d][f.__tauid]
            }
            ,
            i(b, d, f),
            b.__tamee[d][f.__tauid] = f
        }
    }
      , s = "ontouchstart"in document.documentElement
      , t = "onmousedown"in document.documentElement
      , u = {
        mousedown: "touchstart",
        mouseup: "touchend",
        mousemove: "touchmove"
    }
      , v = function() {
        var a = -1;
        if ("Microsoft Internet Explorer" == navigator.appName) {
            var b = navigator.userAgent
              , c = new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})");
            null != c.exec(b) && (a = parseFloat(RegExp.$1))
        }
        return a
    }()
      , w = v > -1 && v < 9
      , x = function(a, b) {
        if (null == a)
            return [0, 0];
        var c = C(a)
          , d = B(c, 0);
        return [d[b + "X"], d[b + "Y"]]
    }
      , y = function(a) {
        return null == a ? [0, 0] : w ? [a.clientX + document.documentElement.scrollLeft, a.clientY + document.documentElement.scrollTop] : x(a, "page")
    }
      , z = function(a) {
        return x(a, "screen")
    }
      , A = function(a) {
        return x(a, "client")
    }
      , B = function(a, b) {
        return a.item ? a.item(b) : a[b]
    }
      , C = function(a) {
        return a.touches && a.touches.length > 0 ? a.touches : a.changedTouches && a.changedTouches.length > 0 ? a.changedTouches : a.targetTouches && a.targetTouches.length > 0 ? a.targetTouches : [a]
    }
      , D = function(a) {
        return C(a).length
    }
      , E = function(a, b, c, d) {
        if (i(a, b, c),
        d.__tauid = c.__tauid,
        a.addEventListener)
            a.addEventListener(b, c, !1);
        else if (a.attachEvent) {
            var e = b + c.__tauid;
            a["e" + e] = c,
            a[e] = function() {
                a["e" + e] && a["e" + e](window.event)
            }
            ,
            a.attachEvent("on" + b, a[e])
        }
    }
      , F = function(a, b, c) {
        null != c && G(a, function() {
            var e = d(this);
            if (j(e, b, c),
            null != c.__tauid)
                if (e.removeEventListener)
                    e.removeEventListener(b, c, !1),
                    s && u[b] && e.removeEventListener(u[b], c, !1);
                else if (this.detachEvent) {
                    var f = b + c.__tauid;
                    e[f] && e.detachEvent("on" + b, e[f]),
                    e[f] = null,
                    e["e" + f] = null
                }
            c.__taTouchProxy && F(a, c.__taTouchProxy[1], c.__taTouchProxy[0])
        })
    }
      , G = function(a, b) {
        if (null != a) {
            a = "undefined" != typeof Window && "unknown" != typeof a.top && a == a.top ? [a] : "string" != typeof a && null == a.tagName && null != a.length ? a : "string" == typeof a ? document.querySelectorAll(a) : [a];
            for (var c = 0; c < a.length; c++)
                b.apply(a[c])
        }
    };
    a.Mottle = function(a) {
        a = a || {};
        var c = a.clickThreshold || 250
          , e = a.dblClickThreshold || 450
          , f = new r
          , g = new p(c,e)
          , h = a.smartClicks
          , i = function(a, b, c, e) {
            null != c && G(a, function() {
                var a = d(this);
                h && "click" === b ? n(a, b, c, e) : "tap" === b || "dbltap" === b || "contextmenu" === b ? g(a, b, c, e) : "mouseenter" === b || "mouseexit" == b ? f(a, b, c, e) : m(a, b, c, e)
            })
        };
        this.remove = function(a) {
            return G(a, function() {
                var a = d(this);
                if (a.__ta)
                    for (var b in a.__ta)
                        if (a.__ta.hasOwnProperty(b))
                            for (var c in a.__ta[b])
                                a.__ta[b].hasOwnProperty(c) && F(a, b, a.__ta[b][c]);
                a.parentNode && a.parentNode.removeChild(a)
            }),
            this
        }
        ,
        this.on = function(a, b, c, d) {
            var e = arguments[0]
              , f = 4 == arguments.length ? arguments[2] : null
              , g = arguments[1]
              , h = arguments[arguments.length - 1];
            return i(e, g, h, f),
            this
        }
        ,
        this.off = function(a, b, c) {
            return F(a, b, c),
            this
        }
        ,
        this.trigger = function(a, c, e, f) {
            var g = t && ("undefined" == typeof MouseEvent || null == e || e.constructor === MouseEvent)
              , h = s && !t && u[c] ? u[c] : c
              , i = !(s && !t && u[c])
              , j = y(e)
              , k = z(e)
              , l = A(e);
            return G(a, function() {
                var a, m = d(this);
                e = e || {
                    screenX: k[0],
                    screenY: k[1],
                    clientX: l[0],
                    clientY: l[1]
                };
                var n = function(a) {
                    f && (a.payload = f)
                }
                  , o = {
                    TouchEvent: function(a) {
                        var b = document.createTouch(window, m, 0, j[0], j[1], k[0], k[1], l[0], l[1], 0, 0, 0, 0)
                          , c = document.createTouchList(b)
                          , d = document.createTouchList(b)
                          , e = document.createTouchList(b);
                        a.initTouchEvent(h, !0, !0, window, null, k[0], k[1], l[0], l[1], !1, !1, !1, !1, c, d, e, 1, 0)
                    },
                    MouseEvents: function(a) {
                        if (a.initMouseEvent(h, !0, !0, window, 0, k[0], k[1], l[0], l[1], !1, !1, !1, !1, 1, m),
                        b.android) {
                            var c = document.createTouch(window, m, 0, j[0], j[1], k[0], k[1], l[0], l[1], 0, 0, 0, 0);
                            a.touches = a.targetTouches = a.changedTouches = document.createTouchList(c)
                        }
                    }
                };
                if (document.createEvent) {
                    var p = !i && !g && s && u[c] && !b.android
                      , q = p ? "TouchEvent" : "MouseEvents";
                    a = document.createEvent(q),
                    o[q](a),
                    n(a),
                    m.dispatchEvent(a)
                } else
                    document.createEventObject && (a = document.createEventObject(),
                    a.eventType = a.eventName = h,
                    a.screenX = k[0],
                    a.screenY = k[1],
                    a.clientX = l[0],
                    a.clientY = l[1],
                    n(a),
                    m.fireEvent("on" + h, a))
            }),
            this
        }
    }
    ,
    a.Mottle.consume = function(a, b) {
        a.stopPropagation ? a.stopPropagation() : a.returnValue = !1,
        !b && a.preventDefault && a.preventDefault()
    }
    ,
    a.Mottle.pageLocation = y,
    a.Mottle.setForceTouchEvents = function(a) {
        s = a
    }
    ,
    a.Mottle.setForceMouseEvents = function(a) {
        t = a
    }
    ,
    a.Mottle.version = "0.8.0",
    "undefined" != typeof exports && (exports.Mottle = a.Mottle)
}
.call("undefined" == typeof window ? this : window),
function() {
    "use strict";
    var a = this
      , b = function(a, b, c) {
        return a.indexOf(b) === -1 && (c ? a.unshift(b) : a.push(b),
        !0)
    }
      , c = function(a, b) {
        var c = a.indexOf(b);
        c != -1 && a.splice(c, 1)
    }
      , d = function(a, b) {
        for (var c = [], d = 0; d < a.length; d++)
            b.indexOf(a[d]) == -1 && c.push(a[d]);
        return c
    }
      , e = function(a) {
        return null != a && ("string" == typeof a || a.constructor == String)
    }
      , f = function(a) {
        var b = a.getBoundingClientRect()
          , c = document.body
          , d = document.documentElement
          , e = window.pageYOffset || d.scrollTop || c.scrollTop
          , f = window.pageXOffset || d.scrollLeft || c.scrollLeft
          , g = d.clientTop || c.clientTop || 0
          , h = d.clientLeft || c.clientLeft || 0
          , i = b.top + e - g
          , j = b.left + f - h;
        return {
            top: Math.round(i),
            left: Math.round(j)
        }
    }
      , g = function(a, b, c) {
        c = c || a.parentNode;
        for (var d = c.querySelectorAll(b), e = 0; e < d.length; e++)
            if (d[e] === a)
                return !0;
        return !1
    }
      , h = function() {
        var a = -1;
        if ("Microsoft Internet Explorer" == navigator.appName) {
            var b = navigator.userAgent
              , c = new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})");
            null != c.exec(b) && (a = parseFloat(RegExp.$1))
        }
        return a
    }()
      , i = 50
      , j = 50
      , k = h > -1 && h < 9
      , l = 9 == h
      , m = function(a) {
        if (k)
            return [a.clientX + document.documentElement.scrollLeft, a.clientY + document.documentElement.scrollTop];
        var b = o(a)
          , c = n(b, 0);
        return l ? [c.pageX || c.clientX, c.pageY || c.clientY] : [c.pageX, c.pageY]
    }
      , n = function(a, b) {
        return a.item ? a.item(b) : a[b]
    }
      , o = function(a) {
        return a.touches && a.touches.length > 0 ? a.touches : a.changedTouches && a.changedTouches.length > 0 ? a.changedTouches : a.targetTouches && a.targetTouches.length > 0 ? a.targetTouches : [a]
    }
      , p = {
        draggable: "katavorio-draggable",
        droppable: "katavorio-droppable",
        drag: "katavorio-drag",
        selected: "katavorio-drag-selected",
        active: "katavorio-drag-active",
        hover: "katavorio-drag-hover",
        noSelect: "katavorio-drag-no-select",
        ghostProxy: "katavorio-ghost-proxy"
    }
      , q = "katavorio-drag-scope"
      , r = ["stop", "start", "drag", "drop", "over", "out", "beforeStart"]
      , s = function() {}
      , t = function() {
        return !0
    }
      , u = function(a, b, c) {
        for (var d = 0; d < a.length; d++)
            a[d] != c && b(a[d])
    }
      , v = function(a, b, c, d) {
        u(a, function(a) {
            a.setActive(b),
            b && a.updatePosition(),
            c && a.setHover(d, b)
        })
    }
      , w = function(a, b) {
        if (null != a) {
            a = e(a) || null != a.tagName || null == a.length ? [a] : a;
            for (var c = 0; c < a.length; c++)
                b.apply(a[c], [a[c]])
        }
    }
      , x = function(a) {
        a.stopPropagation ? (a.stopPropagation(),
        a.preventDefault()) : a.returnValue = !1
    }
      , y = "input,textarea,select,button,option"
      , z = function(a, b, c) {
        var d = a.srcElement || a.target;
        return !g(d, c.getInputFilterSelector(), b)
    }
      , A = function(a, b, c, d) {
        this.params = b || {},
        this.el = a,
        this.params.addClass(this.el, this._class),
        this.uuid = F();
        var e = !0;
        return this.setEnabled = function(a) {
            e = a
        }
        ,
        this.isEnabled = function() {
            return e
        }
        ,
        this.toggleEnabled = function() {
            e = !e
        }
        ,
        this.setScope = function(a) {
            this.scopes = a ? a.split(/\s+/) : [d]
        }
        ,
        this.addScope = function(a) {
            var b = {};
            w(this.scopes, function(a) {
                b[a] = !0
            }),
            w(a ? a.split(/\s+/) : [], function(a) {
                b[a] = !0
            }),
            this.scopes = [];
            for (var c in b)
                this.scopes.push(c)
        }
        ,
        this.removeScope = function(a) {
            var b = {};
            w(this.scopes, function(a) {
                b[a] = !0
            }),
            w(a ? a.split(/\s+/) : [], function(a) {
                delete b[a]
            }),
            this.scopes = [];
            for (var c in b)
                this.scopes.push(c)
        }
        ,
        this.toggleScope = function(a) {
            var b = {};
            w(this.scopes, function(a) {
                b[a] = !0
            }),
            w(a ? a.split(/\s+/) : [], function(a) {
                b[a] ? delete b[a] : b[a] = !0
            }),
            this.scopes = [];
            for (var c in b)
                this.scopes.push(c)
        }
        ,
        this.setScope(b.scope),
        this.k = b.katavorio,
        b.katavorio
    }
      , B = function() {
        return !0
    }
      , C = function() {
        return !1
    }
      , D = function(a, b, c, d) {
        this._class = c.draggable;
        var h = A.apply(this, arguments);
        this.rightButtonCanDrag = this.params.rightButtonCanDrag;
        var k = [0, 0]
          , l = null
          , n = null
          , o = [0, 0]
          , q = !1
          , r = this.params.consumeStartEvent !== !1
          , s = this.el
          , u = this.params.clone
          , w = (this.params.scroll,
        b.multipleDrop !== !1)
          , y = !1
          , D = b.ghostProxy === !0 ? B : b.ghostProxy && "function" == typeof b.ghostProxy ? b.ghostProxy : C
          , E = function(a) {
            return a.cloneNode(!0)
        }
          , H = b.snapThreshold || 5
          , I = function(a, b, c, d, e) {
            d = d || H,
            e = e || H;
            var f = Math.floor(a[0] / b)
              , g = b * f
              , h = g + b
              , i = Math.abs(a[0] - g) <= d ? g : Math.abs(h - a[0]) <= d ? h : a[0]
              , j = Math.floor(a[1] / c)
              , k = c * j
              , l = k + c
              , m = Math.abs(a[1] - k) <= e ? k : Math.abs(l - a[1]) <= e ? l : a[1];
            return [i, m]
        };
        this.posses = [],
        this.posseRoles = {},
        this.toGrid = function(a) {
            return null == this.params.grid ? a : I(a, this.params.grid[0], this.params.grid[1])
        }
        ,
        this.snap = function(a, b) {
            if (null != s) {
                a = a || (this.params.grid ? this.params.grid[0] : i),
                b = b || (this.params.grid ? this.params.grid[1] : j);
                var c = this.params.getPosition(s);
                this.params.setPosition(s, I(c, a, b, a, b))
            }
        }
        ,
        this.setUseGhostProxy = function(a) {
            D = a ? B : C
        }
        ;
        var J, K = function(a) {
            return b.allowNegative === !1 ? [Math.max(0, a[0]), Math.max(0, a[1])] : a
        }, L = function(a) {
            J = "function" == typeof a ? a : a ? function(a) {
                return K([Math.max(0, Math.min(R.w - this.size[0], a[0])), Math.max(0, Math.min(R.h - this.size[1], a[1]))])
            }
            .bind(this) : function(a) {
                return K(a)
            }
        }
        .bind(this);
        L("function" == typeof this.params.constrain ? this.params.constrain : this.params.constrain || this.params.containment),
        this.setConstrain = function(a) {
            L(a)
        }
        ;
        var M;
        this.setRevert = function(a) {
            M = a
        }
        ;
        var N = function(a) {
            return "function" == typeof a ? (a._katavorioId = F(),
            a._katavorioId) : a
        }
          , O = {}
          , P = function(a) {
            for (var b in O) {
                var c = O[b]
                  , d = c[0](a);
                if (c[1] && (d = !d),
                !d)
                    return !1
            }
            return !0
        }
          , Q = this.setFilter = function(b, c) {
            if (b) {
                var d = N(b);
                O[d] = [function(c) {
                    var d, f = c.srcElement || c.target;
                    return e(b) ? d = g(f, b, a) : "function" == typeof b && (d = b(c, a)),
                    d
                }
                , c !== !1]
            }
        }
        ;
        this.addFilter = Q,
        this.removeFilter = function(a) {
            var b = "function" == typeof a ? a._katavorioId : a;
            delete O[b]
        }
        ;
        this.clearAllFilters = function() {
            O = {}
        }
        ,
        this.canDrag = this.params.canDrag || t;
        var R, S = [], T = [];
        this.downListener = function(a) {
            var b = this.rightButtonCanDrag || 3 !== a.which && 2 !== a.button;
            if (b && this.isEnabled() && this.canDrag()) {
                var d = P(a) && z(a, this.el, this.k);
                if (d) {
                    if (u) {
                        s = this.el.cloneNode(!0),
                        s.setAttribute("id", null),
                        s.style.position = "absolute";
                        var e = f(this.el);
                        s.style.left = e.left + "px",
                        s.style.top = e.top + "px",
                        document.body.appendChild(s)
                    } else
                        s = this.el;
                    r && x(a),
                    k = m(a),
                    this.params.bind(document, "mousemove", this.moveListener),
                    this.params.bind(document, "mouseup", this.upListener),
                    h.markSelection(this),
                    h.markPosses(this),
                    this.params.addClass(document.body, c.noSelect),
                    V("beforeStart", {
                        el: this.el,
                        pos: l,
                        e: a,
                        drag: this
                    })
                } else
                    this.params.consumeFilteredEvents && x(a)
            }
        }
        .bind(this),
        this.moveListener = function(a) {
            if (k) {
                if (!q) {
                    var b = V("start", {
                        el: this.el,
                        pos: l,
                        e: a,
                        drag: this
                    });
                    if (b !== !1) {
                        if (!k)
                            return;
                        this.mark(!0),
                        q = !0
                    }
                }
                if (k) {
                    T.length = 0;
                    var c = m(a)
                      , d = c[0] - k[0]
                      , e = c[1] - k[1]
                      , f = this.params.ignoreZoom ? 1 : h.getZoom();
                    d /= f,
                    e /= f,
                    this.moveBy(d, e, a),
                    h.updateSelection(d, e, this),
                    h.updatePosses(d, e, this)
                }
            }
        }
        .bind(this),
        this.upListener = function(a) {
            k && (k = null,
            this.params.unbind(document, "mousemove", this.moveListener),
            this.params.unbind(document, "mouseup", this.upListener),
            this.params.removeClass(document.body, c.noSelect),
            this.unmark(a),
            h.unmarkSelection(this, a),
            h.unmarkPosses(this, a),
            this.stop(a),
            h.notifySelectionDragStop(this, a),
            h.notifyPosseDragStop(this, a),
            q = !1,
            u && (s && s.parentNode && s.parentNode.removeChild(s),
            s = null),
            T.length = 0,
            M && M(this.el, this.params.getPosition(this.el)) === !0 && (this.params.setPosition(this.el, l),
            V("revert", this.el)))
        }
        .bind(this),
        this.getFilters = function() {
            return O
        }
        ,
        this.abort = function() {
            null != k && this.upListener()
        }
        ,
        this.getDragElement = function() {
            return s || this.el
        }
        ;
        var U = {
            start: [],
            drag: [],
            stop: [],
            over: [],
            out: [],
            beforeStart: [],
            revert: []
        };
        b.events.start && U.start.push(b.events.start),
        b.events.beforeStart && U.beforeStart.push(b.events.beforeStart),
        b.events.stop && U.stop.push(b.events.stop),
        b.events.drag && U.drag.push(b.events.drag),
        b.events.revert && U.revert.push(b.events.revert),
        this.on = function(a, b) {
            U[a] && U[a].push(b)
        }
        ,
        this.off = function(a, b) {
            if (U[a]) {
                for (var c = [], d = 0; d < U[a].length; d++)
                    U[a][d] !== b && c.push(U[a][d]);
                U[a] = c
            }
        }
        ;
        var V = function(a, b) {
            if (U[a])
                for (var c = 0; c < U[a].length; c++)
                    try {
                        U[a][c](b)
                    } catch (a) {}
        };
        this.notifyStart = function(a) {
            V("start", {
                el: this.el,
                pos: this.params.getPosition(s),
                e: a,
                drag: this
            })
        }
        ,
        this.stop = function(a, b) {
            if (b || q) {
                var c = []
                  , d = h.getSelection()
                  , e = this.params.getPosition(s);
                if (d.length > 1)
                    for (var f = 0; f < d.length; f++) {
                        var g = this.params.getPosition(d[f].el);
                        c.push([d[f].el, {
                            left: g[0],
                            top: g[1]
                        }, d[f]])
                    }
                else
                    c.push([s, {
                        left: e[0],
                        top: e[1]
                    }, this]);
                V("stop", {
                    el: s,
                    pos: W || e,
                    finalPos: e,
                    e: a,
                    drag: this,
                    selection: c
                })
            }
        }
        ,
        this.mark = function(a) {
            l = this.params.getPosition(s),
            n = this.params.getPosition(s, !0),
            o = [n[0] - l[0], n[1] - l[1]],
            this.size = this.params.getSize(s),
            S = h.getMatchingDroppables(this),
            v(S, !0, !1, this),
            this.params.addClass(s, this.params.dragClass || c.drag);
            var b = this.params.getSize(s.parentNode);
            R = {
                w: b[0],
                h: b[1]
            },
            a && h.notifySelectionDragStart(this)
        }
        ;
        var W;
        this.unmark = function(a, d) {
            if (v(S, !1, !0, this),
            y && D(this.el) ? (W = [s.offsetLeft, s.offsetTop],
            this.el.parentNode.removeChild(s),
            s = this.el) : W = null,
            this.params.removeClass(s, this.params.dragClass || c.drag),
            S.length = 0,
            y = !1,
            !d) {
                T.length > 0 && W && b.setPosition(this.el, W),
                T.sort(G);
                for (var e = 0; e < T.length; e++) {
                    var f = T[e].drop(this, a);
                    if (f === !0)
                        break
                }
            }
        }
        ,
        this.moveBy = function(a, c, d) {
            T.length = 0;
            var e = this.toGrid([l[0] + a, l[1] + c])
              , f = J(e, s);
            if (D(this.el))
                if (e[0] != f[0] || e[1] != f[1]) {
                    if (!y) {
                        var g = E(this.el);
                        b.addClass(g, p.ghostProxy),
                        this.el.parentNode.appendChild(g),
                        s = g,
                        y = !0
                    }
                    f = e
                } else
                    y && (this.el.parentNode.removeChild(s),
                    s = this.el,
                    y = !1);
            var h = {
                x: f[0],
                y: f[1],
                w: this.size[0],
                h: this.size[1]
            }
              , i = {
                x: h.x + o[0],
                y: h.y + o[1],
                w: h.w,
                h: h.h
            }
              , j = null;
            this.params.setPosition(s, f);
            for (var k = 0; k < S.length; k++) {
                var m = {
                    x: S[k].pagePosition[0],
                    y: S[k].pagePosition[1],
                    w: S[k].size[0],
                    h: S[k].size[1]
                };
                this.params.intersects(i, m) && (w || null == j || j == S[k].el) && S[k].canDrop(this) ? (j || (j = S[k].el),
                T.push(S[k]),
                S[k].setHover(this, !0, d)) : S[k].isHover() && S[k].setHover(this, !1, d)
            }
            V("drag", {
                el: this.el,
                pos: f,
                e: d,
                drag: this
            })
        }
        ,
        this.destroy = function() {
            this.params.unbind(this.el, "mousedown", this.downListener),
            this.params.unbind(document, "mousemove", this.moveListener),
            this.params.unbind(document, "mouseup", this.upListener),
            this.downListener = null,
            this.upListener = null,
            this.moveListener = null
        }
        ,
        this.params.bind(this.el, "mousedown", this.downListener),
        this.params.handle ? Q(this.params.handle, !1) : Q(this.params.filter, this.params.filterExclude)
    }
      , E = function(a, b, c, d) {
        this._class = c.droppable,
        this.params = b || {},
        this.rank = b.rank || 0,
        this._activeClass = this.params.activeClass || c.active,
        this._hoverClass = this.params.hoverClass || c.hover,
        A.apply(this, arguments);
        var e = !1;
        this.allowLoopback = this.params.allowLoopback !== !1,
        this.setActive = function(a) {
            this.params[a ? "addClass" : "removeClass"](this.el, this._activeClass)
        }
        ,
        this.updatePosition = function() {
            this.position = this.params.getPosition(this.el),
            this.pagePosition = this.params.getPosition(this.el, !0),
            this.size = this.params.getSize(this.el)
        }
        ,
        this.canDrop = this.params.canDrop || function(a) {
            return !0
        }
        ,
        this.isHover = function() {
            return e
        }
        ,
        this.setHover = function(a, b, c) {
            (b || null == this.el._katavorioDragHover || this.el._katavorioDragHover == a.el._katavorio) && (this.params[b ? "addClass" : "removeClass"](this.el, this._hoverClass),
            this.el._katavorioDragHover = b ? a.el._katavorio : null,
            e !== b && this.params.events[b ? "over" : "out"]({
                el: this.el,
                e: c,
                drag: a,
                drop: this
            }),
            e = b)
        }
        ,
        this.drop = function(a, b) {
            return this.params.events.drop({
                drag: a,
                e: b,
                drop: this
            })
        }
        ,
        this.destroy = function() {
            this._class = null,
            this._activeClass = null,
            this._hoverClass = null,
            e = null
        }
    }
      , F = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(a) {
            var b = 16 * Math.random() | 0
              , c = "x" == a ? b : 3 & b | 8;
            return c.toString(16)
        })
    }
      , G = function(a, b) {
        return a.rank < b.rank ? 1 : a.rank > b.rank ? -1 : 0
    }
      , H = function(a) {
        return null == a ? null : (a = "string" == typeof a || a.constructor == String ? document.getElementById(a) : a,
        null == a ? null : (a._katavorio = a._katavorio || F(),
        a))
    };
    a.Katavorio = function(a) {
        var f = []
          , g = {};
        this._dragsByScope = {},
        this._dropsByScope = {};
        var h = 1
          , i = function(a, b) {
            w(a, function(a) {
                for (var c = 0; c < a.scopes.length; c++)
                    b[a.scopes[c]] = b[a.scopes[c]] || [],
                    b[a.scopes[c]].push(a)
            })
        }
          , j = function(b, c) {
            var d = 0;
            return w(b, function(b) {
                for (var e = 0; e < b.scopes.length; e++)
                    if (c[b.scopes[e]]) {
                        var f = a.indexOf(c[b.scopes[e]], b);
                        f != -1 && (c[b.scopes[e]].splice(f, 1),
                        d++)
                    }
            }),
            d > 0
        }
          , k = (this.getMatchingDroppables = function(a) {
            for (var b = [], c = {}, d = 0; d < a.scopes.length; d++) {
                var e = this._dropsByScope[a.scopes[d]];
                if (e)
                    for (var f = 0; f < e.length; f++)
                        !e[f].canDrop(a) || c[e[f].uuid] || !e[f].allowLoopback && e[f].el === a.el || (c[e[f].uuid] = !0,
                        b.push(e[f]))
            }
            return b.sort(G),
            b
        }
        ,
        function(b) {
            b = b || {};
            var c, d = {
                events: {}
            };
            for (c in a)
                d[c] = a[c];
            for (c in b)
                d[c] = b[c];
            for (c = 0; c < r.length; c++)
                d.events[r[c]] = b[r[c]] || s;
            return d.katavorio = this,
            d
        }
        .bind(this))
          , l = function(a, b) {
            for (var c = 0; c < r.length; c++)
                b[r[c]] && a.on(r[c], b[r[c]])
        }
        .bind(this)
          , m = {}
          , n = a.css || {}
          , o = a.scope || q;
        for (var t in p)
            m[t] = p[t];
        for (var t in n)
            m[t] = n[t];
        var v = a.inputFilterSelector || y;
        this.getInputFilterSelector = function() {
            return v
        }
        ,
        this.setInputFilterSelector = function(a) {
            return v = a,
            this
        }
        ,
        this.draggable = function(b, c) {
            var d = [];
            return w(b, function(b) {
                if (b = H(b),
                null != b)
                    if (null == b._katavorioDrag) {
                        var e = k(c);
                        b._katavorioDrag = new D(b,e,m,o),
                        i(b._katavorioDrag, this._dragsByScope),
                        d.push(b._katavorioDrag),
                        a.addClass(b, m.draggable)
                    } else
                        l(b._katavorioDrag, c)
            }
            .bind(this)),
            d
        }
        ,
        this.droppable = function(b, c) {
            var d = [];
            return w(b, function(b) {
                if (b = H(b),
                null != b) {
                    var e = new E(b,k(c),m,o);
                    b._katavorioDrop = b._katavorioDrop || [],
                    b._katavorioDrop.push(e),
                    i(e, this._dropsByScope),
                    d.push(e),
                    a.addClass(b, m.droppable)
                }
            }
            .bind(this)),
            d
        }
        ,
        this.select = function(b) {
            return w(b, function() {
                var b = H(this);
                b && b._katavorioDrag && (g[b._katavorio] || (f.push(b._katavorioDrag),
                g[b._katavorio] = [b, f.length - 1],
                a.addClass(b, m.selected)))
            }),
            this
        }
        ,
        this.deselect = function(b) {
            return w(b, function() {
                var b = H(this);
                if (b && b._katavorio) {
                    var c = g[b._katavorio];
                    if (c) {
                        for (var d = [], e = 0; e < f.length; e++)
                            f[e].el !== b && d.push(f[e]);
                        f = d,
                        delete g[b._katavorio],
                        a.removeClass(b, m.selected)
                    }
                }
            }),
            this
        }
        ,
        this.deselectAll = function() {
            for (var b in g) {
                var c = g[b];
                a.removeClass(c[0], m.selected)
            }
            f.length = 0,
            g = {}
        }
        ,
        this.markSelection = function(a) {
            u(f, function(a) {
                a.mark()
            }, a)
        }
        ,
        this.markPosses = function(a) {
            a.posses && w(a.posses, function(b) {
                a.posseRoles[b] && B[b] && u(B[b].members, function(a) {
                    a.mark()
                }, a)
            })
        }
        ,
        this.unmarkSelection = function(a, b) {
            u(f, function(a) {
                a.unmark(b)
            }, a)
        }
        ,
        this.unmarkPosses = function(a, b) {
            a.posses && w(a.posses, function(c) {
                a.posseRoles[c] && B[c] && u(B[c].members, function(a) {
                    a.unmark(b, !0)
                }, a)
            })
        }
        ,
        this.getSelection = function() {
            return f.slice(0)
        }
        ,
        this.updateSelection = function(a, b, c) {
            u(f, function(c) {
                c.moveBy(a, b)
            }, c)
        }
        ;
        var x = function(a, b) {
            b.posses && w(b.posses, function(c) {
                b.posseRoles[c] && B[c] && u(B[c].members, function(b) {
                    a(b)
                }, b)
            })
        };
        this.updatePosses = function(a, b, c) {
            x(function(c) {
                c.moveBy(a, b)
            }, c)
        }
        ,
        this.notifyPosseDragStop = function(a, b) {
            x(function(a) {
                a.stop(b, !0)
            }, a)
        }
        ,
        this.notifySelectionDragStop = function(a, b) {
            u(f, function(a) {
                a.stop(b, !0)
            }, a)
        }
        ,
        this.notifySelectionDragStart = function(a, b) {
            u(f, function(a) {
                a.notifyStart(b)
            }, a)
        }
        ,
        this.setZoom = function(a) {
            h = a
        }
        ,
        this.getZoom = function() {
            return h
        }
        ;
        var z = function(a, b, c, d) {
            w(a, function(a) {
                j(a, c),
                a[d](b),
                i(a, c)
            })
        };
        w(["set", "add", "remove", "toggle"], function(a) {
            this[a + "Scope"] = function(b, c) {
                z(b._katavorioDrag, c, this._dragsByScope, a + "Scope"),
                z(b._katavorioDrop, c, this._dropsByScope, a + "Scope")
            }
            .bind(this),
            this[a + "DragScope"] = function(b, c) {
                z(b.constructor === D ? b : b._katavorioDrag, c, this._dragsByScope, a + "Scope")
            }
            .bind(this),
            this[a + "DropScope"] = function(b, c) {
                z(b.constructor === E ? b : b._katavorioDrop, c, this._dropsByScope, a + "Scope")
            }
            .bind(this)
        }
        .bind(this)),
        this.snapToGrid = function(a, b) {
            for (var c in this._dragsByScope)
                u(this._dragsByScope[c], function(c) {
                    c.snap(a, b)
                })
        }
        ,
        this.getDragsForScope = function(a) {
            return this._dragsByScope[a]
        }
        ,
        this.getDropsForScope = function(a) {
            return this._dropsByScope[a]
        }
        ;
        var A = function(a, b, c) {
            if (a = H(a),
            a[b]) {
                var d = f.indexOf(a[b]);
                d >= 0 && f.splice(d, 1),
                j(a[b], c) && w(a[b], function(a) {
                    a.destroy()
                }),
                delete a[b]
            }
        };
        this.elementRemoved = function(a) {
            this.destroyDraggable(a),
            this.destroyDroppable(a)
        }
        ,
        this.destroyDraggable = function(a) {
            A(a, "_katavorioDrag", this._dragsByScope)
        }
        ,
        this.destroyDroppable = function(a) {
            A(a, "_katavorioDrop", this._dropsByScope)
        }
        ,
        this.reset = function() {
            this._dragsByScope = {},
            this._dropsByScope = {},
            f = [],
            g = {},
            B = {}
        }
        ;
        var B = {}
          , C = function(a, c, d) {
            var f = e(c) ? c : c.id
              , g = !!e(c) || c.active !== !1
              , h = B[f] || function() {
                var a = {
                    name: f,
                    members: []
                };
                return B[f] = a,
                a
            }();
            return w(a, function(a) {
                if (a._katavorioDrag) {
                    if (d && null != a._katavorioDrag.posseRoles[h.name])
                        return;
                    b(h.members, a._katavorioDrag),
                    b(a._katavorioDrag.posses, h.name),
                    a._katavorioDrag.posseRoles[h.name] = g
                }
            }),
            h
        };
        this.addToPosse = function(a, b) {
            for (var c = [], d = 1; d < arguments.length; d++)
                c.push(C(a, arguments[d]));
            return 1 == c.length ? c[0] : c
        }
        ,
        this.setPosse = function(a, b) {
            for (var c = [], e = 1; e < arguments.length; e++)
                c.push(C(a, arguments[e], !0).name);
            return w(a, function(a) {
                if (a._katavorioDrag) {
                    var b = d(a._katavorioDrag.posses, c)
                      , e = [];
                    Array.prototype.push.apply(e, a._katavorioDrag.posses);
                    for (var f = 0; f < b.length; f++)
                        this.removeFromPosse(a, b[f])
                }
            }
            .bind(this)),
            1 == c.length ? c[0] : c
        }
        ,
        this.removeFromPosse = function(a, b) {
            if (arguments.length < 2)
                throw new TypeError("No posse id provided for remove operation");
            for (var d = 1; d < arguments.length; d++)
                b = arguments[d],
                w(a, function(a) {
                    if (a._katavorioDrag && a._katavorioDrag.posses) {
                        var d = a._katavorioDrag;
                        w(b, function(a) {
                            c(B[a].members, d),
                            c(d.posses, a),
                            delete d.posseRoles[a]
                        })
                    }
                })
        }
        ,
        this.removeFromAllPosses = function(a) {
            w(a, function(a) {
                if (a._katavorioDrag && a._katavorioDrag.posses) {
                    var b = a._katavorioDrag;
                    w(b.posses, function(a) {
                        c(B[a].members, b)
                    }),
                    b.posses.length = 0,
                    b.posseRoles = {}
                }
            })
        }
        ,
        this.setPosseState = function(a, b, c) {
            var d = B[b];
            d && w(a, function(a) {
                a._katavorioDrag && a._katavorioDrag.posses && (a._katavorioDrag.posseRoles[d.name] = c)
            })
        }
    }
    ,
    a.Katavorio.version = "0.19.2",
    "undefined" != typeof exports && (exports.Katavorio = a.Katavorio)
}
.call("undefined" != typeof window ? window : this),
function() {
    var a = function(a) {
        return "[object Array]" === Object.prototype.toString.call(a)
    }
      , b = function(a) {
        return "[object Number]" === Object.prototype.toString.call(a)
    }
      , c = function(a) {
        return "string" == typeof a
    }
      , d = function(a) {
        return "boolean" == typeof a
    }
      , e = function(a) {
        return null == a
    }
      , f = function(a) {
        return null != a && "[object Object]" === Object.prototype.toString.call(a)
    }
      , g = function(a) {
        return "[object Date]" === Object.prototype.toString.call(a)
    }
      , h = function(a) {
        return "[object Function]" === Object.prototype.toString.call(a)
    }
      , i = function(a) {
        for (var b in a)
            if (a.hasOwnProperty(b))
                return !1;
        return !0
    }
      , j = this;
    j.jsPlumbUtil = {
        isArray: a,
        isString: c,
        isBoolean: d,
        isNull: e,
        isObject: f,
        isDate: g,
        isFunction: h,
        isEmpty: i,
        isNumber: b,
        clone: function(b) {
            if (c(b))
                return "" + b;
            if (d(b))
                return !!b;
            if (g(b))
                return new Date(b.getTime());
            if (h(b))
                return b;
            if (a(b)) {
                for (var e = [], i = 0; i < b.length; i++)
                    e.push(this.clone(b[i]));
                return e
            }
            if (f(b)) {
                var j = {};
                for (var k in b)
                    j[k] = this.clone(b[k]);
                return j
            }
            return b
        },
        merge: function(b, e, g) {
            var h, i, j = {};
            for (g = g || [],
            i = 0; i < g.length; i++)
                j[g[i]] = !0;
            var k = this.clone(b);
            for (i in e)
                if (null == k[i])
                    k[i] = e[i];
                else if (c(e[i]) || d(e[i]))
                    j[i] ? (h = [],
                    h.push.apply(h, a(k[i]) ? k[i] : [k[i]]),
                    h.push.apply(h, a(e[i]) ? e[i] : [e[i]]),
                    k[i] = h) : k[i] = e[i];
                else if (a(e[i]))
                    h = [],
                    a(k[i]) && h.push.apply(h, k[i]),
                    h.push.apply(h, e[i]),
                    k[i] = h;
                else if (f(e[i])) {
                    f(k[i]) || (k[i] = {});
                    for (var l in e[i])
                        k[i][l] = e[i][l]
                }
            return k
        },
        replace: function(a, b, c) {
            if (null != a) {
                var d = a
                  , e = d;
                return b.replace(/([^\.])+/g, function(a, b, d, f) {
                    var g = a.match(/([^\[0-9]+){1}(\[)([0-9+])/)
                      , h = d + a.length >= f.length
                      , i = function() {
                        return e[g[1]] || function() {
                            return e[g[1]] = [],
                            e[g[1]]
                        }()
                    };
                    if (h)
                        g ? i()[g[3]] = c : e[a] = c;
                    else if (g) {
                        var j = i();
                        e = j[g[3]] || function() {
                            return j[g[3]] = {},
                            j[g[3]]
                        }()
                    } else
                        e = e[a] || function() {
                            return e[a] = {},
                            e[a]
                        }()
                }),
                a
            }
        },
        functionChain: function(a, b, c) {
            for (var d = 0; d < c.length; d++) {
                var e = c[d][0][c[d][1]].apply(c[d][0], c[d][2]);
                if (e === b)
                    return e
            }
            return a
        },
        populate: function(b, d, e) {
            var g = function(a) {
                var b = a.match(/(\${.*?})/g);
                if (null != b)
                    for (var c = 0; c < b.length; c++) {
                        var e = d[b[c].substring(2, b[c].length - 1)] || "";
                        null != e && (a = a.replace(b[c], e))
                    }
                return a
            }
              , i = function(b) {
                if (null != b) {
                    if (c(b))
                        return g(b);
                    if (!h(b) || null != e && 0 !== (b.name || "").indexOf(e)) {
                        if (a(b)) {
                            for (var j = [], k = 0; k < b.length; k++)
                                j.push(i(b[k]));
                            return j
                        }
                        if (f(b)) {
                            var l = {};
                            for (var m in b)
                                l[m] = i(b[m]);
                            return l
                        }
                        return b
                    }
                    return b(d)
                }
            };
            return i(b)
        },
        findWithFunction: function(a, b) {
            if (a)
                for (var c = 0; c < a.length; c++)
                    if (b(a[c]))
                        return c;
            return -1
        },
        removeWithFunction: function(a, b) {
            var c = j.jsPlumbUtil.findWithFunction(a, b);
            return c > -1 && a.splice(c, 1),
            c !== -1
        },
        remove: function(a, b) {
            var c = a.indexOf(b);
            return c > -1 && a.splice(c, 1),
            c !== -1
        },
        addWithFunction: function(a, b, c) {
            j.jsPlumbUtil.findWithFunction(a, c) === -1 && a.push(b)
        },
        addToList: function(a, b, c, d) {
            var e = a[b];
            return null == e && (e = [],
            a[b] = e),
            e[d ? "unshift" : "push"](c),
            e
        },
        suggest: function(a, b, c) {
            return a.indexOf(b) === -1 && (c ? a.unshift(b) : a.push(b),
            !0)
        },
        extend: function(b, c, d) {
            var e;
            for (c = a(c) ? c : [c],
            e = 0; e < c.length; e++)
                for (var f in c[e].prototype)
                    c[e].prototype.hasOwnProperty(f) && (b.prototype[f] = c[e].prototype[f]);
            var g = function(a, b) {
                return function() {
                    for (e = 0; e < c.length; e++)
                        c[e].prototype[a] && c[e].prototype[a].apply(this, arguments);
                    return b.apply(this, arguments)
                }
            }
              , h = function(a) {
                for (var c in a)
                    b.prototype[c] = g(c, a[c])
            };
            if (arguments.length > 2)
                for (e = 2; e < arguments.length; e++)
                    h(arguments[e]);
            return b
        },
        uuid: function() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(a) {
                var b = 16 * Math.random() | 0
                  , c = "x" === a ? b : 3 & b | 8;
                return c.toString(16)
            })
        },
        logEnabled: !0,
        log: function() {
            if (j.jsPlumbUtil.logEnabled && "undefined" != typeof console)
                try {
                    var a = arguments[arguments.length - 1];
                    console.log(a)
                } catch (a) {}
        },
        wrap: function(a, b, c) {
            return a = a || function() {}
            ,
            b = b || function() {}
            ,
            function() {
                var d = null;
                try {
                    d = b.apply(this, arguments)
                } catch (a) {
                    j.jsPlumbUtil.log("jsPlumb function failed : " + a)
                }
                if (null == c || d !== c)
                    try {
                        d = a.apply(this, arguments)
                    } catch (a) {
                        j.jsPlumbUtil.log("wrapped function failed : " + a)
                    }
                return d
            }
        }
    },
    j.jsPlumbUtil.EventGenerator = function() {
        var a = {}
          , b = !1
          , c = {
            ready: !0
        };
        this.bind = function(b, c, d) {
            var e = function(b) {
                j.jsPlumbUtil.addToList(a, b, c, d),
                c.__jsPlumb = c.__jsPlumb || {},
                c.__jsPlumb[j.jsPlumbUtil.uuid()] = b
            };
            if ("string" == typeof b)
                e(b);
            else if (null != b.length)
                for (var f = 0; f < b.length; f++)
                    e(b[f]);
            return this
        }
        ,
        this.fire = function(d, e, f) {
            if (!b && a[d]) {
                var g = a[d].length
                  , h = 0
                  , i = !1
                  , k = null;
                if (!this.shouldFireEvent || this.shouldFireEvent(d, e, f))
                    for (; !i && h < g && k !== !1; ) {
                        if (c[d])
                            a[d][h].apply(this, [e, f]);
                        else
                            try {
                                k = a[d][h].apply(this, [e, f])
                            } catch (a) {
                                j.jsPlumbUtil.log("jsPlumb: fire failed for event " + d + " : " + a)
                            }
                        h++,
                        null != a && null != a[d] || (i = !0)
                    }
            }
            return this
        }
        ,
        this.unbind = function(b, c) {
            if (0 === arguments.length)
                a = {};
            else if (1 === arguments.length) {
                if ("string" == typeof b)
                    delete a[b];
                else if (b.__jsPlumb) {
                    var d;
                    for (var e in b.__jsPlumb)
                        d = b.__jsPlumb[e],
                        j.jsPlumbUtil.remove(a[d] || [], b)
                }
            } else
                2 === arguments.length && j.jsPlumbUtil.remove(a[b] || [], c);
            return this
        }
        ,
        this.getListener = function(b) {
            return a[b]
        }
        ,
        this.setSuspendEvents = function(a) {
            b = a
        }
        ,
        this.isSuspendEvents = function() {
            return b
        }
        ,
        this.silently = function(a) {
            this.setSuspendEvents(!0);
            try {
                a()
            } catch (a) {
                j.jsPlumbUtil.log("Cannot execute silent function " + a)
            }
            this.setSuspendEvents(!1)
        }
        ,
        this.cleanupListeners = function() {
            for (var b in a)
                a[b] = null
        }
    }
    ,
    j.jsPlumbUtil.EventGenerator.prototype = {
        cleanup: function() {
            this.cleanupListeners()
        }
    },
    "undefined" != typeof exports && (exports.jsPlumbUtil = j.jsPlumbUtil)
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this;
    a.jsPlumbUtil.matchesSelector = function(a, b, c) {
        c = c || a.parentNode;
        for (var d = c.querySelectorAll(b), e = 0; e < d.length; e++)
            if (d[e] === a)
                return !0;
        return !1
    }
    ,
    a.jsPlumbUtil.consume = function(a, b) {
        a.stopPropagation ? a.stopPropagation() : a.returnValue = !1,
        !b && a.preventDefault && a.preventDefault()
    }
    ,
    a.jsPlumbUtil.sizeElement = function(a, b, c, d, e) {
        a && (a.style.height = e + "px",
        a.height = e,
        a.style.width = d + "px",
        a.width = d,
        a.style.left = b + "px",
        a.style.top = c + "px")
    }
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a, b = this, c = [], d = b.jsPlumbUtil, e = function() {
        return "" + (new Date).getTime()
    }, f = function(a) {
        if (a._jsPlumb.paintStyle && a._jsPlumb.hoverPaintStyle) {
            var b = {};
            r.extend(b, a._jsPlumb.paintStyle),
            r.extend(b, a._jsPlumb.hoverPaintStyle),
            delete a._jsPlumb.hoverPaintStyle,
            b.gradient && a._jsPlumb.paintStyle.fill && delete b.gradient,
            a._jsPlumb.hoverPaintStyle = b
        }
    }, g = ["tap", "dbltap", "click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "contextmenu"], h = function(a, b, c, d) {
        var e = a.getAttachedElements();
        if (e)
            for (var f = 0, g = e.length; f < g; f++)
                d && d === e[f] || e[f].setHover(b, !0, c)
    }, i = function(a) {
        return null == a ? null : a.split(" ")
    }, j = function(a, b, c) {
        for (var d in b)
            a[d] = c
    }, k = function(a, b) {
        b = d.isArray(b) || null != b.length && !d.isString(b) ? b : [b];
        for (var c = 0; c < b.length; c++)
            try {
                a.apply(b[c], [b[c]])
            } catch (a) {
                d.log(".each iteration failed : " + a)
            }
    }, l = function(a, b, c) {
        if (a.getDefaultType) {
            var e = a.getTypeDescriptor()
              , f = {}
              , g = a.getDefaultType()
              , h = d.merge({}, g);
            j(f, g, "__default");
            for (var i = 0, k = a._jsPlumb.types.length; i < k; i++) {
                var l = a._jsPlumb.types[i];
                if ("__default" !== l) {
                    var m = a._jsPlumb.instance.getType(l, e);
                    null != m && (h = d.merge(h, m, ["cssClass"]),
                    j(f, m, l))
                }
            }
            b && (h = d.populate(h, b, "_")),
            a.applyType(h, c, f),
            c || a.repaint()
        }
    }, m = b.jsPlumbUIComponent = function(a) {
        d.EventGenerator.apply(this, arguments);
        var b = this
          , c = arguments
          , e = b.idPrefix
          , f = e + (new Date).getTime();
        this._jsPlumb = {
            instance: a._jsPlumb,
            parameters: a.parameters || {},
            paintStyle: null,
            hoverPaintStyle: null,
            paintStyleInUse: null,
            hover: !1,
            beforeDetach: a.beforeDetach,
            beforeDrop: a.beforeDrop,
            overlayPlacements: [],
            hoverClass: a.hoverClass || a._jsPlumb.Defaults.HoverClass,
            types: [],
            typeCache: {}
        },
        this.cacheTypeItem = function(a, b, c) {
            this._jsPlumb.typeCache[c] = this._jsPlumb.typeCache[c] || {},
            this._jsPlumb.typeCache[c][a] = b
        }
        ,
        this.getCachedTypeItem = function(a, b) {
            return this._jsPlumb.typeCache[b] ? this._jsPlumb.typeCache[b][a] : null
        }
        ,
        this.getId = function() {
            return f
        }
        ;
        var g = a.overlays || []
          , h = {};
        if (this.defaultOverlayKeys) {
            for (var i = 0; i < this.defaultOverlayKeys.length; i++)
                Array.prototype.push.apply(g, this._jsPlumb.instance.Defaults[this.defaultOverlayKeys[i]] || []);
            for (i = 0; i < g.length; i++) {
                var j = r.convertToFullOverlaySpec(g[i]);
                h[j[1].id] = j
            }
        }
        var k = {
            overlays: h,
            parameters: a.parameters || {},
            scope: a.scope || this._jsPlumb.instance.getDefaultScope()
        };
        if (this.getDefaultType = function() {
            return k
        }
        ,
        this.appendToDefaultType = function(a) {
            for (var b in a)
                k[b] = a[b]
        }
        ,
        a.events)
            for (var l in a.events)
                b.bind(l, a.events[l]);
        this.clone = function() {
            var a = Object.create(this.constructor.prototype);
            return this.constructor.apply(a, c),
            a
        }
        .bind(this),
        this.isDetachAllowed = function(a) {
            var b = !0;
            if (this._jsPlumb.beforeDetach)
                try {
                    b = this._jsPlumb.beforeDetach(a)
                } catch (a) {
                    d.log("jsPlumb: beforeDetach callback failed", a)
                }
            return b
        }
        ,
        this.isDropAllowed = function(a, b, c, e, f, g, h) {
            var i = this._jsPlumb.instance.checkCondition("beforeDrop", {
                sourceId: a,
                targetId: b,
                scope: c,
                connection: e,
                dropEndpoint: f,
                source: g,
                target: h
            });
            if (this._jsPlumb.beforeDrop)
                try {
                    i = this._jsPlumb.beforeDrop({
                        sourceId: a,
                        targetId: b,
                        scope: c,
                        connection: e,
                        dropEndpoint: f,
                        source: g,
                        target: h
                    })
                } catch (a) {
                    d.log("jsPlumb: beforeDrop callback failed", a)
                }
            return i
        }
        ;
        var m = [];
        this.setListenerComponent = function(a) {
            for (var b = 0; b < m.length; b++)
                m[b][3] = a
        }
    }
    , n = function(a, b) {
        var c = a._jsPlumb.types[b]
          , d = a._jsPlumb.instance.getType(c, a.getTypeDescriptor());
        null != d && d.cssClass && a.canvas && a._jsPlumb.instance.removeClass(a.canvas, d.cssClass)
    };
    d.extend(b.jsPlumbUIComponent, d.EventGenerator, {
        getParameter: function(a) {
            return this._jsPlumb.parameters[a]
        },
        setParameter: function(a, b) {
            this._jsPlumb.parameters[a] = b
        },
        getParameters: function() {
            return this._jsPlumb.parameters
        },
        setParameters: function(a) {
            this._jsPlumb.parameters = a
        },
        getClass: function() {
            return r.getClass(this.canvas)
        },
        hasClass: function(a) {
            return r.hasClass(this.canvas, a)
        },
        addClass: function(a) {
            r.addClass(this.canvas, a)
        },
        removeClass: function(a) {
            r.removeClass(this.canvas, a)
        },
        updateClasses: function(a, b) {
            r.updateClasses(this.canvas, a, b)
        },
        setType: function(a, b, c) {
            this.clearTypes(),
            this._jsPlumb.types = i(a) || [],
            l(this, b, c)
        },
        getType: function() {
            return this._jsPlumb.types
        },
        reapplyTypes: function(a, b) {
            l(this, a, b)
        },
        hasType: function(a) {
            return this._jsPlumb.types.indexOf(a) !== -1
        },
        addType: function(a, b, c) {
            var d = i(a)
              , e = !1;
            if (null != d) {
                for (var f = 0, g = d.length; f < g; f++)
                    this.hasType(d[f]) || (this._jsPlumb.types.push(d[f]),
                    e = !0);
                e && l(this, b, c)
            }
        },
        removeType: function(a, b, c) {
            var d = i(a)
              , e = !1
              , f = function(a) {
                var b = this._jsPlumb.types.indexOf(a);
                return b !== -1 && (n(this, b),
                this._jsPlumb.types.splice(b, 1),
                !0)
            }
            .bind(this);
            if (null != d) {
                for (var g = 0, h = d.length; g < h; g++)
                    e = f(d[g]) || e;
                e && l(this, b, c)
            }
        },
        clearTypes: function(a, b) {
            for (var c = this._jsPlumb.types.length, d = 0; d < c; d++)
                n(this, 0),
                this._jsPlumb.types.splice(0, 1);
            l(this, a, b)
        },
        toggleType: function(a, b, c) {
            var d = i(a);
            if (null != d) {
                for (var e = 0, f = d.length; e < f; e++) {
                    var g = this._jsPlumb.types.indexOf(d[e]);
                    g !== -1 ? (n(this, g),
                    this._jsPlumb.types.splice(g, 1)) : this._jsPlumb.types.push(d[e])
                }
                l(this, b, c)
            }
        },
        applyType: function(a, b) {
            if (this.setPaintStyle(a.paintStyle, b),
            this.setHoverPaintStyle(a.hoverPaintStyle, b),
            a.parameters)
                for (var c in a.parameters)
                    this.setParameter(c, a.parameters[c]);
            this._jsPlumb.paintStyleInUse = this.getPaintStyle()
        },
        setPaintStyle: function(a, b) {
            this._jsPlumb.paintStyle = a,
            this._jsPlumb.paintStyleInUse = this._jsPlumb.paintStyle,
            f(this),
            b || this.repaint()
        },
        getPaintStyle: function() {
            return this._jsPlumb.paintStyle
        },
        setHoverPaintStyle: function(a, b) {
            this._jsPlumb.hoverPaintStyle = a,
            f(this),
            b || this.repaint()
        },
        getHoverPaintStyle: function() {
            return this._jsPlumb.hoverPaintStyle
        },
        destroy: function(a) {
            (a || null == this.typeId) && (this.cleanupListeners(),
            this.clone = null,
            this._jsPlumb = null)
        },
        isHover: function() {
            return this._jsPlumb.hover
        },
        setHover: function(a, b, c) {
            if (this._jsPlumb && !this._jsPlumb.instance.currentlyDragging && !this._jsPlumb.instance.isHoverSuspended()) {
                this._jsPlumb.hover = a;
                var d = a ? "addClass" : "removeClass";
                null != this.canvas && (null != this._jsPlumb.instance.hoverClass && this._jsPlumb.instance[d](this.canvas, this._jsPlumb.instance.hoverClass),
                null != this._jsPlumb.hoverClass && this._jsPlumb.instance[d](this.canvas, this._jsPlumb.hoverClass)),
                null != this._jsPlumb.hoverPaintStyle && (this._jsPlumb.paintStyleInUse = a ? this._jsPlumb.hoverPaintStyle : this._jsPlumb.paintStyle,
                this._jsPlumb.instance.isSuspendDrawing() || (c = c || e(),
                this.repaint({
                    timestamp: c,
                    recalc: !1
                }))),
                this.getAttachedElements && !b && h(this, a, e(), this)
            }
        }
    });
    var o = 0
      , p = function() {
        var a = o + 1;
        return o++,
        a
    }
      , q = b.jsPlumbInstance = function(f) {
        this.version = "2.4.3",
        f && r.extend(this.Defaults, f),
        this.logEnabled = this.Defaults.LogEnabled,
        this._connectionTypes = {},
        this._endpointTypes = {},
        d.EventGenerator.apply(this);
        var h = this
          , i = p()
          , j = h.bind
          , l = {}
          , n = 1
          , o = function(a) {
            if (null == a)
                return null;
            if (3 === a.nodeType || 8 === a.nodeType)
                return {
                    el: a,
                    text: !0
                };
            var b = h.getElement(a);
            return {
                el: b,
                id: d.isString(a) && null == b ? a : Z(b)
            }
        };
        this.getInstanceIndex = function() {
            return i
        }
        ,
        this.setZoom = function(a, b) {
            return n = a,
            h.fire("zoom", n),
            b && h.repaintEverything(),
            !0
        }
        ,
        this.getZoom = function() {
            return n
        }
        ;
        for (var q in this.Defaults)
            l[q] = this.Defaults[q];
        var s, t = [];
        this.unbindContainer = function() {
            if (null != s && t.length > 0)
                for (var a = 0; a < t.length; a++)
                    h.off(s, t[a][0], t[a][1])
        }
        ,
        this.setContainer = function(a) {
            this.unbindContainer(),
            a = this.getElement(a),
            this.select().each(function(b) {
                b.moveParent(a)
            }),
            this.selectEndpoints().each(function(b) {
                b.moveParent(a)
            });
            var b = s;
            s = a,
            t.length = 0;
            for (var c = {
                endpointclick: "endpointClick",
                endpointdblclick: "endpointDblClick"
            }, d = function(a, b, d) {
                var e = b.srcElement || b.target
                  , f = (e && e.parentNode ? e.parentNode._jsPlumb : null) || (e ? e._jsPlumb : null) || (e && e.parentNode && e.parentNode.parentNode ? e.parentNode.parentNode._jsPlumb : null);
                if (f) {
                    f.fire(a, f, b);
                    var g = d ? c[d + a] || a : a;
                    h.fire(g, f.component || f, b)
                }
            }, e = function(a, b, c) {
                t.push([a, c]),
                h.on(s, a, b, c)
            }, f = function(a) {
                e(a, ".jtk-connector", function(b) {
                    d(a, b)
                }),
                e(a, ".jtk-endpoint", function(b) {
                    d(a, b, "endpoint")
                }),
                e(a, ".jtk-overlay", function(b) {
                    d(a, b)
                })
            }, i = 0; i < g.length; i++)
                f(g[i]);
            for (var j in z) {
                var k = z[j].el;
                k.parentNode === b && (b.removeChild(k),
                s.appendChild(k))
            }
        }
        ,
        this.getContainer = function() {
            return s
        }
        ,
        this.bind = function(a, b) {
            "ready" === a && v ? b() : j.apply(h, [a, b])
        }
        ,
        h.importDefaults = function(a) {
            for (var b in a)
                h.Defaults[b] = a[b];
            return a.Container && h.setContainer(a.Container),
            h
        }
        ,
        h.restoreDefaults = function() {
            return h.Defaults = r.extend({}, l),
            h
        }
        ;
        var u = null
          , v = !1
          , w = []
          , x = {}
          , y = {}
          , z = {}
          , A = {}
          , B = {}
          , C = {}
          , D = !1
          , E = []
          , F = !1
          , G = null
          , H = this.Defaults.Scope
          , I = 1
          , J = function() {
            return "" + I++
        }
          , K = function(a, b) {
            s ? s.appendChild(a) : b ? this.getElement(b).appendChild(a) : this.appendToRoot(a)
        }
        .bind(this)
          , L = function(a, b, c, d) {
            if (!F) {
                var f, g = Z(a), i = h.getDragManager();
                i && (f = i.getElementsForDraggable(g)),
                null == c && (c = e());
                var j = ua({
                    elId: g,
                    offset: b,
                    recalc: !1,
                    timestamp: c
                });
                if (f && j && j.o)
                    for (var k in f)
                        ua({
                            elId: f[k].id,
                            offset: {
                                left: j.o.left + f[k].offset.left,
                                top: j.o.top + f[k].offset.top
                            },
                            recalc: !1,
                            timestamp: c
                        });
                if (h.anchorManager.redraw(g, b, c, null, d),
                f)
                    for (var l in f)
                        h.anchorManager.redraw(f[l].id, b, c, f[l].offset, d, !0)
            }
        }
          , M = function(a) {
            return y[a]
        }
          , N = function(a, b, c, e, f) {
            if (!r.headless) {
                var g = null != b && b;
                if (g && r.isDragSupported(a, h)) {
                    var i = c || h.Defaults.DragOptions;
                    if (i = r.extend({}, i),
                    r.isAlreadyDraggable(a, h))
                        c.force && h.initDraggable(a, i);
                    else {
                        var j = r.dragEvents.drag
                          , k = r.dragEvents.stop
                          , l = r.dragEvents.start
                          , m = !1;
                        ta(e, a),
                        i[l] = d.wrap(i[l], function() {
                            if (h.setHoverSuspended(!0),
                            h.select({
                                source: a
                            }).addClass(h.elementDraggingClass + " " + h.sourceElementDraggingClass, !0),
                            h.select({
                                target: a
                            }).addClass(h.elementDraggingClass + " " + h.targetElementDraggingClass, !0),
                            h.setConnectionBeingDragged(!0),
                            i.canDrag)
                                return c.canDrag()
                        }, !1),
                        i[j] = d.wrap(i[j], function() {
                            var b = h.getUIPosition(arguments, h.getZoom());
                            null != b && (L(a, b, null, !0),
                            m && h.addClass(a, "jtk-dragged"),
                            m = !0)
                        }),
                        i[k] = d.wrap(i[k], function() {
                            for (var a, b = arguments[0].selection, c = function(b) {
                                null != b[1] && (a = h.getUIPosition([{
                                    el: b[2].el,
                                    pos: [b[1].left, b[1].top]
                                }]),
                                L(b[2].el, a)),
                                h.removeClass(b[0], "jtk-dragged"),
                                h.select({
                                    source: b[2].el
                                }).removeClass(h.elementDraggingClass + " " + h.sourceElementDraggingClass, !0),
                                h.select({
                                    target: b[2].el
                                }).removeClass(h.elementDraggingClass + " " + h.targetElementDraggingClass, !0),
                                h.getDragManager().dragEnded(b[2].el)
                            }, d = 0; d < b.length; d++)
                                c(b[d]);
                            m = !1,
                            h.setHoverSuspended(!1),
                            h.setConnectionBeingDragged(!1)
                        });
                        var n = Z(a);
                        C[n] = !0;
                        var o = C[n];
                        i.disabled = null != o && !o,
                        h.initDraggable(a, i),
                        h.getDragManager().register(a),
                        f && h.fire("elementDraggable", {
                            el: a,
                            options: i
                        })
                    }
                }
            }
        }
          , O = function(a, b) {
            for (var c = a.scope.split(/\s/), d = b.scope.split(/\s/), e = 0; e < c.length; e++)
                for (var f = 0; f < d.length; f++)
                    if (d[f] === c[e])
                        return !0;
            return !1
        }
          , P = function(a, b) {
            var c = r.extend({}, a);
            if (b && r.extend(c, b),
            c.source && (c.source.endpoint ? c.sourceEndpoint = c.source : c.source = h.getElement(c.source)),
            c.target && (c.target.endpoint ? c.targetEndpoint = c.target : c.target = h.getElement(c.target)),
            a.uuids && (c.sourceEndpoint = M(a.uuids[0]),
            c.targetEndpoint = M(a.uuids[1])),
            c.sourceEndpoint && c.sourceEndpoint.isFull())
                return void d.log(h, "could not add connection; source endpoint is full");
            if (c.targetEndpoint && c.targetEndpoint.isFull())
                return void d.log(h, "could not add connection; target endpoint is full");
            if (!c.type && c.sourceEndpoint && (c.type = c.sourceEndpoint.connectionType),
            c.sourceEndpoint && c.sourceEndpoint.connectorOverlays) {
                c.overlays = c.overlays || [];
                for (var e = 0, f = c.sourceEndpoint.connectorOverlays.length; e < f; e++)
                    c.overlays.push(c.sourceEndpoint.connectorOverlays[e])
            }
            c.sourceEndpoint && c.sourceEndpoint.scope && (c.scope = c.sourceEndpoint.scope),
            !c["pointer-events"] && c.sourceEndpoint && c.sourceEndpoint.connectorPointerEvents && (c["pointer-events"] = c.sourceEndpoint.connectorPointerEvents);
            var g = function(a, b) {
                var c = r.extend({}, a);
                for (var d in b)
                    b[d] && (c[d] = b[d]);
                return c
            }
              , i = function(a, b, d) {
                return h.addEndpoint(a, g(b, {
                    anchor: c.anchors ? c.anchors[d] : c.anchor,
                    endpoint: c.endpoints ? c.endpoints[d] : c.endpoint,
                    paintStyle: c.endpointStyles ? c.endpointStyles[d] : c.endpointStyle,
                    hoverPaintStyle: c.endpointHoverStyles ? c.endpointHoverStyles[d] : c.endpointHoverStyle
                }))
            }
              , j = function(a, b, d, e) {
                if (c[a] && !c[a].endpoint && !c[a + "Endpoint"] && !c.newConnection) {
                    var f = Z(c[a])
                      , g = d[f];
                    if (g = g ? g[e] : null) {
                        if (!g.enabled)
                            return !1;
                        var h = null != g.endpoint && g.endpoint._jsPlumb ? g.endpoint : i(c[a], g.def, b);
                        if (h.isFull())
                            return !1;
                        c[a + "Endpoint"] = h,
                        !c.scope && g.def.scope && (c.scope = g.def.scope),
                        h.setDeleteOnEmpty(!0),
                        g.uniqueEndpoint && (g.endpoint ? h.finalEndpoint = g.endpoint : (g.endpoint = h,
                        h.setDeleteOnEmpty(!1)))
                    }
                }
            };
            return j("source", 0, this.sourceEndpointDefinitions, c.type || "default") !== !1 && j("target", 1, this.targetEndpointDefinitions, c.type || "default") !== !1 ? (c.sourceEndpoint && c.targetEndpoint && (O(c.sourceEndpoint, c.targetEndpoint) || (c = null)),
            c) : void 0
        }
        .bind(h)
          , Q = function(a) {
            var b = h.Defaults.ConnectionType || h.getDefaultConnectionType();
            a._jsPlumb = h,
            a.newConnection = Q,
            a.newEndpoint = S,
            a.endpointsByUUID = y,
            a.endpointsByElement = x,
            a.finaliseConnection = R,
            a.id = "con_" + J();
            var c = new b(a);
            return c.isDetachable() && (c.endpoints[0].initDraggable("_jsPlumbSource"),
            c.endpoints[1].initDraggable("_jsPlumbTarget")),
            c
        }
          , R = h.finaliseConnection = function(a, b, c, d) {
            if (b = b || {},
            a.suspendedEndpoint || w.push(a),
            a.pending = null,
            a.endpoints[0].isTemporarySource = !1,
            d !== !1 && h.anchorManager.newConnection(a),
            L(a.source),
            !b.doNotFireConnectionEvent && b.fireEvent !== !1) {
                var e = {
                    connection: a,
                    source: a.source,
                    target: a.target,
                    sourceId: a.sourceId,
                    targetId: a.targetId,
                    sourceEndpoint: a.endpoints[0],
                    targetEndpoint: a.endpoints[1]
                };
                h.fire("connection", e, c)
            }
        }
          , S = function(a, b) {
            var c = h.Defaults.EndpointType || r.Endpoint
              , d = r.extend({}, a);
            d._jsPlumb = h,
            d.newConnection = Q,
            d.newEndpoint = S,
            d.endpointsByUUID = y,
            d.endpointsByElement = x,
            d.fireDetachEvent = aa,
            d.elementId = b || Z(d.source);
            var e = new c(d);
            return e.id = "ep_" + J(),
            ta(d.elementId, d.source),
            r.headless || h.getDragManager().endpointAdded(d.source, b),
            e
        }
          , T = function(a, b, c) {
            var d = x[a];
            if (d && d.length)
                for (var e = 0, f = d.length; e < f; e++) {
                    for (var g = 0, h = d[e].connections.length; g < h; g++) {
                        var i = b(d[e].connections[g]);
                        if (i)
                            return
                    }
                    c && c(d[e])
                }
        }
          , U = function(a, b) {
            return r.each(a, function(a) {
                h.isDragSupported(a) && (C[h.getAttribute(a, "id")] = b,
                h.setElementDraggable(a, b))
            })
        }
          , V = function(a, b, c) {
            b = "block" === b;
            var d = null;
            c && (d = function(a) {
                a.setVisible(b, !0, !0)
            }
            );
            var e = o(a);
            T(e.id, function(a) {
                if (b && c) {
                    var d = a.sourceId === e.id ? 1 : 0;
                    a.endpoints[d].isVisible() && a.setVisible(!0)
                } else
                    a.setVisible(b)
            }, d)
        }
          , W = function(a) {
            var b;
            return r.each(a, function(a) {
                var c = h.getAttribute(a, "id");
                return b = null != C[c] && C[c],
                b = !b,
                C[c] = b,
                h.setDraggable(a, b),
                b
            }
            .bind(this)),
            b
        }
          , X = function(a, b) {
            var c = null;
            b && (c = function(a) {
                var b = a.isVisible();
                a.setVisible(!b)
            }
            ),
            T(a, function(a) {
                var b = a.isVisible();
                a.setVisible(!b)
            }, c)
        }
          , Y = function(a) {
            var b = A[a];
            return b ? {
                o: b,
                s: E[a]
            } : ua({
                elId: a
            })
        }
          , Z = function(a, b, c) {
            if (d.isString(a))
                return a;
            if (null == a)
                return null;
            var e = h.getAttribute(a, "id");
            return e && "undefined" !== e || (2 === arguments.length && void 0 !== arguments[1] ? e = b : (1 === arguments.length || 3 === arguments.length && !arguments[2]) && (e = "jsPlumb_" + i + "_" + J()),
            c || h.setAttribute(a, "id", e)),
            e
        };
        this.setConnectionBeingDragged = function(a) {
            D = a
        }
        ,
        this.isConnectionBeingDragged = function() {
            return D
        }
        ,
        this.getManagedElements = function() {
            return z
        }
        ,
        this.connectorClass = "jtk-connector",
        this.connectorOutlineClass = "jtk-connector-outline",
        this.editableConnectorClass = "jtk-connector-editable",
        this.connectedClass = "jtk-connected",
        this.hoverClass = "jtk-hover",
        this.endpointClass = "jtk-endpoint",
        this.endpointConnectedClass = "jtk-endpoint-connected",
        this.endpointFullClass = "jtk-endpoint-full",
        this.endpointDropAllowedClass = "jtk-endpoint-drop-allowed",
        this.endpointDropForbiddenClass = "jtk-endpoint-drop-forbidden",
        this.overlayClass = "jtk-overlay",
        this.draggingClass = "jtk-dragging",
        this.elementDraggingClass = "jtk-element-dragging",
        this.sourceElementDraggingClass = "jtk-source-element-dragging",
        this.targetElementDraggingClass = "jtk-target-element-dragging",
        this.endpointAnchorClassPrefix = "jtk-endpoint-anchor",
        this.hoverSourceClass = "jtk-source-hover",
        this.hoverTargetClass = "jtk-target-hover",
        this.dragSelectClass = "jtk-drag-select",
        this.Anchors = {},
        this.Connectors = {
            svg: {}
        },
        this.Endpoints = {
            svg: {}
        },
        this.Overlays = {
            svg: {}
        },
        this.ConnectorRenderers = {},
        this.SVG = "svg",
        this.addEndpoint = function(a, b, c) {
            c = c || {};
            var e = r.extend({}, c);
            r.extend(e, b),
            e.endpoint = e.endpoint || h.Defaults.Endpoint,
            e.paintStyle = e.paintStyle || h.Defaults.EndpointStyle;
            for (var f = [], g = d.isArray(a) || null != a.length && !d.isString(a) ? a : [a], i = 0, j = g.length; i < j; i++) {
                e.source = h.getElement(g[i]),
                ra(e.source);
                var k = Z(e.source)
                  , l = S(e, k)
                  , m = ta(k, e.source).info.o;
                d.addToList(x, k, l),
                F || l.paint({
                    anchorLoc: l.anchor.compute({
                        xy: [m.left, m.top],
                        wh: E[k],
                        element: l,
                        timestamp: G
                    }),
                    timestamp: G
                }),
                f.push(l)
            }
            return 1 === f.length ? f[0] : f
        }
        ,
        this.addEndpoints = function(a, b, c) {
            for (var e = [], f = 0, g = b.length; f < g; f++) {
                var i = h.addEndpoint(a, b[f], c);
                d.isArray(i) ? Array.prototype.push.apply(e, i) : e.push(i)
            }
            return e
        }
        ,
        this.animate = function(a, b, c) {
            if (!this.animationSupported)
                return !1;
            c = c || {};
            var e = h.getElement(a)
              , f = Z(e)
              , g = r.animEvents.step
              , i = r.animEvents.complete;
            c[g] = d.wrap(c[g], function() {
                h.revalidate(f)
            }),
            c[i] = d.wrap(c[i], function() {
                h.revalidate(f)
            }),
            h.doAnimate(e, b, c)
        }
        ,
        this.checkCondition = function(a, b) {
            var c = h.getListener(a)
              , e = !0;
            if (c && c.length > 0) {
                var f = Array.prototype.slice.call(arguments, 1);
                try {
                    for (var g = 0, i = c.length; g < i; g++)
                        e = e && c[g].apply(c[g], f)
                } catch (b) {
                    d.log(h, "cannot check condition [" + a + "]" + b)
                }
            }
            return e
        }
        ,
        this.connect = function(a, b) {
            var c, e = P(a, b);
            if (e) {
                if (null == e.source && null == e.sourceEndpoint)
                    return void d.log("Cannot establish connection - source does not exist");
                if (null == e.target && null == e.targetEndpoint)
                    return void d.log("Cannot establish connection - target does not exist");
                ra(e.source),
                c = Q(e),
                R(c, e)
            }
            return c
        }
        ;
        var $ = [{
            el: "source",
            elId: "sourceId",
            epDefs: "sourceEndpointDefinitions"
        }, {
            el: "target",
            elId: "targetId",
            epDefs: "targetEndpointDefinitions"
        }]
          , _ = function(a, b, c, d) {
            var e, f, g, h = $[c], i = a[h.elId], j = (a[h.el],
            a.endpoints[c]), k = {
                index: c,
                originalSourceId: 0 === c ? i : a.sourceId,
                newSourceId: a.sourceId,
                originalTargetId: 1 === c ? i : a.targetId,
                newTargetId: a.targetId,
                connection: a
            };
            if (b.constructor === r.Endpoint)
                e = b,
                e.addConnection(a),
                b = e.element;
            else if (f = Z(b),
            g = this[h.epDefs][f],
            f === a[h.elId])
                e = null;
            else if (g)
                for (var l in g) {
                    if (!g[l].enabled)
                        return;
                    e = null != g[l].endpoint && g[l].endpoint._jsPlumb ? g[l].endpoint : this.addEndpoint(b, g[l].def),
                    g[l].uniqueEndpoint && (g[l].endpoint = e),
                    e.addConnection(a)
                }
            else
                e = a.makeEndpoint(0 === c, b, f);
            return null != e && (j.detachFromConnection(a),
            a.endpoints[c] = e,
            a[h.el] = e.element,
            a[h.elId] = e.elementId,
            k[0 === c ? "newSourceId" : "newTargetId"] = e.elementId,
            ba(k),
            d || a.repaint()),
            k.element = b,
            k
        }
        .bind(this);
        this.setSource = function(a, b, c) {
            var d = _(a, b, 0, c);
            this.anchorManager.sourceChanged(d.originalSourceId, d.newSourceId, a, d.el)
        }
        ,
        this.setTarget = function(a, b, c) {
            var d = _(a, b, 1, c);
            this.anchorManager.updateOtherEndpoint(d.originalSourceId, d.originalTargetId, d.newTargetId, a)
        }
        ,
        this.deleteEndpoint = function(a, b, c) {
            var d = "string" == typeof a ? y[a] : a;
            return d && h.deleteObject({
                endpoint: d,
                dontUpdateHover: b,
                deleteAttachedObjects: c
            }),
            h
        }
        ,
        this.deleteEveryEndpoint = function() {
            var a = h.setSuspendDrawing(!0);
            for (var b in x) {
                var c = x[b];
                if (c && c.length)
                    for (var d = 0, e = c.length; d < e; d++)
                        h.deleteEndpoint(c[d], !0)
            }
            x = {},
            z = {},
            y = {},
            A = {},
            B = {},
            h.anchorManager.reset();
            var f = h.getDragManager();
            return f && f.reset(),
            a || h.setSuspendDrawing(!1),
            h
        }
        ;
        var aa = function(a, b, c) {
            var d = h.Defaults.ConnectionType || h.getDefaultConnectionType()
              , e = a.constructor === d
              , f = e ? {
                connection: a,
                source: a.source,
                target: a.target,
                sourceId: a.sourceId,
                targetId: a.targetId,
                sourceEndpoint: a.endpoints[0],
                targetEndpoint: a.endpoints[1]
            } : a;
            b && h.fire("connectionDetached", f, c),
            h.fire("internal.connectionDetached", f, c),
            h.anchorManager.connectionDetached(f)
        }
          , ba = h.fireMoveEvent = function(a, b) {
            h.fire("connectionMoved", a, b)
        }
        ;
        this.unregisterEndpoint = function(a) {
            a._jsPlumb.uuid && (y[a._jsPlumb.uuid] = null),
            h.anchorManager.deleteEndpoint(a);
            for (var b in x) {
                var c = x[b];
                if (c) {
                    for (var d = [], e = 0, f = c.length; e < f; e++)
                        c[e] !== a && d.push(c[e]);
                    x[b] = d
                }
                x[b].length < 1 && delete x[b]
            }
        }
        ;
        var ca = "isDetachAllowed"
          , da = "beforeDetach"
          , ea = "checkCondition";
        this.deleteConnection = function(a, b) {
            return !(null == a || (b = b || {},
            !b.force && !d.functionChain(!0, !1, [[a.endpoints[0], ca, [a]], [a.endpoints[1], ca, [a]], [a, ca, [a]], [h, ea, [da, a]]]))) && (a.setHover(!1),
            aa(a, !a.pending && b.fireEvent !== !1, b.originalEvent),
            a.endpoints[0].detachFromConnection(a),
            a.endpoints[1].detachFromConnection(a),
            d.removeWithFunction(w, function(b) {
                return a.id === b.id
            }),
            a.cleanup(),
            a.destroy(),
            !0)
        }
        ,
        this.deleteEveryConnection = function(a) {
            a = a || {};
            var b = w.length
              , c = 0;
            return h.batch(function() {
                for (var d = 0; d < b; d++)
                    c += h.deleteConnection(w[0], a) ? 1 : 0
            }),
            c
        }
        ,
        this.deleteConnectionsForElement = function(a, b) {
            b = b || {},
            a = h.getElement(a);
            var c = Z(a)
              , d = x[c];
            if (d && d.length)
                for (var e = 0, f = d.length; e < f; e++)
                    d[e].deleteEveryConnection(b);
            return h
        }
        ,
        this.deleteObject = function(a) {
            var b = {
                endpoints: {},
                connections: {},
                endpointCount: 0,
                connectionCount: 0
            }
              , c = a.deleteAttachedObjects !== !1
              , e = function(c) {
                null != c && null == b.connections[c.id] && (a.dontUpdateHover || null == c._jsPlumb || c.setHover(!1),
                b.connections[c.id] = c,
                b.connectionCount++)
            }
              , f = function(d) {
                if (null != d && null == b.endpoints[d.id] && (a.dontUpdateHover || null == d._jsPlumb || d.setHover(!1),
                b.endpoints[d.id] = d,
                b.endpointCount++,
                c))
                    for (var f = 0; f < d.connections.length; f++) {
                        var g = d.connections[f];
                        e(g)
                    }
            };
            a.connection ? e(a.connection) : f(a.endpoint);
            for (var g in b.connections) {
                var i = b.connections[g];
                if (i._jsPlumb) {
                    d.removeWithFunction(w, function(a) {
                        return i.id === a.id
                    }),
                    aa(i, a.fireEvent !== !1 && !i.pending, a.originalEvent);
                    var j = null == a.deleteAttachedObjects ? null : !a.deleteAttachedObjects;
                    i.endpoints[0].detachFromConnection(i, null, j),
                    i.endpoints[1].detachFromConnection(i, null, j),
                    i.cleanup(!0),
                    i.destroy(!0)
                }
            }
            for (var k in b.endpoints) {
                var l = b.endpoints[k];
                l._jsPlumb && (h.unregisterEndpoint(l),
                l.cleanup(!0),
                l.destroy(!0))
            }
            return b
        }
        ,
        this.draggable = function(a, b) {
            var c;
            return k(function(a) {
                c = o(a),
                c.el && N(c.el, !0, b, c.id, !0)
            }, a),
            h
        }
        ,
        this.droppable = function(a, b) {
            var c;
            return b = b || {},
            b.allowLoopback = !1,
            k(function(a) {
                c = o(a),
                c.el && h.initDroppable(c.el, b)
            }, a),
            h
        }
        ;
        var fa = function(a, b, c, d) {
            for (var e = 0, f = a.length; e < f; e++)
                a[e][b].apply(a[e], c);
            return d(a)
        }
          , ga = function(a, b, c) {
            for (var d = [], e = 0, f = a.length; e < f; e++)
                d.push([a[e][b].apply(a[e], c), a[e]]);
            return d
        }
          , ha = function(a, b, c) {
            return function() {
                return fa(a, b, arguments, c)
            }
        }
          , ia = function(a, b) {
            return function() {
                return ga(a, b, arguments)
            }
        }
          , ja = function(a, b) {
            var c = [];
            if (a)
                if ("string" == typeof a) {
                    if ("*" === a)
                        return a;
                    c.push(a)
                } else if (b)
                    c = a;
                else if (a.length)
                    for (var d = 0, e = a.length; d < e; d++)
                        c.push(o(a[d]).id);
                else
                    c.push(o(a).id);
            return c
        }
          , ka = function(a, b, c) {
            return "*" === a || (a.length > 0 ? a.indexOf(b) !== -1 : !c)
        };
        this.getConnections = function(a, b) {
            a ? a.constructor === String && (a = {
                scope: a
            }) : a = {};
            for (var c = a.scope || h.getDefaultScope(), d = ja(c, !0), e = ja(a.source), f = ja(a.target), g = !b && d.length > 1 ? {} : [], i = function(a, c) {
                if (!b && d.length > 1) {
                    var e = g[a];
                    null == e && (e = g[a] = []),
                    e.push(c)
                } else
                    g.push(c)
            }, j = 0, k = w.length; j < k; j++) {
                var l = w[j]
                  , m = l.proxies && l.proxies[0] ? l.proxies[0].originalEp.elementId : l.sourceId
                  , n = l.proxies && l.proxies[1] ? l.proxies[1].originalEp.elementId : l.targetId;
                ka(d, l.scope) && ka(e, m) && ka(f, n) && i(l.scope, l)
            }
            return g
        }
        ;
        var la = function(a, b) {
            return function(c) {
                for (var d = 0, e = a.length; d < e; d++)
                    c(a[d]);
                return b(a)
            }
        }
          , ma = function(a) {
            return function(b) {
                return a[b]
            }
        }
          , na = function(a, b) {
            var c, d, e = {
                length: a.length,
                each: la(a, b),
                get: ma(a)
            }, f = ["setHover", "removeAllOverlays", "setLabel", "addClass", "addOverlay", "removeOverlay", "removeOverlays", "showOverlay", "hideOverlay", "showOverlays", "hideOverlays", "setPaintStyle", "setHoverPaintStyle", "setSuspendEvents", "setParameter", "setParameters", "setVisible", "repaint", "addType", "toggleType", "removeType", "removeClass", "setType", "bind", "unbind"], g = ["getLabel", "getOverlay", "isHover", "getParameter", "getParameters", "getPaintStyle", "getHoverPaintStyle", "isVisible", "hasType", "getType", "isSuspendEvents"];
            for (c = 0,
            d = f.length; c < d; c++)
                e[f[c]] = ha(a, f[c], b);
            for (c = 0,
            d = g.length; c < d; c++)
                e[g[c]] = ia(a, g[c]);
            return e
        }
          , oa = function(a) {
            var b = na(a, oa);
            return r.extend(b, {
                setDetachable: ha(a, "setDetachable", oa),
                setReattach: ha(a, "setReattach", oa),
                setConnector: ha(a, "setConnector", oa),
                delete: function() {
                    for (var b = 0, c = a.length; b < c; b++)
                        h.deleteConnection(a[b])
                },
                isDetachable: ia(a, "isDetachable"),
                isReattach: ia(a, "isReattach")
            })
        }
          , pa = function(a) {
            var b = na(a, pa);
            return r.extend(b, {
                setEnabled: ha(a, "setEnabled", pa),
                setAnchor: ha(a, "setAnchor", pa),
                isEnabled: ia(a, "isEnabled"),
                deleteEveryConnection: function() {
                    for (var b = 0, c = a.length; b < c; b++)
                        a[b].deleteEveryConnection()
                },
                delete: function() {
                    for (var b = 0, c = a.length; b < c; b++)
                        h.deleteEndpoint(a[b])
                }
            })
        };
        this.select = function(a) {
            return a = a || {},
            a.scope = a.scope || "*",
            oa(a.connections || h.getConnections(a, !0))
        }
        ,
        this.selectEndpoints = function(a) {
            a = a || {},
            a.scope = a.scope || "*";
            var b = !a.element && !a.source && !a.target
              , c = b ? "*" : ja(a.element)
              , d = b ? "*" : ja(a.source)
              , e = b ? "*" : ja(a.target)
              , f = ja(a.scope, !0)
              , g = [];
            for (var h in x) {
                var i = ka(c, h, !0)
                  , j = ka(d, h, !0)
                  , k = "*" !== d
                  , l = ka(e, h, !0)
                  , m = "*" !== e;
                if (i || j || l)
                    a: for (var n = 0, o = x[h].length; n < o; n++) {
                        var p = x[h][n];
                        if (ka(f, p.scope, !0)) {
                            var q = k && d.length > 0 && !p.isSource
                              , r = m && e.length > 0 && !p.isTarget;
                            if (q || r)
                                continue a;
                            g.push(p)
                        }
                    }
            }
            return pa(g)
        }
        ,
        this.getAllConnections = function() {
            return w
        }
        ,
        this.getDefaultScope = function() {
            return H
        }
        ,
        this.getEndpoint = M,
        this.getEndpoints = function(a) {
            return x[o(a).id] || []
        }
        ,
        this.getDefaultEndpointType = function() {
            return r.Endpoint
        }
        ,
        this.getDefaultConnectionType = function() {
            return r.Connection
        }
        ,
        this.getId = Z,
        this.appendElement = K;
        var qa = !1;
        this.isHoverSuspended = function() {
            return qa
        }
        ,
        this.setHoverSuspended = function(a) {
            qa = a
        }
        ,
        this.hide = function(a, b) {
            return V(a, "none", b),
            h
        }
        ,
        this.idstamp = J,
        this.connectorsInitialized = !1,
        this.registerConnectorType = function(a, b) {
            c.push([a, b])
        }
        ;
        var ra = function(a) {
            if (!s && a) {
                var b = h.getElement(a);
                b.offsetParent && h.setContainer(b.offsetParent)
            }
        }
          , sa = function() {
            h.Defaults.Container && h.setContainer(h.Defaults.Container)
        }
          , ta = h.manage = function(a, b, c) {
            return z[a] || (z[a] = {
                el: b,
                endpoints: [],
                connections: []
            },
            z[a].info = ua({
                elId: a,
                timestamp: G
            }),
            c || h.fire("manageElement", {
                id: a,
                info: z[a].info,
                el: b
            })),
            z[a]
        }
          , ua = this.updateOffset = function(a) {
            var b, c = a.timestamp, d = a.recalc, e = a.offset, f = a.elId;
            return F && !c && (c = G),
            !d && c && c === B[f] ? {
                o: a.offset || A[f],
                s: E[f]
            } : (d || !e && null == A[f] ? (b = z[f] ? z[f].el : null,
            null != b && (E[f] = h.getSize(b),
            A[f] = h.getOffset(b),
            B[f] = c)) : (A[f] = e || A[f],
            null == E[f] && (b = z[f].el,
            null != b && (E[f] = h.getSize(b))),
            B[f] = c),
            A[f] && !A[f].right && (A[f].right = A[f].left + E[f][0],
            A[f].bottom = A[f].top + E[f][1],
            A[f].width = E[f][0],
            A[f].height = E[f][1],
            A[f].centerx = A[f].left + A[f].width / 2,
            A[f].centery = A[f].top + A[f].height / 2),
            {
                o: A[f],
                s: E[f]
            })
        }
        ;
        this.init = function() {
            a = b.jsPlumb.getRenderModes();
            var e = function(a, c, e) {
                b.jsPlumb.Connectors[a][c] = function() {
                    e.apply(this, arguments),
                    b.jsPlumb.ConnectorRenderers[a].apply(this, arguments)
                }
                ,
                d.extend(b.jsPlumb.Connectors[a][c], [e, b.jsPlumb.ConnectorRenderers[a]])
            };
            if (!b.jsPlumb.connectorsInitialized) {
                for (var f = 0; f < c.length; f++)
                    for (var g = 0; g < a.length; g++)
                        e(a[g], c[f][1], c[f][0]);
                b.jsPlumb.connectorsInitialized = !0
            }
            v || (sa(),
            h.anchorManager = new b.jsPlumb.AnchorManager({
                jsPlumbInstance: h
            }),
            v = !0,
            h.fire("ready", h))
        }
        .bind(this),
        this.log = u,
        this.jsPlumbUIComponent = m,
        this.makeAnchor = function() {
            var a, c = function(a, c) {
                if (b.jsPlumb.Anchors[a])
                    return new b.jsPlumb.Anchors[a](c);
                if (!h.Defaults.DoNotThrowErrors)
                    throw {
                        msg: "jsPlumb: unknown anchor type '" + a + "'"
                    }
            };
            if (0 === arguments.length)
                return null;
            var e = arguments[0]
              , f = arguments[1]
              , g = (arguments[2],
            null);
            if (e.compute && e.getOrientation)
                return e;
            if ("string" == typeof e)
                g = c(arguments[0], {
                    elementId: f,
                    jsPlumbInstance: h
                });
            else if (d.isArray(e))
                if (d.isArray(e[0]) || d.isString(e[0]))
                    2 === e.length && d.isObject(e[1]) ? d.isString(e[0]) ? (a = b.jsPlumb.extend({
                        elementId: f,
                        jsPlumbInstance: h
                    }, e[1]),
                    g = c(e[0], a)) : (a = b.jsPlumb.extend({
                        elementId: f,
                        jsPlumbInstance: h,
                        anchors: e[0]
                    }, e[1]),
                    g = new b.jsPlumb.DynamicAnchor(a)) : g = new r.DynamicAnchor({
                        anchors: e,
                        selector: null,
                        elementId: f,
                        jsPlumbInstance: h
                    });
                else {
                    var i = {
                        x: e[0],
                        y: e[1],
                        orientation: e.length >= 4 ? [e[2], e[3]] : [0, 0],
                        offsets: e.length >= 6 ? [e[4], e[5]] : [0, 0],
                        elementId: f,
                        jsPlumbInstance: h,
                        cssClass: 7 === e.length ? e[6] : null
                    };
                    g = new b.jsPlumb.Anchor(i),
                    g.clone = function() {
                        return new b.jsPlumb.Anchor(i)
                    }
                }
            return g.id || (g.id = "anchor_" + J()),
            g
        }
        ,
        this.makeAnchors = function(a, c, e) {
            for (var f = [], g = 0, i = a.length; g < i; g++)
                "string" == typeof a[g] ? f.push(b.jsPlumb.Anchors[a[g]]({
                    elementId: c,
                    jsPlumbInstance: e
                })) : d.isArray(a[g]) && f.push(h.makeAnchor(a[g], c, e));
            return f
        }
        ,
        this.makeDynamicAnchor = function(a, c) {
            return new b.jsPlumb.DynamicAnchor({
                anchors: a,
                selector: c,
                elementId: null,
                jsPlumbInstance: h
            })
        }
        ,
        this.targetEndpointDefinitions = {},
        this.sourceEndpointDefinitions = {};
        var va = function(a, b, c, d, e) {
            for (var f = a.target || a.srcElement, g = !1, h = d.getSelector(b, c), i = 0; i < h.length; i++)
                if (h[i] === f) {
                    g = !0;
                    break
                }
            return e ? !g : g
        }
          , wa = function(a, c, e, f, g) {
            var i = new m(c)
              , j = c._jsPlumb.EndpointDropHandler({
                jsPlumb: h,
                enabled: function() {
                    return a.def.enabled
                },
                isFull: function() {
                    var b = h.select({
                        target: a.id
                    }).length;
                    return a.def.maxConnections > 0 && b >= a.def.maxConnections
                },
                element: a.el,
                elementId: a.id,
                isSource: f,
                isTarget: g,
                addClass: function(b) {
                    h.addClass(a.el, b)
                },
                removeClass: function(b) {
                    h.removeClass(a.el, b)
                },
                onDrop: function(a) {
                    var b = a.endpoints[0];
                    b.anchor.locked = !1
                },
                isDropAllowed: function() {
                    return i.isDropAllowed.apply(i, arguments)
                },
                isRedrop: function(b) {
                    return null != b.suspendedElement && null != b.suspendedEndpoint && b.suspendedEndpoint.element === a.el
                },
                getEndpoint: function(d) {
                    var e = a.def.endpoint;
                    if (null == e || null == e._jsPlumb) {
                        var f = h.deriveEndpointAndAnchorSpec(d.getType().join(" "), !0)
                          , g = f.endpoints ? b.jsPlumb.extend(c, {
                            endpoint: a.def.def.endpoint || f.endpoints[1]
                        }) : c;
                        f.anchors && (g = b.jsPlumb.extend(g, {
                            anchor: a.def.def.anchor || f.anchors[1]
                        })),
                        e = h.addEndpoint(a.el, g),
                        e._mtNew = !0
                    }
                    if (c.uniqueEndpoint && (a.def.endpoint = e),
                    e.setDeleteOnEmpty(!0),
                    d.isDetachable() && e.initDraggable(),
                    null != e.anchor.positionFinder) {
                        var i = h.getUIPosition(arguments, h.getZoom())
                          , j = h.getOffset(a.el)
                          , k = h.getSize(a.el)
                          , l = null == i ? [0, 0] : e.anchor.positionFinder(i, j, k, e.anchor.constructorParams);
                        e.anchor.x = l[0],
                        e.anchor.y = l[1]
                    }
                    return e
                },
                maybeCleanup: function(a) {
                    a._mtNew && 0 === a.connections.length ? h.deleteObject({
                        endpoint: a
                    }) : delete a._mtNew
                }
            })
              , k = b.jsPlumb.dragEvents.drop;
            return e.scope = e.scope || c.scope || h.Defaults.Scope,
            e[k] = d.wrap(e[k], j, !0),
            g && (e[b.jsPlumb.dragEvents.over] = function() {
                return !0
            }
            ),
            c.allowLoopback === !1 && (e.canDrop = function(b) {
                var c = b.getDragElement()._jsPlumbRelatedElement;
                return c !== a.el
            }
            ),
            h.initDroppable(a.el, e, "internal"),
            j
        };
        this.makeTarget = function(a, c, d) {
            var e = b.jsPlumb.extend({
                _jsPlumb: this
            }, d);
            b.jsPlumb.extend(e, c);
            for (var f = e.maxConnections || -1, g = function(a) {
                var c = o(a)
                  , d = c.id
                  , g = b.jsPlumb.extend({}, e.dropOptions || {})
                  , h = e.connectionType || "default";
                this.targetEndpointDefinitions[d] = this.targetEndpointDefinitions[d] || {},
                ra(d),
                c.el._isJsPlumbGroup && null == g.rank && (g.rank = -1);
                var i = {
                    def: b.jsPlumb.extend({}, e),
                    uniqueEndpoint: e.uniqueEndpoint,
                    maxConnections: f,
                    enabled: !0
                };
                c.def = i,
                this.targetEndpointDefinitions[d][h] = i,
                wa(c, e, g, e.isSource === !0, !0),
                c.el._katavorioDrop[c.el._katavorioDrop.length - 1].targetDef = i
            }
            .bind(this), h = a.length && a.constructor !== String ? a : [a], i = 0, j = h.length; i < j; i++)
                g(h[i]);
            return this
        }
        ,
        this.unmakeTarget = function(a, b) {
            var c = o(a);
            return h.destroyDroppable(c.el, "internal"),
            b || delete this.targetEndpointDefinitions[c.id],
            this
        }
        ,
        this.makeSource = function(a, c, e) {
            var f = b.jsPlumb.extend({
                _jsPlumb: this
            }, e);
            b.jsPlumb.extend(f, c);
            var g = f.connectionType || "default"
              , i = h.deriveEndpointAndAnchorSpec(g);
            f.endpoint = f.endpoint || i.endpoints[0],
            f.anchor = f.anchor || i.anchors[0];
            for (var j = f.maxConnections || -1, k = f.onMaxConnections, l = function(a) {
                var c = a.id
                  , e = this.getElement(a.el);
                this.sourceEndpointDefinitions[c] = this.sourceEndpointDefinitions[c] || {},
                ra(c);
                var i = {
                    def: b.jsPlumb.extend({}, f),
                    uniqueEndpoint: f.uniqueEndpoint,
                    maxConnections: j,
                    enabled: !0
                };
                this.sourceEndpointDefinitions[c][g] = i,
                a.def = i;
                var l = b.jsPlumb.dragEvents.stop
                  , m = b.jsPlumb.dragEvents.drag
                  , o = b.jsPlumb.extend({}, f.dragOptions || {})
                  , p = o.drag
                  , q = o.stop
                  , r = null
                  , s = !1;
                o.scope = o.scope || f.scope,
                o[m] = d.wrap(o[m], function() {
                    p && p.apply(this, arguments),
                    s = !1
                }),
                o[l] = d.wrap(o[l], function() {
                    if (q && q.apply(this, arguments),
                    this.currentlyDragging = !1,
                    null != r._jsPlumb) {
                        var a = f.anchor || this.Defaults.Anchor
                          , b = r.anchor
                          , d = r.connections[0]
                          , e = this.makeAnchor(a, c, this)
                          , g = r.element;
                        if (null != e.positionFinder) {
                            var i = h.getOffset(g)
                              , j = this.getSize(g)
                              , k = {
                                left: i.left + b.x * j[0],
                                top: i.top + b.y * j[1]
                            }
                              , l = e.positionFinder(k, i, j, e.constructorParams);
                            e.x = l[0],
                            e.y = l[1]
                        }
                        r.setAnchor(e, !0),
                        r.repaint(),
                        this.repaint(r.elementId),
                        null != d && this.repaint(d.targetId)
                    }
                }
                .bind(this));
                var t = function(i) {
                    if (3 !== i.which && 2 !== i.button) {
                        var l = this.sourceEndpointDefinitions[c][g];
                        if (l.enabled) {
                            if (c = this.getId(this.getElement(a.el)),
                            f.filter) {
                                var m = d.isString(f.filter) ? va(i, a.el, f.filter, this, f.filterExclude) : f.filter(i, a.el);
                                if (m === !1)
                                    return
                            }
                            var p = this.select({
                                source: c
                            }).length;
                            if (l.maxConnections >= 0 && p >= l.maxConnections)
                                return k && k({
                                    element: a.el,
                                    maxConnections: j
                                }, i),
                                !1;
                            var q = b.jsPlumb.getPositionOnElement(i, e, n)
                              , t = {};
                            b.jsPlumb.extend(t, f),
                            t.isTemporarySource = !0,
                            t.anchor = [q[0], q[1], 0, 0],
                            t.dragOptions = o,
                            l.def.scope && (t.scope = l.def.scope),
                            r = this.addEndpoint(c, t),
                            s = !0,
                            r.setDeleteOnEmpty(!0),
                            l.uniqueEndpoint && (l.endpoint ? r.finalEndpoint = l.endpoint : (l.endpoint = r,
                            r.setDeleteOnEmpty(!1)));
                            var u = function() {
                                h.off(r.canvas, "mouseup", u),
                                h.off(a.el, "mouseup", u),
                                s && (s = !1,
                                h.deleteEndpoint(r))
                            };
                            h.on(r.canvas, "mouseup", u),
                            h.on(a.el, "mouseup", u);
                            var v = {};
                            if (l.def.extract)
                                for (var w in l.def.extract) {
                                    var x = (i.srcElement || i.target).getAttribute(w);
                                    x && (v[l.def.extract[w]] = x)
                                }
                            h.trigger(r.canvas, "mousedown", i, v),
                            d.consume(i)
                        }
                    }
                }
                .bind(this);
                this.on(a.el, "mousedown", t),
                i.trigger = t,
                f.filter && (d.isString(f.filter) || d.isFunction(f.filter)) && h.setDragFilter(a.el, f.filter);
                var u = b.jsPlumb.extend({}, f.dropOptions || {});
                wa(a, f, u, !0, f.isTarget === !0)
            }
            .bind(this), m = a.length && a.constructor !== String ? a : [a], p = 0, q = m.length; p < q; p++)
                l(o(m[p]));
            return this
        }
        ,
        this.unmakeSource = function(a, b, c) {
            var d = o(a);
            h.destroyDroppable(d.el, "internal");
            var e = this.sourceEndpointDefinitions[d.id];
            if (e)
                for (var f in e)
                    if (null == b || b === f) {
                        var g = e[f].trigger;
                        g && h.off(d.el, "mousedown", g),
                        c || delete this.sourceEndpointDefinitions[d.id][f]
                    }
            return this
        }
        ,
        this.unmakeEverySource = function() {
            for (var a in this.sourceEndpointDefinitions)
                h.unmakeSource(a, null, !0);
            return this.sourceEndpointDefinitions = {},
            this
        }
        ;
        var xa = function(a, b, c) {
            b = d.isArray(b) ? b : [b];
            var e = Z(a);
            c = c || "default";
            for (var f = 0; f < b.length; f++) {
                var g = this[b[f]][e];
                if (g && g[c])
                    return g[c].def.scope || this.Defaults.Scope
            }
        }
        .bind(this)
          , ya = function(a, b, c, e) {
            c = d.isArray(c) ? c : [c];
            var f = Z(a);
            e = e || "default";
            for (var g = 0; g < c.length; g++) {
                var h = this[c[g]][f];
                h && h[e] && (h[e].def.scope = b)
            }
        }
        .bind(this);
        this.getScope = function(a, b) {
            return xa(a, ["sourceEndpointDefinitions", "targetEndpointDefinitions"])
        }
        ,
        this.getSourceScope = function(a) {
            return xa(a, "sourceEndpointDefinitions")
        }
        ,
        this.getTargetScope = function(a) {
            return xa(a, "targetEndpointDefinitions")
        }
        ,
        this.setScope = function(a, b, c) {
            this.setSourceScope(a, b, c),
            this.setTargetScope(a, b, c)
        }
        ,
        this.setSourceScope = function(a, b, c) {
            ya(a, b, "sourceEndpointDefinitions", c),
            this.setDragScope(a, b)
        }
        ,
        this.setTargetScope = function(a, b, c) {
            ya(a, b, "targetEndpointDefinitions", c),
            this.setDropScope(a, b)
        }
        ,
        this.unmakeEveryTarget = function() {
            for (var a in this.targetEndpointDefinitions)
                h.unmakeTarget(a, !0);
            return this.targetEndpointDefinitions = {},
            this
        }
        ;
        var za = function(a, b, c, e, f) {
            var g, i, j, k = "source" === a ? this.sourceEndpointDefinitions : this.targetEndpointDefinitions;
            if (f = f || "default",
            b.length && !d.isString(b)) {
                g = [];
                for (var l = 0, m = b.length; l < m; l++)
                    i = o(b[l]),
                    k[i.id] && k[i.id][f] && (g[l] = k[i.id][f].enabled,
                    j = e ? !g[l] : c,
                    k[i.id][f].enabled = j,
                    h[j ? "removeClass" : "addClass"](i.el, "jtk-" + a + "-disabled"))
            } else {
                i = o(b);
                var n = i.id;
                k[n] && k[n][f] && (g = k[n][f].enabled,
                j = e ? !g : c,
                k[n][f].enabled = j,
                h[j ? "removeClass" : "addClass"](i.el, "jtk-" + a + "-disabled"))
            }
            return g
        }
        .bind(this)
          , Aa = function(a, b) {
            return d.isString(a) || !a.length ? b.apply(this, [a]) : a.length ? b.apply(this, [a[0]]) : void 0
        }
        .bind(this);
        this.toggleSourceEnabled = function(a, b) {
            return za("source", a, null, !0, b),
            this.isSourceEnabled(a, b)
        }
        ,
        this.setSourceEnabled = function(a, b, c) {
            return za("source", a, b, null, c)
        }
        ,
        this.isSource = function(a, b) {
            return b = b || "default",
            Aa(a, function(a) {
                var c = this.sourceEndpointDefinitions[o(a).id];
                return null != c && null != c[b]
            }
            .bind(this))
        }
        ,
        this.isSourceEnabled = function(a, b) {
            return b = b || "default",
            Aa(a, function(a) {
                var c = this.sourceEndpointDefinitions[o(a).id];
                return c && c[b] && c[b].enabled === !0
            }
            .bind(this))
        }
        ,
        this.toggleTargetEnabled = function(a, b) {
            return za("target", a, null, !0, b),
            this.isTargetEnabled(a, b)
        }
        ,
        this.isTarget = function(a, b) {
            return b = b || "default",
            Aa(a, function(a) {
                var c = this.targetEndpointDefinitions[o(a).id];
                return null != c && null != c[b]
            }
            .bind(this))
        }
        ,
        this.isTargetEnabled = function(a, b) {
            return b = b || "default",
            Aa(a, function(a) {
                var c = this.targetEndpointDefinitions[o(a).id];
                return c && c[b] && c[b].enabled === !0
            }
            .bind(this))
        }
        ,
        this.setTargetEnabled = function(a, b, c) {
            return za("target", a, b, null, c)
        }
        ,
        this.ready = function(a) {
            h.bind("ready", a)
        }
        ;
        var Ba = function(a, b) {
            if ("object" == typeof a && a.length)
                for (var c = 0, d = a.length; c < d; c++)
                    b(a[c]);
            else
                b(a);
            return h
        };
        this.repaint = function(a, b, c) {
            return Ba(a, function(a) {
                L(a, b, c)
            })
        }
        ,
        this.revalidate = function(a, b, c) {
            return Ba(a, function(a) {
                var d = c ? a : h.getId(a);
                h.updateOffset({
                    elId: d,
                    recalc: !0,
                    timestamp: b
                });
                var e = h.getDragManager();
                e && e.updateOffsets(d),
                h.repaint(a)
            })
        }
        ,
        this.repaintEverything = function() {
            var a, b = e();
            for (a in x)
                h.updateOffset({
                    elId: a,
                    recalc: !0,
                    timestamp: b
                });
            for (a in x)
                L(a, null, b);
            return this
        }
        ,
        this.removeAllEndpoints = function(a, b, c) {
            c = c || [];
            var d = function(a) {
                var e, f, g = o(a), i = x[g.id];
                if (i)
                    for (c.push(g),
                    e = 0,
                    f = i.length; e < f; e++)
                        h.deleteEndpoint(i[e], !1);
                if (delete x[g.id],
                b && g.el && 3 !== g.el.nodeType && 8 !== g.el.nodeType)
                    for (e = 0,
                    f = g.el.childNodes.length; e < f; e++)
                        d(g.el.childNodes[e])
            };
            return d(a),
            this
        }
        ;
        var Ca = function(a, b) {
            h.removeAllEndpoints(a.id, !0, b);
            for (var c = h.getDragManager(), d = function(a) {
                c && c.elementRemoved(a.id),
                h.anchorManager.clearFor(a.id),
                h.anchorManager.removeFloatingConnection(a.id),
                h.isSource(a.el) && h.unmakeSource(a.el),
                h.isTarget(a.el) && h.unmakeTarget(a.el),
                h.destroyDraggable(a.el),
                h.destroyDroppable(a.el),
                delete h.floatingConnections[a.id],
                delete z[a.id],
                delete A[a.id],
                a.el && (h.removeElement(a.el),
                a.el._jsPlumb = null)
            }, e = 1; e < b.length; e++)
                d(b[e]);
            d(a)
        };
        this.remove = function(a, b) {
            var c = o(a)
              , d = [];
            return c.text ? c.el.parentNode.removeChild(c.el) : c.id && h.batch(function() {
                Ca(c, d)
            }, b === !1),
            h
        }
        ,
        this.empty = function(a, b) {
            var c = []
              , d = function(a, b) {
                var e = o(a);
                if (e.text)
                    e.el.parentNode.removeChild(e.el);
                else if (e.el) {
                    for (; e.el.childNodes.length > 0; )
                        d(e.el.childNodes[0]);
                    b || Ca(e, c)
                }
            };
            return h.batch(function() {
                d(a, !0)
            }, b === !1),
            h
        }
        ,
        this.reset = function() {
            h.silently(function() {
                qa = !1,
                h.removeAllGroups(),
                h.removeGroupManager(),
                h.deleteEveryEndpoint(),
                h.unbind(),
                this.targetEndpointDefinitions = {},
                this.sourceEndpointDefinitions = {},
                w.length = 0,
                this.doReset && this.doReset()
            }
            .bind(this))
        }
        ;
        var Da = function(a) {
            a.canvas && a.canvas.parentNode && a.canvas.parentNode.removeChild(a.canvas),
            a.cleanup(),
            a.destroy()
        };
        this.clear = function() {
            h.select().each(Da),
            h.selectEndpoints().each(Da),
            x = {},
            y = {}
        }
        ,
        this.setDefaultScope = function(a) {
            return H = a,
            h
        }
        ,
        this.setDraggable = U,
        this.deriveEndpointAndAnchorSpec = function(a, b) {
            for (var c = ((b ? "" : "default ") + a).split(/[\s]/), d = null, e = null, f = null, g = null, i = 0; i < c.length; i++) {
                var j = h.getType(c[i], "connection");
                j && (j.endpoints && (d = j.endpoints),
                j.endpoint && (e = j.endpoint),
                j.anchors && (g = j.anchors),
                j.anchor && (f = j.anchor))
            }
            return {
                endpoints: d ? d : [e, e],
                anchors: g ? g : [f, f]
            }
        }
        ,
        this.setId = function(a, b, c) {
            var e;
            d.isString(a) ? e = a : (a = this.getElement(a),
            e = this.getId(a));
            var f = this.getConnections({
                source: e,
                scope: "*"
            }, !0)
              , g = this.getConnections({
                target: e,
                scope: "*"
            }, !0);
            b = "" + b,
            c ? a = this.getElement(b) : (a = this.getElement(e),
            this.setAttribute(a, "id", b)),
            x[b] = x[e] || [];
            for (var h = 0, i = x[b].length; h < i; h++)
                x[b][h].setElementId(b),
                x[b][h].setReferenceElement(a);
            delete x[e],
            this.sourceEndpointDefinitions[b] = this.sourceEndpointDefinitions[e],
            delete this.sourceEndpointDefinitions[e],
            this.targetEndpointDefinitions[b] = this.targetEndpointDefinitions[e],
            delete this.targetEndpointDefinitions[e],
            this.anchorManager.changeId(e, b);
            var j = this.getDragManager();
            j && j.changeId(e, b),
            z[b] = z[e],
            delete z[e];
            var k = function(c, d, e) {
                for (var f = 0, g = c.length; f < g; f++)
                    c[f].endpoints[d].setElementId(b),
                    c[f].endpoints[d].setReferenceElement(a),
                    c[f][e + "Id"] = b,
                    c[f][e] = a
            };
            k(f, 0, "source"),
            k(g, 1, "target"),
            this.repaint(b)
        }
        ,
        this.setDebugLog = function(a) {
            u = a
        }
        ,
        this.setSuspendDrawing = function(a, b) {
            var c = F;
            return F = a,
            G = a ? (new Date).getTime() : null,
            b && this.repaintEverything(),
            c
        }
        ,
        this.isSuspendDrawing = function() {
            return F
        }
        ,
        this.getSuspendedAt = function() {
            return G
        }
        ,
        this.batch = function(a, b) {
            var c = this.isSuspendDrawing();
            c || this.setSuspendDrawing(!0);
            try {
                a()
            } catch (a) {
                d.log("Function run while suspended failed", a)
            }
            c || this.setSuspendDrawing(!1, !b)
        }
        ,
        this.doWhileSuspended = this.batch,
        this.getCachedData = Y,
        this.timestamp = e,
        this.show = function(a, b) {
            return V(a, "block", b),
            h
        }
        ,
        this.toggleVisible = X,
        this.toggleDraggable = W,
        this.addListener = this.bind
    }
    ;
    d.extend(b.jsPlumbInstance, d.EventGenerator, {
        setAttribute: function(a, b, c) {
            this.setAttribute(a, b, c)
        },
        getAttribute: function(a, c) {
            return this.getAttribute(b.jsPlumb.getElement(a), c)
        },
        convertToFullOverlaySpec: function(a) {
            return d.isString(a) && (a = [a, {}]),
            a[1].id = a[1].id || d.uuid(),
            a
        },
        registerConnectionType: function(a, c) {
            if (this._connectionTypes[a] = b.jsPlumb.extend({}, c),
            c.overlays) {
                for (var d = {}, e = 0; e < c.overlays.length; e++) {
                    var f = this.convertToFullOverlaySpec(c.overlays[e]);
                    d[f[1].id] = f
                }
                this._connectionTypes[a].overlays = d
            }
        },
        registerConnectionTypes: function(a) {
            for (var b in a)
                this.registerConnectionType(b, a[b])
        },
        registerEndpointType: function(a, c) {
            if (this._endpointTypes[a] = b.jsPlumb.extend({}, c),
            c.overlays) {
                for (var d = {}, e = 0; e < c.overlays.length; e++) {
                    var f = this.convertToFullOverlaySpec(c.overlays[e]);
                    d[f[1].id] = f
                }
                this._endpointTypes[a].overlays = d
            }
        },
        registerEndpointTypes: function(a) {
            for (var b in a)
                this.registerEndpointType(b, a[b])
        },
        getType: function(a, b) {
            return "connection" === b ? this._connectionTypes[a] : this._endpointTypes[a]
        },
        setIdChanged: function(a, b) {
            this.setId(a, b, !0)
        },
        setParent: function(a, b) {
            var c = this.getElement(a)
              , d = this.getId(c)
              , e = this.getElement(b)
              , f = this.getId(e)
              , g = this.getDragManager();
            c.parentNode.removeChild(c),
            e.appendChild(c),
            g && g.setParent(c, d, e, f)
        },
        extend: function(a, b, c) {
            var d;
            if (c)
                for (d = 0; d < c.length; d++)
                    a[c[d]] = b[c[d]];
            else
                for (d in b)
                    a[d] = b[d];
            return a
        },
        floatingConnections: {},
        getFloatingAnchorIndex: function(a) {
            return a.endpoints[0].isFloating() ? 0 : a.endpoints[1].isFloating() ? 1 : -1
        }
    }),
    q.prototype.Defaults = {
        Anchor: "Bottom",
        Anchors: [null, null],
        ConnectionsDetachable: !0,
        ConnectionOverlays: [],
        Connector: "Bezier",
        Container: null,
        DoNotThrowErrors: !1,
        DragOptions: {},
        DropOptions: {},
        Endpoint: "Dot",
        EndpointOverlays: [],
        Endpoints: [null, null],
        EndpointStyle: {
            fill: "#456"
        },
        EndpointStyles: [null, null],
        EndpointHoverStyle: null,
        EndpointHoverStyles: [null, null],
        HoverPaintStyle: null,
        LabelStyle: {
            color: "black"
        },
        LogEnabled: !1,
        Overlays: [],
        MaxConnections: 1,
        PaintStyle: {
            "stroke-width": 4,
            stroke: "#456"
        },
        ReattachConnections: !1,
        RenderMode: "svg",
        Scope: "jsPlumb_DefaultScope"
    };
    var r = new q;
    b.jsPlumb = r,
    r.getInstance = function(a, b) {
        var c = new q(a);
        if (b)
            for (var d in b)
                c[d] = b[d];
        return c.init(),
        c
    }
    ,
    r.each = function(a, b) {
        if (null != a)
            if ("string" == typeof a)
                b(r.getElement(a));
            else if (null != a.length)
                for (var c = 0; c < a.length; c++)
                    b(r.getElement(a[c]));
            else
                b(a)
    }
    ,
    "undefined" != typeof exports && (exports.jsPlumb = r)
}
.call("undefined" != typeof window ? window : this),
function() {
    var a = this
      , b = a.jsPlumbUtil
      , c = function(a, b) {
        if (null == b)
            return [0, 0];
        var c = h(b)
          , d = g(c, 0);
        return [d[a + "X"], d[a + "Y"]]
    }
      , d = c.bind(this, "page")
      , e = c.bind(this, "screen")
      , f = c.bind(this, "client")
      , g = function(a, b) {
        return a.item ? a.item(b) : a[b]
    }
      , h = function(a) {
        return a.touches && a.touches.length > 0 ? a.touches : a.changedTouches && a.changedTouches.length > 0 ? a.changedTouches : a.targetTouches && a.targetTouches.length > 0 ? a.targetTouches : [a]
    }
      , i = function(a) {
        var b = {}
          , c = []
          , d = {}
          , e = {}
          , f = {};
        this.register = function(g) {
            var h = a.getId(g)
              , i = a.getOffset(g);
            b[h] || (b[h] = g,
            c.push(g),
            d[h] = {});
            var j = function(b) {
                if (b)
                    for (var c = 0; c < b.childNodes.length; c++)
                        if (3 !== b.childNodes[c].nodeType && 8 !== b.childNodes[c].nodeType) {
                            var g = jsPlumb.getElement(b.childNodes[c])
                              , k = a.getId(b.childNodes[c], null, !0);
                            if (k && e[k] && e[k] > 0) {
                                var l = a.getOffset(g);
                                d[h][k] = {
                                    id: k,
                                    offset: {
                                        left: l.left - i.left,
                                        top: l.top - i.top
                                    }
                                },
                                f[k] = h
                            }
                            j(b.childNodes[c])
                        }
            };
            j(g)
        }
        ,
        this.updateOffsets = function(b, c) {
            if (null != b) {
                c = c || {};
                var e = jsPlumb.getElement(b)
                  , g = a.getId(e)
                  , h = d[g]
                  , i = a.getOffset(e);
                if (h)
                    for (var j in h)
                        if (h.hasOwnProperty(j)) {
                            var k = jsPlumb.getElement(j)
                              , l = c[j] || a.getOffset(k);
                            if (null == k.offsetParent && null != d[g][j])
                                continue;
                            d[g][j] = {
                                id: j,
                                offset: {
                                    left: l.left - i.left,
                                    top: l.top - i.top
                                }
                            },
                            f[j] = g
                        }
            }
        }
        ,
        this.endpointAdded = function(c, g) {
            g = g || a.getId(c);
            var h = document.body
              , i = c.parentNode;
            for (e[g] = e[g] ? e[g] + 1 : 1; null != i && i !== h; ) {
                var j = a.getId(i, null, !0);
                if (j && b[j]) {
                    var k = a.getOffset(i);
                    if (null == d[j][g]) {
                        var l = a.getOffset(c);
                        d[j][g] = {
                            id: g,
                            offset: {
                                left: l.left - k.left,
                                top: l.top - k.top
                            }
                        },
                        f[g] = j
                    }
                    break
                }
                i = i.parentNode
            }
        }
        ,
        this.endpointDeleted = function(a) {
            if (e[a.elementId] && (e[a.elementId]--,
            e[a.elementId] <= 0))
                for (var b in d)
                    d.hasOwnProperty(b) && d[b] && (delete d[b][a.elementId],
                    delete f[a.elementId])
        }
        ,
        this.changeId = function(a, b) {
            d[b] = d[a],
            d[a] = {},
            f[b] = f[a],
            f[a] = null
        }
        ,
        this.getElementsForDraggable = function(a) {
            return d[a]
        }
        ,
        this.elementRemoved = function(a) {
            var b = f[a];
            b && (delete d[b][a],
            delete f[a])
        }
        ,
        this.reset = function() {
            b = {},
            c = [],
            d = {},
            e = {}
        }
        ,
        this.dragEnded = function(b) {
            if (null != b.offsetParent) {
                var c = a.getId(b)
                  , d = f[c];
                d && this.updateOffsets(d)
            }
        }
        ,
        this.setParent = function(b, c, e, g, h) {
            var i = f[c];
            d[g] || (d[g] = {});
            var j = a.getOffset(e)
              , k = h || a.getOffset(b);
            i && d[i] && delete d[i][c],
            d[g][c] = {
                id: c,
                offset: {
                    left: k.left - j.left,
                    top: k.top - j.top
                }
            },
            f[c] = g
        }
        ,
        this.clearParent = function(a, b) {
            var c = f[b];
            c && (delete d[c][b],
            delete f[b])
        }
        ,
        this.revalidateParent = function(b, c, d) {
            var e = f[c];
            if (e) {
                var g = {};
                g[c] = d,
                this.updateOffsets(e, g),
                a.revalidate(e)
            }
        }
        ,
        this.getDragAncestor = function(b) {
            var c = jsPlumb.getElement(b)
              , d = a.getId(c)
              , e = f[d];
            return e ? jsPlumb.getElement(e) : null
        }
    }
      , j = function(a) {
        return null == a ? null : a.replace(/^\s\s*/, "").replace(/\s\s*$/, "")
    }
      , k = function(a, b) {
        b = j(b),
        "undefined" != typeof a.className.baseVal ? a.className.baseVal = b : a.className = b
    }
      , l = function(a) {
        return "undefined" == typeof a.className.baseVal ? a.className : a.className.baseVal
    }
      , m = function(a, c, d) {
        c = null == c ? [] : b.isArray(c) ? c : c.split(/\s+/),
        d = null == d ? [] : b.isArray(d) ? d : d.split(/\s+/);
        var e = l(a)
          , f = e.split(/\s+/)
          , g = function(a, b) {
            for (var c = 0; c < b.length; c++)
                if (a)
                    f.indexOf(b[c]) === -1 && f.push(b[c]);
                else {
                    var d = f.indexOf(b[c]);
                    d !== -1 && f.splice(d, 1)
                }
        };
        g(!0, c),
        g(!1, d),
        k(a, f.join(" "))
    };
    a.jsPlumb.extend(a.jsPlumbInstance.prototype, {
        headless: !1,
        pageLocation: d,
        screenLocation: e,
        clientLocation: f,
        getDragManager: function() {
            return null == this.dragManager && (this.dragManager = new i(this)),
            this.dragManager
        },
        recalculateOffsets: function(a) {
            this.getDragManager().updateOffsets(a)
        },
        createElement: function(a, b, c, d) {
            return this.createElementNS(null, a, b, c, d)
        },
        createElementNS: function(a, b, c, d, e) {
            var f, g = null == a ? document.createElement(b) : document.createElementNS(a, b);
            c = c || {};
            for (f in c)
                g.style[f] = c[f];
            d && (g.className = d),
            e = e || {};
            for (f in e)
                g.setAttribute(f, "" + e[f]);
            return g
        },
        getAttribute: function(a, b) {
            return null != a.getAttribute ? a.getAttribute(b) : null
        },
        setAttribute: function(a, b, c) {
            null != a.setAttribute && a.setAttribute(b, c)
        },
        setAttributes: function(a, b) {
            for (var c in b)
                b.hasOwnProperty(c) && a.setAttribute(c, b[c])
        },
        appendToRoot: function(a) {
            document.body.appendChild(a)
        },
        getRenderModes: function() {
            return ["svg"]
        },
        getClass: l,
        addClass: function(a, b) {
            jsPlumb.each(a, function(a) {
                m(a, b)
            })
        },
        hasClass: function(a, b) {
            return a = jsPlumb.getElement(a),
            a.classList ? a.classList.contains(b) : l(a).indexOf(b) !== -1
        },
        removeClass: function(a, b) {
            jsPlumb.each(a, function(a) {
                m(a, null, b)
            })
        },
        updateClasses: function(a, b, c) {
            jsPlumb.each(a, function(a) {
                m(a, b, c)
            })
        },
        setClass: function(a, b) {
            jsPlumb.each(a, function(a) {
                k(a, b)
            })
        },
        setPosition: function(a, b) {
            a.style.left = b.left + "px",
            a.style.top = b.top + "px"
        },
        getPosition: function(a) {
            var b = function(b) {
                var c = a.style[b];
                return c ? c.substring(0, c.length - 2) : 0
            };
            return {
                left: b("left"),
                top: b("top")
            }
        },
        getStyle: function(a, b) {
            return "undefined" != typeof window.getComputedStyle ? getComputedStyle(a, null).getPropertyValue(b) : a.currentStyle[b]
        },
        getSelector: function(a, b) {
            var c = null;
            return c = 1 === arguments.length ? null != a.nodeType ? a : document.querySelectorAll(a) : a.querySelectorAll(b)
        },
        getOffset: function(a, b, c) {
            a = jsPlumb.getElement(a),
            c = c || this.getContainer();
            for (var d = {
                left: a.offsetLeft,
                top: a.offsetTop
            }, e = b || null != c && a !== c && a.offsetParent !== c ? a.offsetParent : null, f = function(a) {
                null != a && a !== document.body && (a.scrollTop > 0 || a.scrollLeft > 0) && (d.left -= a.scrollLeft,
                d.top -= a.scrollTop)
            }
            .bind(this); null != e; )
                d.left += e.offsetLeft,
                d.top += e.offsetTop,
                f(e),
                e = b ? e.offsetParent : e.offsetParent === c ? null : e.offsetParent;
            if (null != c && !b && (c.scrollTop > 0 || c.scrollLeft > 0)) {
                var g = null != a.offsetParent ? this.getStyle(a.offsetParent, "position") : "static"
                  , h = this.getStyle(a, "position");
                "absolute" !== h && "fixed" !== h && "absolute" !== g && "fixed" !== g && (d.left -= c.scrollLeft,
                d.top -= c.scrollTop)
            }
            return d
        },
        getPositionOnElement: function(a, b, c) {
            var d = "undefined" != typeof b.getBoundingClientRect ? b.getBoundingClientRect() : {
                left: 0,
                top: 0,
                width: 0,
                height: 0
            }
              , e = document.body
              , f = document.documentElement
              , g = window.pageYOffset || f.scrollTop || e.scrollTop
              , h = window.pageXOffset || f.scrollLeft || e.scrollLeft
              , i = f.clientTop || e.clientTop || 0
              , j = f.clientLeft || e.clientLeft || 0
              , k = 0
              , l = 0
              , m = d.top + g - i + k * c
              , n = d.left + h - j + l * c
              , o = jsPlumb.pageLocation(a)
              , p = d.width || b.offsetWidth * c
              , q = d.height || b.offsetHeight * c
              , r = (o[0] - n) / p
              , s = (o[1] - m) / q;
            return [r, s]
        },
        getAbsolutePosition: function(a) {
            var b = function(b) {
                var c = a.style[b];
                if (c)
                    return parseFloat(c.substring(0, c.length - 2))
            };
            return [b("left"), b("top")]
        },
        setAbsolutePosition: function(a, b, c, d) {
            c ? this.animate(a, {
                left: "+=" + (b[0] - c[0]),
                top: "+=" + (b[1] - c[1])
            }, d) : (a.style.left = b[0] + "px",
            a.style.top = b[1] + "px")
        },
        getSize: function(a) {
            return [a.offsetWidth, a.offsetHeight]
        },
        getWidth: function(a) {
            return a.offsetWidth
        },
        getHeight: function(a) {
            return a.offsetHeight
        },
        getRenderMode: function() {
            return "svg"
        }
    })
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumb
      , c = a.jsPlumbUtil
      , d = "__label"
      , e = function(a, c) {
        var e = {
            cssClass: c.cssClass,
            labelStyle: a.labelStyle,
            id: d,
            component: a,
            _jsPlumb: a._jsPlumb.instance
        }
          , f = b.extend(e, c);
        return new (b.Overlays[a._jsPlumb.instance.getRenderMode()].Label)(f)
    }
      , f = function(a, d) {
        var e = null;
        if (c.isArray(d)) {
            var f = d[0]
              , g = b.extend({
                component: a,
                _jsPlumb: a._jsPlumb.instance
            }, d[1]);
            3 === d.length && b.extend(g, d[2]),
            e = new (b.Overlays[a._jsPlumb.instance.getRenderMode()][f])(g)
        } else
            e = d.constructor === String ? new (b.Overlays[a._jsPlumb.instance.getRenderMode()][d])({
                component: a,
                _jsPlumb: a._jsPlumb.instance
            }) : d;
        return e.id = e.id || c.uuid(),
        a.cacheTypeItem("overlay", e, e.id),
        a._jsPlumb.overlays[e.id] = e,
        e
    };
    b.OverlayCapableJsPlumbUIComponent = function(b) {
        a.jsPlumbUIComponent.apply(this, arguments),
        this._jsPlumb.overlays = {},
        this._jsPlumb.overlayPositions = {},
        b.label && (this.getDefaultType().overlays[d] = ["Label", {
            label: b.label,
            location: b.labelLocation || this.defaultLabelLocation || .5,
            labelStyle: b.labelStyle || this._jsPlumb.instance.Defaults.LabelStyle,
            id: d
        }]),
        this.setListenerComponent = function(a) {
            if (this._jsPlumb)
                for (var b in this._jsPlumb.overlays)
                    this._jsPlumb.overlays[b].setListenerComponent(a)
        }
    }
    ,
    b.OverlayCapableJsPlumbUIComponent.applyType = function(a, b) {
        if (b.overlays) {
            var c, d = {};
            for (c in b.overlays) {
                var e = a._jsPlumb.overlays[b.overlays[c][1].id];
                if (e)
                    e.updateFrom(b.overlays[c][1]),
                    d[b.overlays[c][1].id] = !0;
                else {
                    var f = a.getCachedTypeItem("overlay", b.overlays[c][1].id);
                    null != f ? (f.reattach(a._jsPlumb.instance),
                    f.setVisible(!0),
                    f.updateFrom(b.overlays[c][1]),
                    a._jsPlumb.overlays[f.id] = f) : f = a.addOverlay(b.overlays[c], !0),
                    d[f.id] = !0
                }
            }
            for (c in a._jsPlumb.overlays)
                null == d[a._jsPlumb.overlays[c].id] && a.removeOverlay(a._jsPlumb.overlays[c].id, !0)
        }
    }
    ,
    c.extend(b.OverlayCapableJsPlumbUIComponent, a.jsPlumbUIComponent, {
        setHover: function(a, b) {
            if (this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged())
                for (var c in this._jsPlumb.overlays)
                    this._jsPlumb.overlays[c][a ? "addClass" : "removeClass"](this._jsPlumb.instance.hoverClass)
        },
        addOverlay: function(a, b) {
            var c = f(this, a);
            return b || this.repaint(),
            c
        },
        getOverlay: function(a) {
            return this._jsPlumb.overlays[a]
        },
        getOverlays: function() {
            return this._jsPlumb.overlays
        },
        hideOverlay: function(a) {
            var b = this.getOverlay(a);
            b && b.hide()
        },
        hideOverlays: function() {
            for (var a in this._jsPlumb.overlays)
                this._jsPlumb.overlays[a].hide()
        },
        showOverlay: function(a) {
            var b = this.getOverlay(a);
            b && b.show()
        },
        showOverlays: function() {
            for (var a in this._jsPlumb.overlays)
                this._jsPlumb.overlays[a].show()
        },
        removeAllOverlays: function(a) {
            for (var b in this._jsPlumb.overlays)
                this._jsPlumb.overlays[b].cleanup && this._jsPlumb.overlays[b].cleanup();
            this._jsPlumb.overlays = {},
            this._jsPlumb.overlayPositions = null,
            a || this.repaint()
        },
        removeOverlay: function(a, b) {
            var c = this._jsPlumb.overlays[a];
            c && (c.setVisible(!1),
            !b && c.cleanup && c.cleanup(),
            delete this._jsPlumb.overlays[a],
            this._jsPlumb.overlayPositions && delete this._jsPlumb.overlayPositions[a])
        },
        removeOverlays: function() {
            for (var a = 0, b = arguments.length; a < b; a++)
                this.removeOverlay(arguments[a])
        },
        moveParent: function(a) {
            if (this.bgCanvas && (this.bgCanvas.parentNode.removeChild(this.bgCanvas),
            a.appendChild(this.bgCanvas)),
            this.canvas && this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas),
                a.appendChild(this.canvas);
                for (var b in this._jsPlumb.overlays)
                    if (this._jsPlumb.overlays[b].isAppendedAtTopLevel) {
                        var c = this._jsPlumb.overlays[b].getElement();
                        c.parentNode.removeChild(c),
                        a.appendChild(c)
                    }
            }
        },
        getLabel: function() {
            var a = this.getOverlay(d);
            return null != a ? a.getLabel() : null
        },
        getLabelOverlay: function() {
            return this.getOverlay(d)
        },
        setLabel: function(a) {
            var b = this.getOverlay(d);
            if (b)
                a.constructor === String || a.constructor === Function ? b.setLabel(a) : (a.label && b.setLabel(a.label),
                a.location && b.setLocation(a.location));
            else {
                var c = a.constructor === String || a.constructor === Function ? {
                    label: a
                } : a;
                b = e(this, c),
                this._jsPlumb.overlays[d] = b
            }
            this._jsPlumb.instance.isSuspendDrawing() || this.repaint()
        },
        cleanup: function(a) {
            for (var b in this._jsPlumb.overlays)
                this._jsPlumb.overlays[b].cleanup(a),
                this._jsPlumb.overlays[b].destroy(a);
            a && (this._jsPlumb.overlays = {},
            this._jsPlumb.overlayPositions = null)
        },
        setVisible: function(a) {
            this[a ? "showOverlays" : "hideOverlays"]()
        },
        setAbsoluteOverlayPosition: function(a, b) {
            this._jsPlumb.overlayPositions[a.id] = b
        },
        getAbsoluteOverlayPosition: function(a) {
            return this._jsPlumb.overlayPositions ? this._jsPlumb.overlayPositions[a.id] : null
        },
        _clazzManip: function(a, b, c) {
            if (!c)
                for (var d in this._jsPlumb.overlays)
                    this._jsPlumb.overlays[d][a + "Class"](b)
        },
        addClass: function(a, b) {
            this._clazzManip("add", a, b)
        },
        removeClass: function(a, b) {
            this._clazzManip("remove", a, b)
        }
    })
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumb
      , c = a.jsPlumbUtil
      , d = function(a, b, c) {
        var d = !1;
        return {
            drag: function() {
                if (d)
                    return d = !1,
                    !0;
                if (b.element) {
                    var e = c.getUIPosition(arguments, c.getZoom());
                    null != e && c.setPosition(b.element, e),
                    c.repaint(b.element, e),
                    a.paint({
                        anchorPoint: a.anchor.getCurrentLocation({
                            element: a
                        })
                    })
                }
            },
            stopDrag: function() {
                d = !0
            }
        }
    }
      , e = function(a, b, c, d) {
        var e = b.createElement("div", {
            position: "absolute"
        });
        b.appendElement(e);
        var f = b.getId(e);
        b.setPosition(e, c),
        e.style.width = d[0] + "px",
        e.style.height = d[1] + "px",
        b.manage(f, e, !0),
        a.id = f,
        a.element = e
    }
      , f = function(a, c, d, e, f, g, h, i) {
        var j = new b.FloatingAnchor({
            reference: c,
            referenceCanvas: e,
            jsPlumbInstance: g
        });
        return h({
            paintStyle: a,
            endpoint: d,
            anchor: j,
            source: f,
            scope: i
        })
    }
      , g = ["connectorStyle", "connectorHoverStyle", "connectorOverlays", "connector", "connectionType", "connectorClass", "connectorHoverClass"]
      , h = function(a, b) {
        var c = 0;
        if (null != b)
            for (var d = 0; d < a.connections.length; d++)
                if (a.connections[d].sourceId === b || a.connections[d].targetId === b) {
                    c = d;
                    break
                }
        return a.connections[c]
    };
    b.Endpoint = function(a) {
        var i = a._jsPlumb
          , j = a.newConnection
          , k = a.newEndpoint;
        this.idPrefix = "_jsplumb_e_",
        this.defaultLabelLocation = [.5, .5],
        this.defaultOverlayKeys = ["Overlays", "EndpointOverlays"],
        b.OverlayCapableJsPlumbUIComponent.apply(this, arguments),
        this.appendToDefaultType({
            connectionType: a.connectionType,
            maxConnections: null == a.maxConnections ? this._jsPlumb.instance.Defaults.MaxConnections : a.maxConnections,
            paintStyle: a.endpointStyle || a.paintStyle || a.style || this._jsPlumb.instance.Defaults.EndpointStyle || b.Defaults.EndpointStyle,
            hoverPaintStyle: a.endpointHoverStyle || a.hoverPaintStyle || this._jsPlumb.instance.Defaults.EndpointHoverStyle || b.Defaults.EndpointHoverStyle,
            connectorStyle: a.connectorStyle,
            connectorHoverStyle: a.connectorHoverStyle,
            connectorClass: a.connectorClass,
            connectorHoverClass: a.connectorHoverClass,
            connectorOverlays: a.connectorOverlays,
            connector: a.connector,
            connectorTooltip: a.connectorTooltip
        }),
        this._jsPlumb.enabled = !(a.enabled === !1),
        this._jsPlumb.visible = !0,
        this.element = b.getElement(a.source),
        this._jsPlumb.uuid = a.uuid,
        this._jsPlumb.floatingEndpoint = null;
        var l = null;
        this._jsPlumb.uuid && (a.endpointsByUUID[this._jsPlumb.uuid] = this),
        this.elementId = a.elementId,
        this.dragProxy = a.dragProxy,
        this._jsPlumb.connectionCost = a.connectionCost,
        this._jsPlumb.connectionsDirected = a.connectionsDirected,
        this._jsPlumb.currentAnchorClass = "",
        this._jsPlumb.events = {};
        var m = a.deleteOnEmpty === !0;
        this.setDeleteOnEmpty = function(a) {
            m = a
        }
        ;
        var n = function() {
            var a = i.endpointAnchorClassPrefix + "-" + this._jsPlumb.currentAnchorClass;
            this._jsPlumb.currentAnchorClass = this.anchor.getCssClass();
            var c = i.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? "-" + this._jsPlumb.currentAnchorClass : "");
            this.removeClass(a),
            this.addClass(c),
            b.updateClasses(this.element, c, a)
        }
        .bind(this);
        this.prepareAnchor = function(a) {
            var b = this._jsPlumb.instance.makeAnchor(a, this.elementId, i);
            return b.bind("anchorChanged", function(a) {
                this.fire("anchorChanged", {
                    endpoint: this,
                    anchor: a
                }),
                n()
            }
            .bind(this)),
            b
        }
        ,
        this.setPreparedAnchor = function(a, b) {
            return this._jsPlumb.instance.continuousAnchorFactory.clear(this.elementId),
            this.anchor = a,
            n(),
            b || this._jsPlumb.instance.repaint(this.elementId),
            this
        }
        ,
        this.setAnchor = function(a, b) {
            var c = this.prepareAnchor(a);
            return this.setPreparedAnchor(c, b),
            this
        }
        ;
        var o = function(a) {
            if (this.connections.length > 0)
                for (var b = 0; b < this.connections.length; b++)
                    this.connections[b].setHover(a, !1);
            else
                this.setHover(a)
        }
        .bind(this);
        this.bind("mouseover", function() {
            o(!0)
        }),
        this.bind("mouseout", function() {
            o(!1)
        }),
        a._transient || this._jsPlumb.instance.anchorManager.add(this, this.elementId),
        this.prepareEndpoint = function(d, e) {
            var f, g = function(a, c) {
                var d = i.getRenderMode();
                if (b.Endpoints[d][a])
                    return new b.Endpoints[d][a](c);
                if (!i.Defaults.DoNotThrowErrors)
                    throw {
                        msg: "jsPlumb: unknown endpoint type '" + a + "'"
                    }
            }, h = {
                _jsPlumb: this._jsPlumb.instance,
                cssClass: a.cssClass,
                container: a.container,
                tooltip: a.tooltip,
                connectorTooltip: a.connectorTooltip,
                endpoint: this
            };
            return c.isString(d) ? f = g(d, h) : c.isArray(d) ? (h = c.merge(d[1], h),
            f = g(d[0], h)) : f = d.clone(),
            f.clone = function() {
                return c.isString(d) ? g(d, h) : c.isArray(d) ? (h = c.merge(d[1], h),
                g(d[0], h)) : void 0
            }
            .bind(this),
            f.typeId = e,
            f
        }
        ,
        this.setEndpoint = function(a, b) {
            var c = this.prepareEndpoint(a);
            this.setPreparedEndpoint(c, !0)
        }
        ,
        this.setPreparedEndpoint = function(a, b) {
            null != this.endpoint && (this.endpoint.cleanup(),
            this.endpoint.destroy()),
            this.endpoint = a,
            this.type = this.endpoint.type,
            this.canvas = this.endpoint.canvas
        }
        ,
        b.extend(this, a, g),
        this.isSource = a.isSource || !1,
        this.isTemporarySource = a.isTemporarySource || !1,
        this.isTarget = a.isTarget || !1,
        this.connections = a.connections || [],
        this.connectorPointerEvents = a["connector-pointer-events"],
        this.scope = a.scope || i.getDefaultScope(),
        this.timestamp = null,
        this.reattachConnections = a.reattach || i.Defaults.ReattachConnections,
        this.connectionsDetachable = i.Defaults.ConnectionsDetachable,
        a.connectionsDetachable !== !1 && a.detachable !== !1 || (this.connectionsDetachable = !1),
        this.dragAllowedWhenFull = a.dragAllowedWhenFull !== !1,
        a.onMaxConnections && this.bind("maxConnections", a.onMaxConnections),
        this.addConnection = function(a) {
            this.connections.push(a),
            this[(this.connections.length > 0 ? "add" : "remove") + "Class"](i.endpointConnectedClass),
            this[(this.isFull() ? "add" : "remove") + "Class"](i.endpointFullClass)
        }
        ,
        this.detachFromConnection = function(a, b, c) {
            b = null == b ? this.connections.indexOf(a) : b,
            b >= 0 && (this.connections.splice(b, 1),
            this[(this.connections.length > 0 ? "add" : "remove") + "Class"](i.endpointConnectedClass),
            this[(this.isFull() ? "add" : "remove") + "Class"](i.endpointFullClass)),
            !c && m && 0 === this.connections.length && i.deleteObject({
                endpoint: this,
                fireEvent: !1,
                deleteAttachedObjects: c !== !0
            })
        }
        ,
        this.deleteEveryConnection = function(a) {
            for (var b = this.connections.length, c = 0; c < b; c++)
                i.deleteConnection(this.connections[0], a)
        }
        ,
        this.detachFrom = function(a, b, c) {
            for (var d = [], e = 0; e < this.connections.length; e++)
                this.connections[e].endpoints[1] !== a && this.connections[e].endpoints[0] !== a || d.push(this.connections[e]);
            for (var f = 0, g = d.length; f < g; f++)
                i.deleteConnection(d[0]);
            return this
        }
        ,
        this.getElement = function() {
            return this.element
        }
        ,
        this.setElement = function(d) {
            var e = this._jsPlumb.instance.getId(d)
              , f = this.elementId;
            return c.removeWithFunction(a.endpointsByElement[this.elementId], function(a) {
                return a.id === this.id
            }
            .bind(this)),
            this.element = b.getElement(d),
            this.elementId = i.getId(this.element),
            i.anchorManager.rehomeEndpoint(this, f, this.element),
            i.dragManager.endpointAdded(this.element),
            c.addToList(a.endpointsByElement, e, this),
            this
        }
        ,
        this.makeInPlaceCopy = function() {
            var b = this.anchor.getCurrentLocation({
                element: this
            })
              , c = this.anchor.getOrientation(this)
              , d = this.anchor.getCssClass()
              , e = {
                bind: function() {},
                compute: function() {
                    return [b[0], b[1]]
                },
                getCurrentLocation: function() {
                    return [b[0], b[1]]
                },
                getOrientation: function() {
                    return c
                },
                getCssClass: function() {
                    return d
                }
            };
            return k({
                dropOptions: a.dropOptions,
                anchor: e,
                source: this.element,
                paintStyle: this.getPaintStyle(),
                endpoint: a.hideOnDrag ? "Blank" : this.endpoint,
                _transient: !0,
                scope: this.scope,
                reference: this
            })
        }
        ,
        this.connectorSelector = function() {
            var a = this.connections[0];
            return a ? a : this.connections.length < this._jsPlumb.maxConnections || this._jsPlumb.maxConnections === -1 ? null : a
        }
        ,
        this.setStyle = this.setPaintStyle,
        this.paint = function(a) {
            a = a || {};
            var b = a.timestamp
              , c = !(a.recalc === !1);
            if (!b || this.timestamp !== b) {
                var d = i.updateOffset({
                    elId: this.elementId,
                    timestamp: b
                })
                  , e = a.offset ? a.offset.o : d.o;
                if (null != e) {
                    var f = a.anchorPoint
                      , g = a.connectorPaintStyle;
                    if (null == f) {
                        var j = a.dimensions || d.s
                          , k = {
                            xy: [e.left, e.top],
                            wh: j,
                            element: this,
                            timestamp: b
                        };
                        if (c && this.anchor.isDynamic && this.connections.length > 0) {
                            var l = h(this, a.elementWithPrecedence)
                              , m = l.endpoints[0] === this ? 1 : 0
                              , n = 0 === m ? l.sourceId : l.targetId
                              , o = i.getCachedData(n)
                              , p = o.o
                              , q = o.s;
                            k.txy = [p.left, p.top],
                            k.twh = q,
                            k.tElement = l.endpoints[m]
                        }
                        f = this.anchor.compute(k)
                    }
                    this.endpoint.compute(f, this.anchor.getOrientation(this), this._jsPlumb.paintStyleInUse, g || this.paintStyleInUse),
                    this.endpoint.paint(this._jsPlumb.paintStyleInUse, this.anchor),
                    this.timestamp = b;
                    for (var r in this._jsPlumb.overlays)
                        if (this._jsPlumb.overlays.hasOwnProperty(r)) {
                            var s = this._jsPlumb.overlays[r];
                            s.isVisible() && (this._jsPlumb.overlayPlacements[r] = s.draw(this.endpoint, this._jsPlumb.paintStyleInUse),
                            s.paint(this._jsPlumb.overlayPlacements[r]))
                        }
                }
            }
        }
        ,
        this.getTypeDescriptor = function() {
            return "endpoint"
        }
        ,
        this.isVisible = function() {
            return this._jsPlumb.visible
        }
        ,
        this.repaint = this.paint;
        var p = !1;
        this.initDraggable = function() {
            if (!p && b.isDragSupported(this.element)) {
                var g, h = {
                    id: null,
                    element: null
                }, m = null, n = !1, o = null, q = d(this, h, i), r = a.dragOptions || {}, s = {}, t = b.dragEvents.start, u = b.dragEvents.stop, v = b.dragEvents.drag, w = b.dragEvents.beforeStart, x = function(a) {
                    g = a.e.payload || {}
                }, y = function(d) {
                    m = this.connectorSelector();
                    var l = !0;
                    this.isEnabled() || (l = !1),
                    null != m || this.isSource || this.isTemporarySource || (l = !1),
                    !this.isSource || !this.isFull() || null != m && this.dragAllowedWhenFull || (l = !1),
                    null == m || m.isDetachable(this) || (l = !1);
                    var p = i.checkCondition(null == m ? "beforeDrag" : "beforeStartDetach", {
                        endpoint: this,
                        source: this.element,
                        sourceId: this.elementId,
                        connection: m
                    });
                    if (p === !1 ? l = !1 : "object" == typeof p ? b.extend(p, g || {}) : p = g || {},
                    l === !1)
                        return i.stopDrag && i.stopDrag(this.canvas),
                        q.stopDrag(),
                        !1;
                    for (var r = 0; r < this.connections.length; r++)
                        this.connections[r].setHover(!1);
                    this.addClass("endpointDrag"),
                    i.setConnectionBeingDragged(!0),
                    m && !this.isFull() && this.isSource && (m = null),
                    i.updateOffset({
                        elId: this.elementId
                    });
                    var s = this._jsPlumb.instance.getOffset(this.canvas)
                      , t = this.canvas
                      , u = this._jsPlumb.instance.getSize(this.canvas);
                    e(h, i, s, u),
                    i.setAttributes(this.canvas, {
                        dragId: h.id,
                        elId: this.elementId
                    });
                    var v = this.dragProxy || this.endpoint;
                    if (null == this.dragProxy && null != this.connectionType) {
                        var w = this._jsPlumb.instance.deriveEndpointAndAnchorSpec(this.connectionType);
                        w.endpoints[1] && (v = w.endpoints[1])
                    }
                    var x = this._jsPlumb.instance.makeAnchor("Center");
                    x.isFloating = !0,
                    this._jsPlumb.floatingEndpoint = f(this.getPaintStyle(), x, v, this.canvas, h.element, i, k, this.scope);
                    var y = this._jsPlumb.floatingEndpoint.anchor;
                    if (null == m)
                        this.setHover(!1, !1),
                        m = j({
                            sourceEndpoint: this,
                            targetEndpoint: this._jsPlumb.floatingEndpoint,
                            source: this.element,
                            target: h.element,
                            anchors: [this.anchor, this._jsPlumb.floatingEndpoint.anchor],
                            paintStyle: a.connectorStyle,
                            hoverPaintStyle: a.connectorHoverStyle,
                            connector: a.connector,
                            overlays: a.connectorOverlays,
                            type: this.connectionType,
                            cssClass: this.connectorClass,
                            hoverClass: this.connectorHoverClass,
                            scope: a.scope,
                            data: p
                        }),
                        m.pending = !0,
                        m.addClass(i.draggingClass),
                        this._jsPlumb.floatingEndpoint.addClass(i.draggingClass),
                        this._jsPlumb.floatingEndpoint.anchor = y,
                        i.fire("connectionDrag", m),
                        i.anchorManager.newConnection(m);
                    else {
                        n = !0,
                        m.setHover(!1);
                        var z = m.endpoints[0].id === this.id ? 0 : 1;
                        this.detachFromConnection(m, null, !0);
                        var A = i.getDragScope(t);
                        i.setAttribute(this.canvas, "originalScope", A),
                        i.fire("connectionDrag", m),
                        0 === z ? (o = [m.source, m.sourceId, t, A],
                        i.anchorManager.sourceChanged(m.endpoints[z].elementId, h.id, m, h.element)) : (o = [m.target, m.targetId, t, A],
                        m.target = h.element,
                        m.targetId = h.id,
                        i.anchorManager.updateOtherEndpoint(m.sourceId, m.endpoints[z].elementId, m.targetId, m)),
                        m.suspendedEndpoint = m.endpoints[z],
                        m.suspendedElement = m.endpoints[z].getElement(),
                        m.suspendedElementId = m.endpoints[z].elementId,
                        m.suspendedElementType = 0 === z ? "source" : "target",
                        m.suspendedEndpoint.setHover(!1),
                        this._jsPlumb.floatingEndpoint.referenceEndpoint = m.suspendedEndpoint,
                        m.endpoints[z] = this._jsPlumb.floatingEndpoint,
                        m.addClass(i.draggingClass),
                        this._jsPlumb.floatingEndpoint.addClass(i.draggingClass)
                    }
                    i.floatingConnections[h.id] = m,
                    c.addToList(a.endpointsByElement, h.id, this._jsPlumb.floatingEndpoint),
                    i.currentlyDragging = !0
                }
                .bind(this), z = function() {
                    if (i.setConnectionBeingDragged(!1),
                    m && null != m.endpoints) {
                        var a = i.getDropEvent(arguments)
                          , b = i.getFloatingAnchorIndex(m);
                        if (m.endpoints[0 === b ? 1 : 0].anchor.locked = !1,
                        m.removeClass(i.draggingClass),
                        this._jsPlumb && (m.deleteConnectionNow || m.endpoints[b] === this._jsPlumb.floatingEndpoint) && n && m.suspendedEndpoint) {
                            0 === b ? (m.floatingElement = m.source,
                            m.floatingId = m.sourceId,
                            m.floatingEndpoint = m.endpoints[0],
                            m.floatingIndex = 0,
                            m.source = o[0],
                            m.sourceId = o[1]) : (m.floatingElement = m.target,
                            m.floatingId = m.targetId,
                            m.floatingEndpoint = m.endpoints[1],
                            m.floatingIndex = 1,
                            m.target = o[0],
                            m.targetId = o[1]);
                            var c = this._jsPlumb.floatingEndpoint;
                            i.setDragScope(o[2], o[3]),
                            m.endpoints[b] = m.suspendedEndpoint,
                            m.isReattach() || m._forceReattach || m._forceDetach || !i.deleteConnection(m) ? (m.setHover(!1),
                            m._forceDetach = null,
                            m._forceReattach = null,
                            this._jsPlumb.floatingEndpoint.detachFromConnection(m),
                            m.suspendedEndpoint.addConnection(m),
                            1 === b ? i.anchorManager.updateOtherEndpoint(m.sourceId, m.floatingId, m.targetId, m) : i.anchorManager.sourceChanged(m.floatingId, m.sourceId, m, m.source),
                            i.repaint(o[1])) : i.deleteObject({
                                endpoint: c
                            })
                        }
                        this.deleteAfterDragStop ? i.deleteObject({
                            endpoint: this
                        }) : this._jsPlumb && this.paint({
                            recalc: !1
                        }),
                        i.fire("connectionDragStop", m, a),
                        m.pending && i.fire("connectionAborted", m, a),
                        i.currentlyDragging = !1,
                        m.suspendedElement = null,
                        m.suspendedEndpoint = null,
                        m = null
                    }
                    h && h.element && i.remove(h.element, !1, !1),
                    l && i.deleteObject({
                        endpoint: l
                    }),
                    this._jsPlumb && (this.canvas.style.visibility = "visible",
                    this.anchor.locked = !1,
                    this._jsPlumb.floatingEndpoint = null)
                }
                .bind(this);
                r = b.extend(s, r),
                r.scope = this.scope || r.scope,
                r[w] = c.wrap(r[w], x, !1),
                r[t] = c.wrap(r[t], y, !1),
                r[v] = c.wrap(r[v], q.drag),
                r[u] = c.wrap(r[u], z),
                r.multipleDrop = !1,
                r.canDrag = function() {
                    return this.isSource || this.isTemporarySource || this.connections.length > 0
                }
                .bind(this),
                i.initDraggable(this.canvas, r, "internal"),
                this.canvas._jsPlumbRelatedElement = this.element,
                p = !0
            }
        }
        ;
        var q = a.endpoint || this._jsPlumb.instance.Defaults.Endpoint || b.Defaults.Endpoint;
        this.setEndpoint(q, !0);
        var r = a.anchor ? a.anchor : a.anchors ? a.anchors : i.Defaults.Anchor || "Top";
        this.setAnchor(r, !0);
        var s = ["default", a.type || ""].join(" ");
        this.addType(s, a.data, !0),
        this.canvas = this.endpoint.canvas,
        this.canvas._jsPlumb = this,
        this.initDraggable();
        var t = function(d, e, f, g) {
            if (b.isDropSupported(this.element)) {
                var h = a.dropOptions || i.Defaults.DropOptions || b.Defaults.DropOptions;
                h = b.extend({}, h),
                h.scope = h.scope || this.scope;
                var j = b.dragEvents.drop
                  , k = b.dragEvents.over
                  , l = b.dragEvents.out
                  , m = this
                  , n = i.EndpointDropHandler({
                    getEndpoint: function() {
                        return m
                    },
                    jsPlumb: i,
                    enabled: function() {
                        return null == f || f.isEnabled()
                    },
                    isFull: function() {
                        return f.isFull()
                    },
                    element: this.element,
                    elementId: this.elementId,
                    isSource: this.isSource,
                    isTarget: this.isTarget,
                    addClass: function(a) {
                        m.addClass(a)
                    },
                    removeClass: function(a) {
                        m.removeClass(a)
                    },
                    isDropAllowed: function() {
                        return m.isDropAllowed.apply(m, arguments)
                    },
                    reference: g,
                    isRedrop: function(a, b) {
                        return a.suspendedEndpoint && b.reference && a.suspendedEndpoint.id === b.reference.id
                    }
                });
                h[j] = c.wrap(h[j], n, !0),
                h[k] = c.wrap(h[k], function() {
                    var a = b.getDragObject(arguments)
                      , c = i.getAttribute(b.getElement(a), "dragId")
                      , d = i.floatingConnections[c];
                    if (null != d) {
                        var e = i.getFloatingAnchorIndex(d)
                          , f = this.isTarget && 0 !== e || d.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id === d.suspendedEndpoint.id;
                        if (f) {
                            var g = i.checkCondition("checkDropAllowed", {
                                sourceEndpoint: d.endpoints[e],
                                targetEndpoint: this,
                                connection: d
                            });
                            this[(g ? "add" : "remove") + "Class"](i.endpointDropAllowedClass),
                            this[(g ? "remove" : "add") + "Class"](i.endpointDropForbiddenClass),
                            d.endpoints[e].anchor.over(this.anchor, this)
                        }
                    }
                }
                .bind(this)),
                h[l] = c.wrap(h[l], function() {
                    var a = b.getDragObject(arguments)
                      , c = null == a ? null : i.getAttribute(b.getElement(a), "dragId")
                      , d = c ? i.floatingConnections[c] : null;
                    if (null != d) {
                        var e = i.getFloatingAnchorIndex(d)
                          , f = this.isTarget && 0 !== e || d.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id === d.suspendedEndpoint.id;
                        f && (this.removeClass(i.endpointDropAllowedClass),
                        this.removeClass(i.endpointDropForbiddenClass),
                        d.endpoints[e].anchor.out())
                    }
                }
                .bind(this)),
                i.initDroppable(d, h, "internal", e)
            }
        }
        .bind(this);
        return this.anchor.isFloating || t(this.canvas, !(a._transient || this.anchor.isFloating), this, a.reference),
        this
    }
    ,
    c.extend(b.Endpoint, b.OverlayCapableJsPlumbUIComponent, {
        setVisible: function(a, b, c) {
            if (this._jsPlumb.visible = a,
            this.canvas && (this.canvas.style.display = a ? "block" : "none"),
            this[a ? "showOverlays" : "hideOverlays"](),
            !b)
                for (var d = 0; d < this.connections.length; d++)
                    if (this.connections[d].setVisible(a),
                    !c) {
                        var e = this === this.connections[d].endpoints[0] ? 1 : 0;
                        1 === this.connections[d].endpoints[e].connections.length && this.connections[d].endpoints[e].setVisible(a, !0, !0)
                    }
        },
        getAttachedElements: function() {
            return this.connections
        },
        applyType: function(a, c) {
            this.setPaintStyle(a.endpointStyle || a.paintStyle, c),
            this.setHoverPaintStyle(a.endpointHoverStyle || a.hoverPaintStyle, c),
            null != a.maxConnections && (this._jsPlumb.maxConnections = a.maxConnections),
            a.scope && (this.scope = a.scope),
            b.extend(this, a, g),
            null != a.cssClass && this.canvas && this._jsPlumb.instance.addClass(this.canvas, a.cssClass),
            b.OverlayCapableJsPlumbUIComponent.applyType(this, a)
        },
        isEnabled: function() {
            return this._jsPlumb.enabled
        },
        setEnabled: function(a) {
            this._jsPlumb.enabled = a
        },
        cleanup: function() {
            var a = this._jsPlumb.instance.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? "-" + this._jsPlumb.currentAnchorClass : "");
            b.removeClass(this.element, a),
            this.anchor = null,
            this.endpoint.cleanup(!0),
            this.endpoint.destroy(),
            this.endpoint = null,
            this._jsPlumb.instance.destroyDraggable(this.canvas, "internal"),
            this._jsPlumb.instance.destroyDroppable(this.canvas, "internal")
        },
        setHover: function(a) {
            this.endpoint && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged() && this.endpoint.setHover(a)
        },
        isFull: function() {
            return 0 === this._jsPlumb.maxConnections || !(this.isFloating() || this._jsPlumb.maxConnections < 0 || this.connections.length < this._jsPlumb.maxConnections)
        },
        isFloating: function() {
            return null != this.anchor && this.anchor.isFloating
        },
        isConnectedTo: function(a) {
            var b = !1;
            if (a)
                for (var c = 0; c < this.connections.length; c++)
                    if (this.connections[c].endpoints[1] === a || this.connections[c].endpoints[0] === a) {
                        b = !0;
                        break
                    }
            return b
        },
        getConnectionCost: function() {
            return this._jsPlumb.connectionCost
        },
        setConnectionCost: function(a) {
            this._jsPlumb.connectionCost = a
        },
        areConnectionsDirected: function() {
            return this._jsPlumb.connectionsDirected
        },
        setConnectionsDirected: function(a) {
            this._jsPlumb.connectionsDirected = a
        },
        setElementId: function(a) {
            this.elementId = a,
            this.anchor.elementId = a
        },
        setReferenceElement: function(a) {
            this.element = b.getElement(a)
        },
        setDragAllowedWhenFull: function(a) {
            this.dragAllowedWhenFull = a
        },
        equals: function(a) {
            return this.anchor.equals(a.anchor)
        },
        getUuid: function() {
            return this._jsPlumb.uuid
        },
        computeAnchor: function(a) {
            return this.anchor.compute(a)
        }
    }),
    a.jsPlumbInstance.prototype.EndpointDropHandler = function(a) {
        return function(b) {
            var d = a.jsPlumb;
            a.removeClass(d.endpointDropAllowedClass),
            a.removeClass(d.endpointDropForbiddenClass);
            var e = d.getDropEvent(arguments)
              , f = d.getDragObject(arguments)
              , g = d.getAttribute(f, "dragId")
              , h = (d.getAttribute(f, "elId"),
            d.getAttribute(f, "originalScope"))
              , i = d.floatingConnections[g];
            if (null != i) {
                var j = null != i.suspendedEndpoint;
                if (!j || null != i.suspendedEndpoint._jsPlumb) {
                    var k = a.getEndpoint(i);
                    if (null != k) {
                        if (a.isRedrop(i, a))
                            return i._forceReattach = !0,
                            i.setHover(!1),
                            void (a.maybeCleanup && a.maybeCleanup(k));
                        var l = d.getFloatingAnchorIndex(i);
                        if (0 === l && !a.isSource || 1 === l && !a.isTarget)
                            return void (a.maybeCleanup && a.maybeCleanup(k));
                        a.onDrop && a.onDrop(i),
                        h && d.setDragScope(f, h);
                        var m = a.isFull(b);
                        if (m && k.fire("maxConnections", {
                            endpoint: this,
                            connection: i,
                            maxConnections: k._jsPlumb.maxConnections
                        }, e),
                        !m && a.enabled()) {
                            var n = !0;
                            0 === l ? (i.floatingElement = i.source,
                            i.floatingId = i.sourceId,
                            i.floatingEndpoint = i.endpoints[0],
                            i.floatingIndex = 0,
                            i.source = a.element,
                            i.sourceId = a.elementId) : (i.floatingElement = i.target,
                            i.floatingId = i.targetId,
                            i.floatingEndpoint = i.endpoints[1],
                            i.floatingIndex = 1,
                            i.target = a.element,
                            i.targetId = a.elementId),
                            j && i.suspendedEndpoint.id !== k.id && (i.isDetachAllowed(i) && i.endpoints[l].isDetachAllowed(i) && i.suspendedEndpoint.isDetachAllowed(i) && d.checkCondition("beforeDetach", i) || (n = !1));
                            var o = function(b) {
                                i.endpoints[l].detachFromConnection(i),
                                i.suspendedEndpoint && i.suspendedEndpoint.detachFromConnection(i),
                                i.endpoints[l] = k,
                                k.addConnection(i);
                                var f = k.getParameters();
                                for (var g in f)
                                    i.setParameter(g, f[g]);
                                if (j) {
                                    var h = i.suspendedEndpoint.elementId;
                                    d.fireMoveEvent({
                                        index: l,
                                        originalSourceId: 0 === l ? h : i.sourceId,
                                        newSourceId: 0 === l ? k.elementId : i.sourceId,
                                        originalTargetId: 1 === l ? h : i.targetId,
                                        newTargetId: 1 === l ? k.elementId : i.targetId,
                                        originalSourceEndpoint: 0 === l ? i.suspendedEndpoint : i.endpoints[0],
                                        newSourceEndpoint: 0 === l ? k : i.endpoints[0],
                                        originalTargetEndpoint: 1 === l ? i.suspendedEndpoint : i.endpoints[1],
                                        newTargetEndpoint: 1 === l ? k : i.endpoints[1],
                                        connection: i
                                    }, e)
                                } else
                                    f.draggable && d.initDraggable(this.element, a.dragOptions, "internal", d);
                                if (1 === l ? d.anchorManager.updateOtherEndpoint(i.sourceId, i.floatingId, i.targetId, i) : d.anchorManager.sourceChanged(i.floatingId, i.sourceId, i, i.source),
                                i.endpoints[0].finalEndpoint) {
                                    var m = i.endpoints[0];
                                    m.detachFromConnection(i),
                                    i.endpoints[0] = i.endpoints[0].finalEndpoint,
                                    i.endpoints[0].addConnection(i)
                                }
                                c.isObject(b) && i.mergeData(b),
                                d.finaliseConnection(i, null, e, !1),
                                i.setHover(!1)
                            }
                            .bind(this)
                              , p = function() {
                                i.suspendedEndpoint && (i.endpoints[l] = i.suspendedEndpoint,
                                i.setHover(!1),
                                i._forceDetach = !0,
                                0 === l ? (i.source = i.suspendedEndpoint.element,
                                i.sourceId = i.suspendedEndpoint.elementId) : (i.target = i.suspendedEndpoint.element,
                                i.targetId = i.suspendedEndpoint.elementId),
                                i.suspendedEndpoint.addConnection(i),
                                1 === l ? d.anchorManager.updateOtherEndpoint(i.sourceId, i.floatingId, i.targetId, i) : d.anchorManager.sourceChanged(i.floatingId, i.sourceId, i, i.source),
                                d.repaint(i.sourceId),
                                i._forceDetach = !1)
                            };
                            if (n = n && a.isDropAllowed(i.sourceId, i.targetId, i.scope, i, k))
                                return o(n),
                                !0;
                            p()
                        }
                        a.maybeCleanup && a.maybeCleanup(k),
                        d.currentlyDragging = !1
                    }
                }
            }
        }
    }
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumb
      , c = a.jsPlumbUtil
      , d = function(a, c, d, e, f) {
        if (!a.Defaults.DoNotThrowErrors && null == b.Connectors[c][d])
            throw {
                msg: "jsPlumb: unknown connector type '" + d + "'"
            };
        return new b.Connectors[c][d](e,f)
    }
      , e = function(a, b, c) {
        return a ? c.makeAnchor(a, b, c) : null
    }
      , f = function(a, b, d, e) {
        null != b && (b._jsPlumbConnections = b._jsPlumbConnections || {},
        e ? delete b._jsPlumbConnections[a.id] : b._jsPlumbConnections[a.id] = !0,
        c.isEmpty(b._jsPlumbConnections) ? d.removeClass(b, d.connectedClass) : d.addClass(b, d.connectedClass))
    };
    b.Connection = function(a) {
        var d = a.newEndpoint;
        this.id = a.id,
        this.connector = null,
        this.idPrefix = "_jsplumb_c_",
        this.defaultLabelLocation = .5,
        this.defaultOverlayKeys = ["Overlays", "ConnectionOverlays"],
        this.previousConnection = a.previousConnection,
        this.source = b.getElement(a.source),
        this.target = b.getElement(a.target),
        a.sourceEndpoint && (this.source = a.sourceEndpoint.getElement()),
        a.targetEndpoint && (this.target = a.targetEndpoint.getElement()),
        b.OverlayCapableJsPlumbUIComponent.apply(this, arguments),
        this.sourceId = this._jsPlumb.instance.getId(this.source),
        this.targetId = this._jsPlumb.instance.getId(this.target),
        this.scope = a.scope,
        this.endpoints = [],
        this.endpointStyles = [];
        var e = this._jsPlumb.instance;
        e.manage(this.sourceId, this.source),
        e.manage(this.targetId, this.target),
        this._jsPlumb.visible = !0,
        this._jsPlumb.editable = a.editable === !0,
        this._jsPlumb.params = {
            cssClass: a.cssClass,
            container: a.container,
            "pointer-events": a["pointer-events"],
            editorParams: a.editorParams,
            overlays: a.overlays
        },
        this._jsPlumb.lastPaintedAt = null,
        this.bind("mouseover", function() {
            this.setHover(!0)
        }
        .bind(this)),
        this.bind("mouseout", function() {
            this.setHover(!1)
        }
        .bind(this)),
        this.editableRequested = a.editable !== !1,
        this.setEditable = function(a) {
            return !!this.connector && this.connector.setEditable(a)
        }
        ,
        this.isEditable = function() {
            return !!this.connector && this.connector.isEditable()
        }
        ,
        this.isEditing = function() {
            return !!this.connector && this.connector.isEditing()
        }
        ,
        this.makeEndpoint = function(b, c, f, g) {
            return f = f || this._jsPlumb.instance.getId(c),
            this.prepareEndpoint(e, d, this, g, b ? 0 : 1, a, c, f)
        }
        ,
        a.type && (a.endpoints = a.endpoints || this._jsPlumb.instance.deriveEndpointAndAnchorSpec(a.type).endpoints);
        var f = this.makeEndpoint(!0, this.source, this.sourceId, a.sourceEndpoint)
          , g = this.makeEndpoint(!1, this.target, this.targetId, a.targetEndpoint);
        f && c.addToList(a.endpointsByElement, this.sourceId, f),
        g && c.addToList(a.endpointsByElement, this.targetId, g),
        this.scope || (this.scope = this.endpoints[0].scope),
        null != a.deleteEndpointsOnEmpty && (this.endpoints[0].setDeleteOnEmpty(a.deleteEndpointsOnEmpty),
        this.endpoints[1].setDeleteOnEmpty(a.deleteEndpointsOnEmpty));
        var h = e.Defaults.ConnectionsDetachable;
        a.detachable === !1 && (h = !1),
        this.endpoints[0].connectionsDetachable === !1 && (h = !1),
        this.endpoints[1].connectionsDetachable === !1 && (h = !1);
        var i = a.reattach || this.endpoints[0].reattachConnections || this.endpoints[1].reattachConnections || e.Defaults.ReattachConnections;
        this.appendToDefaultType({
            detachable: h,
            reattach: i,
            paintStyle: this.endpoints[0].connectorStyle || this.endpoints[1].connectorStyle || a.paintStyle || e.Defaults.PaintStyle || b.Defaults.PaintStyle,
            hoverPaintStyle: this.endpoints[0].connectorHoverStyle || this.endpoints[1].connectorHoverStyle || a.hoverPaintStyle || e.Defaults.HoverPaintStyle || b.Defaults.HoverPaintStyle
        });
        var j = e.getSuspendedAt();
        if (!e.isSuspendDrawing()) {
            var k = e.getCachedData(this.sourceId)
              , l = k.o
              , m = k.s
              , n = e.getCachedData(this.targetId)
              , o = n.o
              , p = n.s
              , q = j || e.timestamp()
              , r = this.endpoints[0].anchor.compute({
                xy: [l.left, l.top],
                wh: m,
                element: this.endpoints[0],
                elementId: this.endpoints[0].elementId,
                txy: [o.left, o.top],
                twh: p,
                tElement: this.endpoints[1],
                timestamp: q
            });
            this.endpoints[0].paint({
                anchorLoc: r,
                timestamp: q
            }),
            r = this.endpoints[1].anchor.compute({
                xy: [o.left, o.top],
                wh: p,
                element: this.endpoints[1],
                elementId: this.endpoints[1].elementId,
                txy: [l.left, l.top],
                twh: m,
                tElement: this.endpoints[0],
                timestamp: q
            }),
            this.endpoints[1].paint({
                anchorLoc: r,
                timestamp: q
            })
        }
        this.getTypeDescriptor = function() {
            return "connection"
        }
        ,
        this.getAttachedElements = function() {
            return this.endpoints
        }
        ,
        this.isDetachable = function() {
            return this._jsPlumb.detachable === !0
        }
        ,
        this.setDetachable = function(a) {
            this._jsPlumb.detachable = a === !0
        }
        ,
        this.isReattach = function() {
            return this._jsPlumb.reattach === !0 || this.endpoints[0].reattachConnections === !0 || this.endpoints[1].reattachConnections === !0
        }
        ,
        this.setReattach = function(a) {
            this._jsPlumb.reattach = a === !0
        }
        ,
        this._jsPlumb.cost = a.cost || this.endpoints[0].getConnectionCost(),
        this._jsPlumb.directed = a.directed,
        null == a.directed && (this._jsPlumb.directed = this.endpoints[0].areConnectionsDirected());
        var s = b.extend({}, this.endpoints[1].getParameters());
        b.extend(s, this.endpoints[0].getParameters()),
        b.extend(s, this.getParameters()),
        this.setParameters(s),
        this.setConnector(this.endpoints[0].connector || this.endpoints[1].connector || a.connector || e.Defaults.Connector || b.Defaults.Connector, !0),
        a.geometry && this.connector.setGeometry(a.geometry);
        var t = null != a.data && c.isObject(a.data) ? a.data : {};
        this.getData = function() {
            return t
        }
        ,
        this.setData = function(a) {
            t = a || {}
        }
        ,
        this.mergeData = function(a) {
            t = b.extend(t, a)
        }
        ;
        var u = ["default", this.endpoints[0].connectionType, this.endpoints[1].connectionType, a.type].join(" ");
        /[^\s]/.test(u) && this.addType(u, a.data, !0),
        this.updateConnectedClass()
    }
    ,
    c.extend(b.Connection, b.OverlayCapableJsPlumbUIComponent, {
        applyType: function(a, c, d) {
            null != a.detachable && this.setDetachable(a.detachable),
            null != a.reattach && this.setReattach(a.reattach),
            a.scope && (this.scope = a.scope),
            null != a.cssClass && this.canvas && this._jsPlumb.instance.addClass(this.canvas, a.cssClass);
            var e = null;
            a.anchor ? (e = this.getCachedTypeItem("anchors", d.anchor),
            null == e && (e = [this._jsPlumb.instance.makeAnchor(a.anchor), this._jsPlumb.instance.makeAnchor(a.anchor)],
            this.cacheTypeItem("anchors", e, d.anchor))) : a.anchors && (e = this.getCachedTypeItem("anchors", d.anchors),
            null == e && (e = [this._jsPlumb.instance.makeAnchor(a.anchors[0]), this._jsPlumb.instance.makeAnchor(a.anchors[1])],
            this.cacheTypeItem("anchors", e, d.anchors))),
            null != e && (this.endpoints[0].anchor = e[0],
            this.endpoints[1].anchor = e[1],
            this.endpoints[1].anchor.isDynamic && this._jsPlumb.instance.repaint(this.endpoints[1].elementId)),
            b.OverlayCapableJsPlumbUIComponent.applyType(this, a)
        },
        addClass: function(a, b) {
            b && (this.endpoints[0].addClass(a),
            this.endpoints[1].addClass(a),
            this.suspendedEndpoint && this.suspendedEndpoint.addClass(a)),
            this.connector && this.connector.addClass(a)
        },
        removeClass: function(a, b) {
            b && (this.endpoints[0].removeClass(a),
            this.endpoints[1].removeClass(a),
            this.suspendedEndpoint && this.suspendedEndpoint.removeClass(a)),
            this.connector && this.connector.removeClass(a)
        },
        isVisible: function() {
            return this._jsPlumb.visible
        },
        setVisible: function(a) {
            this._jsPlumb.visible = a,
            this.connector && this.connector.setVisible(a),
            this.repaint()
        },
        cleanup: function() {
            this.updateConnectedClass(!0),
            this.endpoints = null,
            this.source = null,
            this.target = null,
            null != this.connector && (this.connector.cleanup(!0),
            this.connector.destroy(!0)),
            this.connector = null
        },
        updateConnectedClass: function(a) {
            this._jsPlumb && (f(this, this.source, this._jsPlumb.instance, a),
            f(this, this.target, this._jsPlumb.instance, a))
        },
        setHover: function(b) {
            this.connector && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged() && (this.connector.setHover(b),
            a.jsPlumb[b ? "addClass" : "removeClass"](this.source, this._jsPlumb.instance.hoverSourceClass),
            a.jsPlumb[b ? "addClass" : "removeClass"](this.target, this._jsPlumb.instance.hoverTargetClass))
        },
        getUuids: function() {
            return [this.endpoints[0].getUuid(), this.endpoints[1].getUuid()]
        },
        getCost: function() {
            return this._jsPlumb ? this._jsPlumb.cost : -(1 / 0)
        },
        setCost: function(a) {
            this._jsPlumb.cost = a
        },
        isDirected: function() {
            return this._jsPlumb.directed === !0
        },
        getConnector: function() {
            return this.connector
        },
        getGeometry: function() {
            return this.connector ? this.connector.getGeometry() : null
        },
        setGeometry: function(a) {
            this.connector && this.connector.setGeometry(a)
        },
        prepareConnector: function(a, b) {
            var e, f = {
                _jsPlumb: this._jsPlumb.instance,
                cssClass: (this._jsPlumb.params.cssClass || "") + (this.isEditable() ? this._jsPlumb.instance.editableConnectorClass : ""),
                container: this._jsPlumb.params.container,
                "pointer-events": this._jsPlumb.params["pointer-events"],
                editable: this.editableRequested
            }, g = this._jsPlumb.instance.getRenderMode();
            return c.isString(a) ? e = d(this._jsPlumb.instance, g, a, f, this) : c.isArray(a) && (e = 1 === a.length ? d(this._jsPlumb.instance, g, a[0], f, this) : d(this._jsPlumb.instance, g, a[0], c.merge(a[1], f), this)),
            null != b && (e.typeId = b),
            e
        },
        setPreparedConnector: function(a, b, c, d) {
            var e, f = "";
            if (null != this.connector && (e = this.connector,
            f = e.getClass(),
            this.connector.cleanup(),
            this.connector.destroy()),
            this.connector = a,
            d && this.cacheTypeItem("connector", a, d),
            this.canvas = this.connector.canvas,
            this.bgCanvas = this.connector.bgCanvas,
            this.addClass(f),
            this.canvas && (this.canvas._jsPlumb = this),
            this.bgCanvas && (this.bgCanvas._jsPlumb = this),
            null != e)
                for (var g = this.getOverlays(), h = 0; h < g.length; h++)
                    g[h].transfer && g[h].transfer(this.connector);
            c || this.setListenerComponent(this.connector),
            b || this.repaint()
        },
        setConnector: function(a, b, c, d) {
            var e = this.prepareConnector(a, d);
            this.setPreparedConnector(e, b, c, d)
        },
        paint: function(a) {
            if (!this._jsPlumb.instance.isSuspendDrawing() && this._jsPlumb.visible) {
                a = a || {};
                var b = a.timestamp
                  , c = !1
                  , d = c ? this.sourceId : this.targetId
                  , e = c ? this.targetId : this.sourceId
                  , f = c ? 0 : 1
                  , g = c ? 1 : 0;
                if (null == b || b !== this._jsPlumb.lastPaintedAt) {
                    var h = this._jsPlumb.instance.updateOffset({
                        elId: e
                    }).o
                      , i = this._jsPlumb.instance.updateOffset({
                        elId: d
                    }).o
                      , j = this.endpoints[g]
                      , k = this.endpoints[f]
                      , l = j.anchor.getCurrentLocation({
                        xy: [h.left, h.top],
                        wh: [h.width, h.height],
                        element: j,
                        timestamp: b
                    })
                      , m = k.anchor.getCurrentLocation({
                        xy: [i.left, i.top],
                        wh: [i.width, i.height],
                        element: k,
                        timestamp: b
                    });
                    this.connector.resetBounds(),
                    this.connector.compute({
                        sourcePos: l,
                        targetPos: m,
                        sourceEndpoint: this.endpoints[g],
                        targetEndpoint: this.endpoints[f],
                        "stroke-width": this._jsPlumb.paintStyleInUse.strokeWidth,
                        sourceInfo: h,
                        targetInfo: i
                    });
                    var n = {
                        minX: 1 / 0,
                        minY: 1 / 0,
                        maxX: -(1 / 0),
                        maxY: -(1 / 0)
                    };
                    for (var o in this._jsPlumb.overlays)
                        if (this._jsPlumb.overlays.hasOwnProperty(o)) {
                            var p = this._jsPlumb.overlays[o];
                            p.isVisible() && (this._jsPlumb.overlayPlacements[o] = p.draw(this.connector, this._jsPlumb.paintStyleInUse, this.getAbsoluteOverlayPosition(p)),
                            n.minX = Math.min(n.minX, this._jsPlumb.overlayPlacements[o].minX),
                            n.maxX = Math.max(n.maxX, this._jsPlumb.overlayPlacements[o].maxX),
                            n.minY = Math.min(n.minY, this._jsPlumb.overlayPlacements[o].minY),
                            n.maxY = Math.max(n.maxY, this._jsPlumb.overlayPlacements[o].maxY))
                        }
                    var q = parseFloat(this._jsPlumb.paintStyleInUse.strokeWidth || 1) / 2
                      , r = parseFloat(this._jsPlumb.paintStyleInUse.strokeWidth || 0)
                      , s = {
                        xmin: Math.min(this.connector.bounds.minX - (q + r), n.minX),
                        ymin: Math.min(this.connector.bounds.minY - (q + r), n.minY),
                        xmax: Math.max(this.connector.bounds.maxX + (q + r), n.maxX),
                        ymax: Math.max(this.connector.bounds.maxY + (q + r), n.maxY)
                    };
                    this.connector.paint(this._jsPlumb.paintStyleInUse, null, s);
                    for (var t in this._jsPlumb.overlays)
                        if (this._jsPlumb.overlays.hasOwnProperty(t)) {
                            var u = this._jsPlumb.overlays[t];
                            u.isVisible() && u.paint(this._jsPlumb.overlayPlacements[t], s)
                        }
                }
                this._jsPlumb.lastPaintedAt = b
            }
        },
        repaint: function(a) {
            a = a || {},
            this.paint({
                elId: this.sourceId,
                recalc: !(a.recalc === !1),
                timestamp: a.timestamp
            })
        },
        prepareEndpoint: function(a, c, d, f, g, h, i, j) {
            var k;
            if (f)
                d.endpoints[g] = f,
                f.addConnection(d);
            else {
                h.endpoints || (h.endpoints = [null, null]);
                var l = h.endpoints[g] || h.endpoint || a.Defaults.Endpoints[g] || b.Defaults.Endpoints[g] || a.Defaults.Endpoint || b.Defaults.Endpoint;
                h.endpointStyles || (h.endpointStyles = [null, null]),
                h.endpointHoverStyles || (h.endpointHoverStyles = [null, null]);
                var m = h.endpointStyles[g] || h.endpointStyle || a.Defaults.EndpointStyles[g] || b.Defaults.EndpointStyles[g] || a.Defaults.EndpointStyle || b.Defaults.EndpointStyle;
                null == m.fill && null != h.paintStyle && (m.fill = h.paintStyle.stroke),
                null == m.outlineStroke && null != h.paintStyle && (m.outlineStroke = h.paintStyle.outlineStroke),
                null == m.outlineWidth && null != h.paintStyle && (m.outlineWidth = h.paintStyle.outlineWidth);
                var n = h.endpointHoverStyles[g] || h.endpointHoverStyle || a.Defaults.EndpointHoverStyles[g] || b.Defaults.EndpointHoverStyles[g] || a.Defaults.EndpointHoverStyle || b.Defaults.EndpointHoverStyle;
                null != h.hoverPaintStyle && (null == n && (n = {}),
                null == n.fill && (n.fill = h.hoverPaintStyle.stroke));
                var o = h.anchors ? h.anchors[g] : h.anchor ? h.anchor : e(a.Defaults.Anchors[g], j, a) || e(b.Defaults.Anchors[g], j, a) || e(a.Defaults.Anchor, j, a) || e(b.Defaults.Anchor, j, a)
                  , p = h.uuids ? h.uuids[g] : null;
                k = c({
                    paintStyle: m,
                    hoverPaintStyle: n,
                    endpoint: l,
                    connections: [d],
                    uuid: p,
                    anchor: o,
                    source: i,
                    scope: h.scope,
                    reattach: h.reattach || a.Defaults.ReattachConnections,
                    detachable: h.detachable || a.Defaults.ConnectionsDetachable
                }),
                null == f && k.setDeleteOnEmpty(!0),
                d.endpoints[g] = k,
                h.drawEndpoints === !1 && k.setVisible(!1, !0, !0)
            }
            return k
        }
    })
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumbUtil
      , c = a.jsPlumb;
    c.AnchorManager = function(a) {
        var d = {}
          , e = {}
          , f = {}
          , g = {}
          , h = {
            HORIZONTAL: "horizontal",
            VERTICAL: "vertical",
            DIAGONAL: "diagonal",
            IDENTITY: "identity"
        }
          , i = ["left", "top", "right", "bottom"]
          , j = {}
          , k = this
          , l = {}
          , m = a.jsPlumbInstance
          , n = {}
          , o = function(a, b, c, d, e, f) {
            if (a === b)
                return {
                    orientation: h.IDENTITY,
                    a: ["top", "top"]
                };
            var g = Math.atan2(d.centery - c.centery, d.centerx - c.centerx)
              , j = Math.atan2(c.centery - d.centery, c.centerx - d.centerx)
              , k = []
              , l = {};
            !function(a, b) {
                for (var c = 0; c < a.length; c++)
                    l[a[c]] = {
                        left: [b[c].left, b[c].centery],
                        right: [b[c].right, b[c].centery],
                        top: [b[c].centerx, b[c].top],
                        bottom: [b[c].centerx, b[c].bottom]
                    }
            }(["source", "target"], [c, d]);
            for (var m = 0; m < i.length; m++)
                for (var n = 0; n < i.length; n++)
                    k.push({
                        source: i[m],
                        target: i[n],
                        dist: Biltong.lineLength(l.source[i[m]], l.target[i[n]])
                    });
            k.sort(function(a, b) {
                return a.dist < b.dist ? -1 : a.dist > b.dist ? 1 : 0
            });
            for (var o = k[0].source, p = k[0].target, q = 0; q < k.length && (o = !e.isContinuous || e.isEdgeSupported(k[q].source) ? k[q].source : null,
            p = !f.isContinuous || f.isEdgeSupported(k[q].target) ? k[q].target : null,
            null == o || null == p); q++)
                ;
            return {
                a: [o, p],
                theta: g,
                theta2: j
            }
        }
          , p = function(a, b, c, d, e, f, g) {
            for (var h = [], i = b[e ? 0 : 1] / (d.length + 1), j = 0; j < d.length; j++) {
                var k = (j + 1) * i
                  , l = f * b[e ? 1 : 0];
                g && (k = b[e ? 0 : 1] - k);
                var m = e ? k : l
                  , n = c[0] + m
                  , o = m / b[0]
                  , p = e ? l : k
                  , q = c[1] + p
                  , r = p / b[1];
                h.push([n, q, o, r, d[j][1], d[j][2]])
            }
            return h
        }
          , q = function(a) {
            return function(b, c) {
                var d = !0;
                return d = a ? b[0][0] < c[0][0] : b[0][0] > c[0][0],
                d === !1 ? -1 : 1
            }
        }
          , r = function(a, b) {
            var c = a[0][0] < 0 ? -Math.PI - a[0][0] : Math.PI - a[0][0]
              , d = b[0][0] < 0 ? -Math.PI - b[0][0] : Math.PI - b[0][0];
            return c > d ? 1 : -1
        }
          , s = {
            top: function(a, b) {
                return a[0] > b[0] ? 1 : -1
            },
            right: q(!0),
            bottom: q(!0),
            left: r
        }
          , t = function(a, b) {
            return a.sort(b)
        }
          , u = function(a, b) {
            var c = m.getCachedData(a)
              , d = c.s
              , f = c.o
              , h = function(b, c, d, f, h, i, j) {
                if (f.length > 0)
                    for (var k = t(f, s[b]), l = "right" === b || "top" === b, m = p(b, c, d, k, h, i, l), n = function(a, b) {
                        e[a.id] = [b[0], b[1], b[2], b[3]],
                        g[a.id] = j
                    }, o = 0; o < m.length; o++) {
                        var q = m[o][4]
                          , r = q.endpoints[0].elementId === a
                          , u = q.endpoints[1].elementId === a;
                        r && n(q.endpoints[0], m[o]),
                        u && n(q.endpoints[1], m[o])
                    }
            };
            h("bottom", d, [f.left, f.top], b.bottom, !0, 1, [0, 1]),
            h("top", d, [f.left, f.top], b.top, !0, 0, [0, -1]),
            h("left", d, [f.left, f.top], b.left, !1, 0, [-1, 0]),
            h("right", d, [f.left, f.top], b.right, !1, 1, [1, 0])
        };
        this.reset = function() {
            d = {},
            j = {},
            l = {}
        }
        ,
        this.addFloatingConnection = function(a, b) {
            n[a] = b
        }
        ,
        this.removeFloatingConnection = function(a) {
            delete n[a]
        }
        ,
        this.newConnection = function(a) {
            var d = a.sourceId
              , e = a.targetId
              , f = a.endpoints
              , g = !0
              , h = function(h, i, k, l, m) {
                d === e && k.isContinuous && (a._jsPlumb.instance.removeElement(f[1].canvas),
                g = !1),
                b.addToList(j, l, [m, i, k.constructor === c.DynamicAnchor])
            };
            h(0, f[0], f[0].anchor, e, a),
            g && h(1, f[1], f[1].anchor, d, a)
        }
        ;
        var v = function(a) {
            !function(a, c) {
                if (a) {
                    var d = function(a) {
                        return a[4] === c
                    };
                    b.removeWithFunction(a.top, d),
                    b.removeWithFunction(a.left, d),
                    b.removeWithFunction(a.bottom, d),
                    b.removeWithFunction(a.right, d)
                }
            }(l[a.elementId], a.id)
        };
        this.connectionDetached = function(a, c) {
            var d = a.connection || a
              , e = a.sourceId
              , f = a.targetId
              , g = d.endpoints
              , h = function(a, c, d, e, f) {
                b.removeWithFunction(j[e], function(a) {
                    return a[0].id === f.id
                })
            };
            h(1, g[1], g[1].anchor, e, d),
            h(0, g[0], g[0].anchor, f, d),
            d.floatingId && (h(d.floatingIndex, d.floatingEndpoint, d.floatingEndpoint.anchor, d.floatingId, d),
            v(d.floatingEndpoint)),
            v(d.endpoints[0]),
            v(d.endpoints[1]),
            c || (k.redraw(d.sourceId),
            d.targetId !== d.sourceId && k.redraw(d.targetId))
        }
        ,
        this.add = function(a, c) {
            b.addToList(d, c, a)
        }
        ,
        this.changeId = function(a, b) {
            j[b] = j[a],
            d[b] = d[a],
            delete j[a],
            delete d[a]
        }
        ,
        this.getConnectionsFor = function(a) {
            return j[a] || []
        }
        ,
        this.getEndpointsFor = function(a) {
            return d[a] || []
        }
        ,
        this.deleteEndpoint = function(a) {
            b.removeWithFunction(d[a.elementId], function(b) {
                return b.id === a.id
            }),
            v(a)
        }
        ,
        this.clearFor = function(a) {
            delete d[a],
            d[a] = []
        }
        ;
        var w = function(c, d, e, f, g, h, i, j, k, l, m, n) {
            var o, p, q = -1, r = -1, s = f.endpoints[i], t = s.id, u = [1, 0][i], v = [[d, e], f, g, h, t], w = c[k], x = s._continuousAnchorEdge ? c[s._continuousAnchorEdge] : null;
            if (x) {
                var y = b.findWithFunction(x, function(a) {
                    return a[4] === t
                });
                if (y !== -1)
                    for (x.splice(y, 1),
                    o = 0; o < x.length; o++)
                        p = x[o][1],
                        b.addWithFunction(m, p, function(a) {
                            return a.id === p.id
                        }),
                        b.addWithFunction(n, x[o][1].endpoints[i], function(a) {
                            return a.id === p.endpoints[i].id
                        }),
                        b.addWithFunction(n, x[o][1].endpoints[u], function(a) {
                            return a.id === p.endpoints[u].id
                        })
            }
            for (o = 0; o < w.length; o++)
                p = w[o][1],
                1 === a.idx && w[o][3] === h && r === -1 && (r = o),
                b.addWithFunction(m, p, function(a) {
                    return a.id === p.id
                }),
                b.addWithFunction(n, w[o][1].endpoints[i], function(a) {
                    return a.id === p.endpoints[i].id
                }),
                b.addWithFunction(n, w[o][1].endpoints[u], function(a) {
                    return a.id === p.endpoints[u].id
                });
            if (q !== -1)
                w[q] = v;
            else {
                var z = j ? r !== -1 ? r : 0 : w.length;
                w.splice(z, 0, v)
            }
            s._continuousAnchorEdge = k
        };
        this.updateOtherEndpoint = function(a, d, e, f) {
            var g = b.findWithFunction(j[a], function(a) {
                return a[0].id === f.id
            })
              , h = b.findWithFunction(j[d], function(a) {
                return a[0].id === f.id
            });
            g !== -1 && (j[a][g][0] = f,
            j[a][g][1] = f.endpoints[1],
            j[a][g][2] = f.endpoints[1].anchor.constructor === c.DynamicAnchor),
            h > -1 && (j[d].splice(h, 1),
            b.addToList(j, e, [f, f.endpoints[0], f.endpoints[0].anchor.constructor === c.DynamicAnchor])),
            f.updateConnectedClass()
        }
        ,
        this.sourceChanged = function(a, d, e, f) {
            if (a !== d) {
                e.sourceId = d,
                e.source = f,
                b.removeWithFunction(j[a], function(a) {
                    return a[0].id === e.id
                });
                var g = b.findWithFunction(j[e.targetId], function(a) {
                    return a[0].id === e.id
                });
                g > -1 && (j[e.targetId][g][0] = e,
                j[e.targetId][g][1] = e.endpoints[0],
                j[e.targetId][g][2] = e.endpoints[0].anchor.constructor === c.DynamicAnchor),
                b.addToList(j, d, [e, e.endpoints[1], e.endpoints[1].anchor.constructor === c.DynamicAnchor]),
                e.endpoints[1].anchor.isContinuous && (e.source === e.target ? e._jsPlumb.instance.removeElement(e.endpoints[1].canvas) : null == e.endpoints[1].canvas.parentNode && e._jsPlumb.instance.appendElement(e.endpoints[1].canvas)),
                e.updateConnectedClass()
            }
        }
        ,
        this.rehomeEndpoint = function(a, b, c) {
            var e = d[b] || []
              , f = m.getId(c);
            if (f !== b) {
                var g = e.indexOf(a);
                if (g > -1) {
                    var h = e.splice(g, 1)[0];
                    k.add(h, f)
                }
            }
            for (var i = 0; i < a.connections.length; i++)
                a.connections[i].sourceId === b ? k.sourceChanged(b, a.elementId, a.connections[i], a.element) : a.connections[i].targetId === b && (a.connections[i].targetId = a.elementId,
                a.connections[i].target = a.element,
                k.updateOtherEndpoint(a.connections[i].sourceId, b, a.elementId, a.connections[i]))
        }
        ,
        this.redraw = function(a, e, f, g, h, i) {
            if (!m.isSuspendDrawing()) {
                var k = d[a] || []
                  , p = j[a] || []
                  , q = []
                  , r = []
                  , s = [];
                f = f || m.timestamp(),
                g = g || {
                    left: 0,
                    top: 0
                },
                e && (e = {
                    left: e.left + g.left,
                    top: e.top + g.top
                });
                for (var t = m.updateOffset({
                    elId: a,
                    offset: e,
                    recalc: !1,
                    timestamp: f
                }), v = {}, x = 0; x < p.length; x++) {
                    var y = p[x][0]
                      , z = y.sourceId
                      , A = y.targetId
                      , B = y.endpoints[0].anchor.isContinuous
                      , C = y.endpoints[1].anchor.isContinuous;
                    if (B || C) {
                        var D = z + "_" + A
                          , E = v[D]
                          , F = y.sourceId === a ? 1 : 0;
                        B && !l[z] && (l[z] = {
                            top: [],
                            right: [],
                            bottom: [],
                            left: []
                        }),
                        C && !l[A] && (l[A] = {
                            top: [],
                            right: [],
                            bottom: [],
                            left: []
                        }),
                        a !== A && m.updateOffset({
                            elId: A,
                            timestamp: f
                        }),
                        a !== z && m.updateOffset({
                            elId: z,
                            timestamp: f
                        });
                        var G = m.getCachedData(A)
                          , H = m.getCachedData(z);
                        A === z && (B || C) ? (w(l[z], -Math.PI / 2, 0, y, !1, A, 0, !1, "top", z, q, r),
                        w(l[A], -Math.PI / 2, 0, y, !1, z, 1, !1, "top", A, q, r)) : (E || (E = o(z, A, H.o, G.o, y.endpoints[0].anchor, y.endpoints[1].anchor),
                        v[D] = E),
                        B && w(l[z], E.theta, 0, y, !1, A, 0, !1, E.a[0], z, q, r),
                        C && w(l[A], E.theta2, -1, y, !0, z, 1, !0, E.a[1], A, q, r)),
                        B && b.addWithFunction(s, z, function(a) {
                            return a === z
                        }),
                        C && b.addWithFunction(s, A, function(a) {
                            return a === A
                        }),
                        b.addWithFunction(q, y, function(a) {
                            return a.id === y.id
                        }),
                        (B && 0 === F || C && 1 === F) && b.addWithFunction(r, y.endpoints[F], function(a) {
                            return a.id === y.endpoints[F].id
                        })
                    }
                }
                for (x = 0; x < k.length; x++)
                    0 === k[x].connections.length && k[x].anchor.isContinuous && (l[a] || (l[a] = {
                        top: [],
                        right: [],
                        bottom: [],
                        left: []
                    }),
                    w(l[a], -Math.PI / 2, 0, {
                        endpoints: [k[x], k[x]],
                        paint: function() {}
                    }, !1, a, 0, !1, k[x].anchor.getDefaultFace(), a, q, r),
                    b.addWithFunction(s, a, function(b) {
                        return b === a
                    }));
                for (x = 0; x < s.length; x++)
                    u(s[x], l[s[x]]);
                for (x = 0; x < k.length; x++)
                    k[x].paint({
                        timestamp: f,
                        offset: t,
                        dimensions: t.s,
                        recalc: i !== !0
                    });
                for (x = 0; x < r.length; x++) {
                    var I = m.getCachedData(r[x].elementId);
                    r[x].paint({
                        timestamp: f,
                        offset: I,
                        dimensions: I.s
                    })
                }
                for (x = 0; x < p.length; x++) {
                    var J = p[x][1];
                    if (J.anchor.constructor === c.DynamicAnchor) {
                        J.paint({
                            elementWithPrecedence: a,
                            timestamp: f
                        }),
                        b.addWithFunction(q, p[x][0], function(a) {
                            return a.id === p[x][0].id
                        });
                        for (var K = 0; K < J.connections.length; K++)
                            J.connections[K] !== p[x][0] && b.addWithFunction(q, J.connections[K], function(a) {
                                return a.id === J.connections[K].id
                            })
                    } else
                        J.anchor.constructor === c.Anchor && b.addWithFunction(q, p[x][0], function(a) {
                            return a.id === p[x][0].id
                        })
                }
                var L = n[a];
                for (L && L.paint({
                    timestamp: f,
                    recalc: !1,
                    elId: a
                }),
                x = 0; x < q.length; x++)
                    q[x].paint({
                        elId: a,
                        timestamp: f,
                        recalc: !1,
                        clearEdits: h
                    })
            }
        }
        ;
        var x = function(a) {
            b.EventGenerator.apply(this),
            this.type = "Continuous",
            this.isDynamic = !0,
            this.isContinuous = !0;
            for (var c = a.faces || ["top", "right", "bottom", "left"], d = !(a.clockwise === !1), h = {}, i = {
                top: "bottom",
                right: "left",
                left: "right",
                bottom: "top"
            }, j = {
                top: "right",
                right: "bottom",
                left: "top",
                bottom: "left"
            }, k = {
                top: "left",
                right: "top",
                left: "bottom",
                bottom: "right"
            }, l = d ? j : k, m = d ? k : j, n = a.cssClass || "", o = 0; o < c.length; o++)
                h[c[o]] = !0;
            this.getDefaultFace = function() {
                return 0 === c.length ? "top" : c[0]
            }
            ,
            this.verifyEdge = function(a) {
                return h[a] ? a : h[i[a]] ? i[a] : h[l[a]] ? l[a] : h[m[a]] ? m[a] : a
            }
            ,
            this.isEdgeSupported = function(a) {
                return h[a] === !0
            }
            ,
            this.compute = function(a) {
                return f[a.element.id] || e[a.element.id] || [0, 0]
            }
            ,
            this.getCurrentLocation = function(a) {
                return f[a.element.id] || e[a.element.id] || [0, 0]
            }
            ,
            this.getOrientation = function(a) {
                return g[a.id] || [0, 0]
            }
            ,
            this.clearUserDefinedLocation = function() {
                delete f[a.elementId]
            }
            ,
            this.setUserDefinedLocation = function(b) {
                f[a.elementId] = b
            }
            ,
            this.getCssClass = function() {
                return n
            }
        };
        m.continuousAnchorFactory = {
            get: function(a) {
                return new x(a)
            },
            clear: function(a) {
                delete f[a],
                delete e[a]
            }
        }
    }
    ,
    c.Anchor = function(a) {
        this.x = a.x || 0,
        this.y = a.y || 0,
        this.elementId = a.elementId,
        this.cssClass = a.cssClass || "",
        this.userDefinedLocation = null,
        this.orientation = a.orientation || [0, 0],
        this.lastReturnValue = null,
        this.offsets = a.offsets || [0, 0],
        this.timestamp = null,
        b.EventGenerator.apply(this),
        this.compute = function(a) {
            var b = a.xy
              , c = a.wh
              , d = a.timestamp;
            return a.clearUserDefinedLocation && (this.userDefinedLocation = null),
            d && d === this.timestamp ? this.lastReturnValue : (null != this.userDefinedLocation ? this.lastReturnValue = this.userDefinedLocation : this.lastReturnValue = [b[0] + this.x * c[0] + this.offsets[0], b[1] + this.y * c[1] + this.offsets[1]],
            this.timestamp = d,
            this.lastReturnValue)
        }
        ,
        this.getCurrentLocation = function(a) {
            return a = a || {},
            null == this.lastReturnValue || null != a.timestamp && this.timestamp !== a.timestamp ? this.compute(a) : this.lastReturnValue
        }
    }
    ,
    b.extend(c.Anchor, b.EventGenerator, {
        equals: function(a) {
            if (!a)
                return !1;
            var b = a.getOrientation()
              , c = this.getOrientation();
            return this.x === a.x && this.y === a.y && this.offsets[0] === a.offsets[0] && this.offsets[1] === a.offsets[1] && c[0] === b[0] && c[1] === b[1]
        },
        getUserDefinedLocation: function() {
            return this.userDefinedLocation
        },
        setUserDefinedLocation: function(a) {
            this.userDefinedLocation = a
        },
        clearUserDefinedLocation: function() {
            this.userDefinedLocation = null
        },
        getOrientation: function() {
            return this.orientation
        },
        getCssClass: function() {
            return this.cssClass
        }
    }),
    c.FloatingAnchor = function(a) {
        c.Anchor.apply(this, arguments);
        var b = a.reference
          , d = a.referenceCanvas
          , e = c.getSize(d)
          , f = 0
          , g = 0
          , h = null
          , i = null;
        this.orientation = null,
        this.x = 0,
        this.y = 0,
        this.isFloating = !0,
        this.compute = function(a) {
            var b = a.xy
              , c = [b[0] + e[0] / 2, b[1] + e[1] / 2];
            return i = c,
            c
        }
        ,
        this.getOrientation = function(a) {
            if (h)
                return h;
            var c = b.getOrientation(a);
            return [Math.abs(c[0]) * f * -1, Math.abs(c[1]) * g * -1]
        }
        ,
        this.over = function(a, b) {
            h = a.getOrientation(b)
        }
        ,
        this.out = function() {
            h = null
        }
        ,
        this.getCurrentLocation = function(a) {
            return null == i ? this.compute(a) : i
        }
    }
    ,
    b.extend(c.FloatingAnchor, c.Anchor);
    var d = function(a, b, d) {
        return a.constructor === c.Anchor ? a : b.makeAnchor(a, d, b)
    };
    c.DynamicAnchor = function(a) {
        c.Anchor.apply(this, arguments),
        this.isDynamic = !0,
        this.anchors = [],
        this.elementId = a.elementId,
        this.jsPlumbInstance = a.jsPlumbInstance;
        for (var b = 0; b < a.anchors.length; b++)
            this.anchors[b] = d(a.anchors[b], this.jsPlumbInstance, this.elementId);
        this.getAnchors = function() {
            return this.anchors
        }
        ,
        this.locked = !1;
        var e = this.anchors.length > 0 ? this.anchors[0] : null
          , f = e
          , g = this
          , h = function(a, b, c, d, e) {
            var f = d[0] + a.x * e[0]
              , g = d[1] + a.y * e[1]
              , h = d[0] + e[0] / 2
              , i = d[1] + e[1] / 2;
            return Math.sqrt(Math.pow(b - f, 2) + Math.pow(c - g, 2)) + Math.sqrt(Math.pow(h - f, 2) + Math.pow(i - g, 2))
        }
          , i = a.selector || function(a, b, c, d, e) {
            for (var f = c[0] + d[0] / 2, g = c[1] + d[1] / 2, i = -1, j = 1 / 0, k = 0; k < e.length; k++) {
                var l = h(e[k], f, g, a, b);
                l < j && (i = k + 0,
                j = l)
            }
            return e[i]
        }
        ;
        this.compute = function(a) {
            var b = a.xy
              , c = a.wh
              , d = a.txy
              , h = a.twh;
            this.timestamp = a.timestamp;
            var j = g.getUserDefinedLocation();
            return null != j ? j : this.locked || null == d || null == h ? e.compute(a) : (a.timestamp = null,
            e = i(b, c, d, h, this.anchors),
            this.x = e.x,
            this.y = e.y,
            e !== f && this.fire("anchorChanged", e),
            f = e,
            e.compute(a))
        }
        ,
        this.getCurrentLocation = function(a) {
            return this.getUserDefinedLocation() || (null != e ? e.getCurrentLocation(a) : null)
        }
        ,
        this.getOrientation = function(a) {
            return null != e ? e.getOrientation(a) : [0, 0]
        }
        ,
        this.over = function(a, b) {
            null != e && e.over(a, b)
        }
        ,
        this.out = function() {
            null != e && e.out()
        }
        ,
        this.getCssClass = function() {
            return e && e.getCssClass() || ""
        }
    }
    ,
    b.extend(c.DynamicAnchor, c.Anchor);
    var e = function(a, b, d, e, f, g) {
        c.Anchors[f] = function(c) {
            var h = c.jsPlumbInstance.makeAnchor([a, b, d, e, 0, 0], c.elementId, c.jsPlumbInstance);
            return h.type = f,
            g && g(h, c),
            h
        }
    };
    e(.5, 0, 0, -1, "TopCenter"),
    e(.5, 1, 0, 1, "BottomCenter"),
    e(0, .5, -1, 0, "LeftMiddle"),
    e(1, .5, 1, 0, "RightMiddle"),
    e(.5, 0, 0, -1, "Top"),
    e(.5, 1, 0, 1, "Bottom"),
    e(0, .5, -1, 0, "Left"),
    e(1, .5, 1, 0, "Right"),
    e(.5, .5, 0, 0, "Center"),
    e(1, 0, 0, -1, "TopRight"),
    e(1, 1, 0, 1, "BottomRight"),
    e(0, 0, 0, -1, "TopLeft"),
    e(0, 1, 0, 1, "BottomLeft"),
    c.Defaults.DynamicAnchors = function(a) {
        return a.jsPlumbInstance.makeAnchors(["TopCenter", "RightMiddle", "BottomCenter", "LeftMiddle"], a.elementId, a.jsPlumbInstance)
    }
    ,
    c.Anchors.AutoDefault = function(a) {
        var b = a.jsPlumbInstance.makeDynamicAnchor(c.Defaults.DynamicAnchors(a));
        return b.type = "AutoDefault",
        b
    }
    ;
    var f = function(a, b) {
        c.Anchors[a] = function(c) {
            var d = c.jsPlumbInstance.makeAnchor(["Continuous", {
                faces: b
            }], c.elementId, c.jsPlumbInstance);
            return d.type = a,
            d
        }
    };
    c.Anchors.Continuous = function(a) {
        return a.jsPlumbInstance.continuousAnchorFactory.get(a)
    }
    ,
    f("ContinuousLeft", ["left"]),
    f("ContinuousTop", ["top"]),
    f("ContinuousBottom", ["bottom"]),
    f("ContinuousRight", ["right"]),
    e(0, 0, 0, 0, "Assign", function(a, b) {
        var c = b.position || "Fixed";
        a.positionFinder = c.constructor === String ? b.jsPlumbInstance.AnchorPositionFinders[c] : c,
        a.constructorParams = b
    }),
    a.jsPlumbInstance.prototype.AnchorPositionFinders = {
        Fixed: function(a, b, c) {
            return [(a.left - b.left) / c[0], (a.top - b.top) / c[1]]
        },
        Grid: function(a, b, c, d) {
            var e = a.left - b.left
              , f = a.top - b.top
              , g = c[0] / d.grid[0]
              , h = c[1] / d.grid[1]
              , i = Math.floor(e / g)
              , j = Math.floor(f / h);
            return [(i * g + g / 2) / c[0], (j * h + h / 2) / c[1]]
        }
    },
    c.Anchors.Perimeter = function(a) {
        a = a || {};
        var b = a.anchorCount || 60
          , c = a.shape;
        if (!c)
            throw new Error("no shape supplied to Perimeter Anchor type");
        var d = function() {
            for (var a = .5, c = 2 * Math.PI / b, d = 0, e = [], f = 0; f < b; f++) {
                var g = a + a * Math.sin(d)
                  , h = a + a * Math.cos(d);
                e.push([g, h, 0, 0]),
                d += c
            }
            return e
        }
          , e = function(a) {
            for (var c = b / a.length, d = [], e = function(a, e, f, g, h) {
                c = b * h;
                for (var i = (f - a) / c, j = (g - e) / c, k = 0; k < c; k++)
                    d.push([a + i * k, e + j * k, 0, 0])
            }, f = 0; f < a.length; f++)
                e.apply(null, a[f]);
            return d
        }
          , f = function(a) {
            for (var b = [], c = 0; c < a.length; c++)
                b.push([a[c][0], a[c][1], a[c][2], a[c][3], 1 / a.length]);
            return e(b)
        }
          , g = function() {
            return f([[0, 0, 1, 0], [1, 0, 1, 1], [1, 1, 0, 1], [0, 1, 0, 0]])
        }
          , h = {
            Circle: d,
            Ellipse: d,
            Diamond: function() {
                return f([[.5, 0, 1, .5], [1, .5, .5, 1], [.5, 1, 0, .5], [0, .5, .5, 0]])
            },
            Rectangle: g,
            Square: g,
            Triangle: function() {
                return f([[.5, 0, 1, 1], [1, 1, 0, 1], [0, 1, .5, 0]])
            },
            Path: function(a) {
                for (var b = a.points, c = [], d = 0, f = 0; f < b.length - 1; f++) {
                    var g = Math.sqrt(Math.pow(b[f][2] - b[f][0]) + Math.pow(b[f][3] - b[f][1]));
                    d += g,
                    c.push([b[f][0], b[f][1], b[f + 1][0], b[f + 1][1], g])
                }
                for (var h = 0; h < c.length; h++)
                    c[h][4] = c[h][4] / d;
                return e(c)
            }
        }
          , i = function(a, b) {
            for (var c = [], d = b / 180 * Math.PI, e = 0; e < a.length; e++) {
                var f = a[e][0] - .5
                  , g = a[e][1] - .5;
                c.push([.5 + (f * Math.cos(d) - g * Math.sin(d)), .5 + (f * Math.sin(d) + g * Math.cos(d)), a[e][2], a[e][3]])
            }
            return c
        };
        if (!h[c])
            throw new Error("Shape [" + c + "] is unknown by Perimeter Anchor type");
        var j = h[c](a);
        a.rotation && (j = i(j, a.rotation));
        var k = a.jsPlumbInstance.makeDynamicAnchor(j);
        return k.type = "Perimeter",
        k
    }
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumb
      , c = a.jsPlumbUtil
      , d = a.Biltong;
    b.Segments = {
        AbstractSegment: function(a) {
            this.params = a,
            this.findClosestPointOnPath = function(a, b) {
                return {
                    d: 1 / 0,
                    x: null,
                    y: null,
                    l: null
                }
            }
            ,
            this.getBounds = function() {
                return {
                    minX: Math.min(a.x1, a.x2),
                    minY: Math.min(a.y1, a.y2),
                    maxX: Math.max(a.x1, a.x2),
                    maxY: Math.max(a.y1, a.y2)
                }
            }
        },
        Straight: function(a) {
            var c, e, f, g, h, i, j, k = (b.Segments.AbstractSegment.apply(this, arguments),
            function() {
                c = Math.sqrt(Math.pow(h - g, 2) + Math.pow(j - i, 2)),
                e = d.gradient({
                    x: g,
                    y: i
                }, {
                    x: h,
                    y: j
                }),
                f = -1 / e
            }
            );
            this.type = "Straight",
            this.getLength = function() {
                return c
            }
            ,
            this.getGradient = function() {
                return e
            }
            ,
            this.getCoordinates = function() {
                return {
                    x1: g,
                    y1: i,
                    x2: h,
                    y2: j
                }
            }
            ,
            this.setCoordinates = function(a) {
                g = a.x1,
                i = a.y1,
                h = a.x2,
                j = a.y2,
                k()
            }
            ,
            this.setCoordinates({
                x1: a.x1,
                y1: a.y1,
                x2: a.x2,
                y2: a.y2
            }),
            this.getBounds = function() {
                return {
                    minX: Math.min(g, h),
                    minY: Math.min(i, j),
                    maxX: Math.max(g, h),
                    maxY: Math.max(i, j)
                }
            }
            ,
            this.pointOnPath = function(a, b) {
                if (0 !== a || b) {
                    if (1 !== a || b) {
                        var e = b ? a > 0 ? a : c + a : a * c;
                        return d.pointOnLine({
                            x: g,
                            y: i
                        }, {
                            x: h,
                            y: j
                        }, e)
                    }
                    return {
                        x: h,
                        y: j
                    }
                }
                return {
                    x: g,
                    y: i
                }
            }
            ,
            this.gradientAtPoint = function(a) {
                return e
            }
            ,
            this.pointAlongPathFrom = function(a, b, c) {
                var e = this.pointOnPath(a, c)
                  , f = b <= 0 ? {
                    x: g,
                    y: i
                } : {
                    x: h,
                    y: j
                };
                return b <= 0 && Math.abs(b) > 1 && (b *= -1),
                d.pointOnLine(e, f, b)
            }
            ;
            var l = function(a, b, c) {
                return c >= Math.min(a, b) && c <= Math.max(a, b)
            }
              , m = function(a, b, c) {
                return Math.abs(c - a) < Math.abs(c - b) ? a : b
            };
            this.findClosestPointOnPath = function(a, b) {
                var k = {
                    d: 1 / 0,
                    x: null,
                    y: null,
                    l: null,
                    x1: g,
                    x2: h,
                    y1: i,
                    y2: j
                };
                if (0 === e)
                    k.y = i,
                    k.x = l(g, h, a) ? a : m(g, h, a);
                else if (e === 1 / 0 || e === -(1 / 0))
                    k.x = g,
                    k.y = l(i, j, b) ? b : m(i, j, b);
                else {
                    var n = i - e * g
                      , o = b - f * a
                      , p = (o - n) / (e - f)
                      , q = e * p + n;
                    k.x = l(g, h, p) ? p : m(g, h, p),
                    k.y = l(i, j, q) ? q : m(i, j, q)
                }
                var r = d.lineLength([k.x, k.y], [g, i]);
                return k.d = d.lineLength([a, b], [k.x, k.y]),
                k.l = r / c,
                k
            }
        },
        Arc: function(a) {
            var c = (b.Segments.AbstractSegment.apply(this, arguments),
            function(b, c) {
                return d.theta([a.cx, a.cy], [b, c])
            }
            )
              , e = function(a, b) {
                if (a.anticlockwise) {
                    var c = a.startAngle < a.endAngle ? a.startAngle + f : a.startAngle
                      , d = Math.abs(c - a.endAngle);
                    return c - d * b
                }
                var e = a.endAngle < a.startAngle ? a.endAngle + f : a.endAngle
                  , g = Math.abs(e - a.startAngle);
                return a.startAngle + g * b
            }
              , f = 2 * Math.PI;
            this.radius = a.r,
            this.anticlockwise = a.ac,
            this.type = "Arc",
            a.startAngle && a.endAngle ? (this.startAngle = a.startAngle,
            this.endAngle = a.endAngle,
            this.x1 = a.cx + this.radius * Math.cos(a.startAngle),
            this.y1 = a.cy + this.radius * Math.sin(a.startAngle),
            this.x2 = a.cx + this.radius * Math.cos(a.endAngle),
            this.y2 = a.cy + this.radius * Math.sin(a.endAngle)) : (this.startAngle = c(a.x1, a.y1),
            this.endAngle = c(a.x2, a.y2),
            this.x1 = a.x1,
            this.y1 = a.y1,
            this.x2 = a.x2,
            this.y2 = a.y2),
            this.endAngle < 0 && (this.endAngle += f),
            this.startAngle < 0 && (this.startAngle += f);
            var g = this.endAngle < this.startAngle ? this.endAngle + f : this.endAngle;
            this.sweep = Math.abs(g - this.startAngle),
            this.anticlockwise && (this.sweep = f - this.sweep);
            var h = 2 * Math.PI * this.radius
              , i = this.sweep / f
              , j = h * i;
            this.getLength = function() {
                return j
            }
            ,
            this.getBounds = function() {
                return {
                    minX: a.cx - a.r,
                    maxX: a.cx + a.r,
                    minY: a.cy - a.r,
                    maxY: a.cy + a.r
                }
            }
            ;
            var k = 1e-10
              , l = function(a) {
                var b = Math.floor(a)
                  , c = Math.ceil(a);
                return a - b < k ? b : c - a < k ? c : a
            };
            this.pointOnPath = function(b, c) {
                if (0 === b)
                    return {
                        x: this.x1,
                        y: this.y1,
                        theta: this.startAngle
                    };
                if (1 === b)
                    return {
                        x: this.x2,
                        y: this.y2,
                        theta: this.endAngle
                    };
                c && (b /= j);
                var d = e(this, b)
                  , f = a.cx + a.r * Math.cos(d)
                  , g = a.cy + a.r * Math.sin(d);
                return {
                    x: l(f),
                    y: l(g),
                    theta: d
                }
            }
            ,
            this.gradientAtPoint = function(b, c) {
                var e = this.pointOnPath(b, c)
                  , f = d.normal([a.cx, a.cy], [e.x, e.y]);
                return this.anticlockwise || f !== 1 / 0 && f !== -(1 / 0) || (f *= -1),
                f
            }
            ,
            this.pointAlongPathFrom = function(b, c, d) {
                var e = this.pointOnPath(b, d)
                  , f = c / h * 2 * Math.PI
                  , g = this.anticlockwise ? -1 : 1
                  , i = e.theta + g * f
                  , j = a.cx + this.radius * Math.cos(i)
                  , k = a.cy + this.radius * Math.sin(i);
                return {
                    x: j,
                    y: k
                }
            }
        },
        Bezier: function(c) {
            this.curve = [{
                x: c.x1,
                y: c.y1
            }, {
                x: c.cp1x,
                y: c.cp1y
            }, {
                x: c.cp2x,
                y: c.cp2y
            }, {
                x: c.x2,
                y: c.y2
            }];
            b.Segments.AbstractSegment.apply(this, arguments);
            this.bounds = {
                minX: Math.min(c.x1, c.x2, c.cp1x, c.cp2x),
                minY: Math.min(c.y1, c.y2, c.cp1y, c.cp2y),
                maxX: Math.max(c.x1, c.x2, c.cp1x, c.cp2x),
                maxY: Math.max(c.y1, c.y2, c.cp1y, c.cp2y)
            },
            this.type = "Bezier";
            var d = function(b, c, d) {
                return d && (c = a.jsBezier.locationAlongCurveFrom(b, c > 0 ? 0 : 1, c)),
                c
            };
            this.pointOnPath = function(b, c) {
                return b = d(this.curve, b, c),
                a.jsBezier.pointOnCurve(this.curve, b)
            }
            ,
            this.gradientAtPoint = function(b, c) {
                return b = d(this.curve, b, c),
                a.jsBezier.gradientAtPoint(this.curve, b)
            }
            ,
            this.pointAlongPathFrom = function(b, c, e) {
                return b = d(this.curve, b, e),
                a.jsBezier.pointAlongCurveFrom(this.curve, b, c)
            }
            ,
            this.getLength = function() {
                return a.jsBezier.getLength(this.curve)
            }
            ,
            this.getBounds = function() {
                return this.bounds
            }
        }
    },
    b.SegmentRenderer = {
        getPath: function(a) {
            return {
                Straight: function() {
                    var b = a.getCoordinates();
                    return "M " + b.x1 + " " + b.y1 + " L " + b.x2 + " " + b.y2
                },
                Bezier: function() {
                    var b = a.params;
                    return "M " + b.x1 + " " + b.y1 + " C " + b.cp1x + " " + b.cp1y + " " + b.cp2x + " " + b.cp2y + " " + b.x2 + " " + b.y2
                },
                Arc: function() {
                    var b = a.params
                      , c = a.sweep > Math.PI ? 1 : 0
                      , d = a.anticlockwise ? 0 : 1;
                    return "M" + a.x1 + " " + a.y1 + " A " + a.radius + " " + b.r + " 0 " + c + "," + d + " " + a.x2 + " " + a.y2
                }
            }[a.type]()
        }
    };
    var e = function() {
        this.resetBounds = function() {
            this.bounds = {
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -(1 / 0),
                maxY: -(1 / 0)
            }
        }
        ,
        this.resetBounds()
    };
    b.Connectors.AbstractConnector = function(a) {
        e.apply(this, arguments);
        var f = []
          , g = 0
          , h = []
          , i = []
          , j = a.stub || 0
          , k = c.isArray(j) ? j[0] : j
          , l = c.isArray(j) ? j[1] : j
          , m = a.gap || 0
          , n = c.isArray(m) ? m[0] : m
          , o = c.isArray(m) ? m[1] : m
          , p = null
          , q = !1
          , r = null
          , s = null
          , t = a.editable !== !1 && null != b.ConnectorEditors && null != b.ConnectorEditors[this.type]
          , u = this.setGeometry = function(a, b) {
            q = !b,
            s = a
        }
          , v = this.getGeometry = function() {
            return s
        }
        ;
        this.getPathData = function() {
            for (var a = "", c = 0; c < f.length; c++)
                a += b.SegmentRenderer.getPath(f[c]),
                a += " ";
            return a
        }
        ,
        this.hasBeenEdited = function() {
            return q
        }
        ,
        this.isEditing = function() {
            return null != this.editor && this.editor.isActive()
        }
        ,
        this.setEditable = function(a) {
            return t = !(!a || null == b.ConnectorEditors || null == b.ConnectorEditors[this.type] || null != this.overrideSetEditable && !this.overrideSetEditable()) && a
        }
        ,
        this.isEditable = function() {
            return t
        }
        ,
        this.findSegmentForPoint = function(a, b) {
            for (var c = {
                d: 1 / 0,
                s: null,
                x: null,
                y: null,
                l: null
            }, d = 0; d < f.length; d++) {
                var e = f[d].findClosestPointOnPath(a, b);
                e.d < c.d && (c.d = e.d,
                c.l = e.l,
                c.x = e.x,
                c.y = e.y,
                c.s = f[d],
                c.x1 = e.x1,
                c.x2 = e.x2,
                c.y1 = e.y1,
                c.y2 = e.y2,
                c.index = d)
            }
            return c
        }
        ;
        var w = function() {
            for (var a = 0, b = 0; b < f.length; b++) {
                var c = f[b].getLength();
                i[b] = c / g,
                h[b] = [a, a += c / g]
            }
        }
          , x = function(a, b) {
            b && (a = a > 0 ? a / g : (g + a) / g);
            for (var c = h.length - 1, d = 1, e = 0; e < h.length; e++)
                if (h[e][1] >= a) {
                    c = e,
                    d = 1 === a ? 1 : 0 === a ? 0 : (a - h[e][0]) / i[e];
                    break
                }
            return {
                segment: f[c],
                proportion: d,
                index: c
            }
        }
          , y = function(a, c, d) {
            if (d.x1 !== d.x2 || d.y1 !== d.y2) {
                var e = new b.Segments[c](d);
                f.push(e),
                g += e.getLength(),
                a.updateBounds(e)
            }
        }
          , z = function() {
            g = f.length = h.length = i.length = 0
        };
        this.setSegments = function(a) {
            p = [],
            g = 0;
            for (var b = 0; b < a.length; b++)
                p.push(a[b]),
                g += a[b].getLength()
        }
        ,
        this.getLength = function() {
            return g
        }
        ;
        var A = function(a) {
            this.strokeWidth = a.strokeWidth;
            var b = d.quadrant(a.sourcePos, a.targetPos)
              , c = a.targetPos[0] < a.sourcePos[0]
              , e = a.targetPos[1] < a.sourcePos[1]
              , f = a.strokeWidth || 1
              , g = a.sourceEndpoint.anchor.getOrientation(a.sourceEndpoint)
              , h = a.targetEndpoint.anchor.getOrientation(a.targetEndpoint)
              , i = c ? a.targetPos[0] : a.sourcePos[0]
              , j = e ? a.targetPos[1] : a.sourcePos[1]
              , m = Math.abs(a.targetPos[0] - a.sourcePos[0])
              , p = Math.abs(a.targetPos[1] - a.sourcePos[1]);
            if (0 === g[0] && 0 === g[1] || 0 === h[0] && 0 === h[1]) {
                var q = m > p ? 0 : 1
                  , r = [1, 0][q];
                g = [],
                h = [],
                g[q] = a.sourcePos[q] > a.targetPos[q] ? -1 : 1,
                h[q] = a.sourcePos[q] > a.targetPos[q] ? 1 : -1,
                g[r] = 0,
                h[r] = 0
            }
            var s = c ? m + n * g[0] : n * g[0]
              , t = e ? p + n * g[1] : n * g[1]
              , u = c ? o * h[0] : m + o * h[0]
              , v = e ? o * h[1] : p + o * h[1]
              , w = g[0] * h[0] + g[1] * h[1]
              , x = {
                sx: s,
                sy: t,
                tx: u,
                ty: v,
                lw: f,
                xSpan: Math.abs(u - s),
                ySpan: Math.abs(v - t),
                mx: (s + u) / 2,
                my: (t + v) / 2,
                so: g,
                to: h,
                x: i,
                y: j,
                w: m,
                h: p,
                segment: b,
                startStubX: s + g[0] * k,
                startStubY: t + g[1] * k,
                endStubX: u + h[0] * l,
                endStubY: v + h[1] * l,
                isXGreaterThanStubTimes2: Math.abs(s - u) > k + l,
                isYGreaterThanStubTimes2: Math.abs(t - v) > k + l,
                opposite: w === -1,
                perpendicular: 0 === w,
                orthogonal: 1 === w,
                sourceAxis: 0 === g[0] ? "y" : "x",
                points: [i, j, m, p, s, t, u, v]
            };
            return x.anchorOrientation = x.opposite ? "opposite" : x.orthogonal ? "orthogonal" : "perpendicular",
            x
        };
        this.getSegments = function() {
            return f
        }
        ,
        this.updateBounds = function(a) {
            var b = a.getBounds();
            this.bounds.minX = Math.min(this.bounds.minX, b.minX),
            this.bounds.maxX = Math.max(this.bounds.maxX, b.maxX),
            this.bounds.minY = Math.min(this.bounds.minY, b.minY),
            this.bounds.maxY = Math.max(this.bounds.maxY, b.maxY)
        }
        ;
        return this.pointOnPath = function(a, b) {
            var c = x(a, b);
            return c.segment && c.segment.pointOnPath(c.proportion, !1) || [0, 0]
        }
        ,
        this.gradientAtPoint = function(a, b) {
            var c = x(a, b);
            return c.segment && c.segment.gradientAtPoint(c.proportion, !1) || 0
        }
        ,
        this.pointAlongPathFrom = function(a, b, c) {
            var d = x(a, c);
            return d.segment && d.segment.pointAlongPathFrom(d.proportion, b, !1) || [0, 0]
        }
        ,
        this.compute = function(a) {
            r = A.call(this, a),
            z(),
            this._compute(r, a),
            this.x = r.points[0],
            this.y = r.points[1],
            this.w = r.points[2],
            this.h = r.points[3],
            this.segment = r.segment,
            w()
        }
        ,
        {
            addSegment: y,
            prepareCompute: A,
            sourceStub: k,
            targetStub: l,
            maxStub: Math.max(k, l),
            sourceGap: n,
            targetGap: o,
            maxGap: Math.max(n, o),
            setGeometry: u,
            getGeometry: v
        }
    }
    ,
    c.extend(b.Connectors.AbstractConnector, e),
    b.Endpoints.AbstractEndpoint = function(a) {
        e.apply(this, arguments);
        var b = this.compute = function(a, b, c, d) {
            var e = this._compute.apply(this, arguments);
            return this.x = e[0],
            this.y = e[1],
            this.w = e[2],
            this.h = e[3],
            this.bounds.minX = this.x,
            this.bounds.minY = this.y,
            this.bounds.maxX = this.x + this.w,
            this.bounds.maxY = this.y + this.h,
            e
        }
        ;
        return {
            compute: b,
            cssClass: a.cssClass
        }
    }
    ,
    c.extend(b.Endpoints.AbstractEndpoint, e),
    b.Endpoints.Dot = function(a) {
        this.type = "Dot";
        b.Endpoints.AbstractEndpoint.apply(this, arguments);
        a = a || {},
        this.radius = a.radius || 10,
        this.defaultOffset = .5 * this.radius,
        this.defaultInnerRadius = this.radius / 3,
        this._compute = function(a, b, c, d) {
            this.radius = c.radius || this.radius;
            var e = a[0] - this.radius
              , f = a[1] - this.radius
              , g = 2 * this.radius
              , h = 2 * this.radius;
            if (c.stroke) {
                var i = c.strokeWidth || 1;
                e -= i,
                f -= i,
                g += 2 * i,
                h += 2 * i
            }
            return [e, f, g, h, this.radius]
        }
    }
    ,
    c.extend(b.Endpoints.Dot, b.Endpoints.AbstractEndpoint),
    b.Endpoints.Rectangle = function(a) {
        this.type = "Rectangle";
        b.Endpoints.AbstractEndpoint.apply(this, arguments);
        a = a || {},
        this.width = a.width || 20,
        this.height = a.height || 20,
        this._compute = function(a, b, c, d) {
            var e = c.width || this.width
              , f = c.height || this.height
              , g = a[0] - e / 2
              , h = a[1] - f / 2;
            return [g, h, e, f]
        }
    }
    ,
    c.extend(b.Endpoints.Rectangle, b.Endpoints.AbstractEndpoint);
    var f = function(a) {
        b.jsPlumbUIComponent.apply(this, arguments),
        this._jsPlumb.displayElements = []
    };
    c.extend(f, b.jsPlumbUIComponent, {
        getDisplayElements: function() {
            return this._jsPlumb.displayElements
        },
        appendDisplayElement: function(a) {
            this._jsPlumb.displayElements.push(a)
        }
    }),
    b.Endpoints.Image = function(d) {
        this.type = "Image",
        f.apply(this, arguments),
        b.Endpoints.AbstractEndpoint.apply(this, arguments);
        var e = d.onload
          , g = d.src || d.url
          , h = d.cssClass ? " " + d.cssClass : "";
        this._jsPlumb.img = new Image,
        this._jsPlumb.ready = !1,
        this._jsPlumb.initialized = !1,
        this._jsPlumb.deleted = !1,
        this._jsPlumb.widthToUse = d.width,
        this._jsPlumb.heightToUse = d.height,
        this._jsPlumb.endpoint = d.endpoint,
        this._jsPlumb.img.onload = function() {
            null != this._jsPlumb && (this._jsPlumb.ready = !0,
            this._jsPlumb.widthToUse = this._jsPlumb.widthToUse || this._jsPlumb.img.width,
            this._jsPlumb.heightToUse = this._jsPlumb.heightToUse || this._jsPlumb.img.height,
            e && e(this))
        }
        .bind(this),
        this._jsPlumb.endpoint.setImage = function(a, b) {
            var c = a.constructor === String ? a : a.src;
            e = b,
            this._jsPlumb.img.src = c,
            null != this.canvas && this.canvas.setAttribute("src", this._jsPlumb.img.src)
        }
        .bind(this),
        this._jsPlumb.endpoint.setImage(g, e),
        this._compute = function(a, b, c, d) {
            return this.anchorPoint = a,
            this._jsPlumb.ready ? [a[0] - this._jsPlumb.widthToUse / 2, a[1] - this._jsPlumb.heightToUse / 2, this._jsPlumb.widthToUse, this._jsPlumb.heightToUse] : [0, 0, 0, 0]
        }
        ,
        this.canvas = b.createElement("img", {
            position: "absolute",
            margin: 0,
            padding: 0,
            outline: 0
        }, this._jsPlumb.instance.endpointClass + h),
        this._jsPlumb.widthToUse && this.canvas.setAttribute("width", this._jsPlumb.widthToUse),
        this._jsPlumb.heightToUse && this.canvas.setAttribute("height", this._jsPlumb.heightToUse),
        this._jsPlumb.instance.appendElement(this.canvas),
        this.actuallyPaint = function(a, b, d) {
            if (!this._jsPlumb.deleted) {
                this._jsPlumb.initialized || (this.canvas.setAttribute("src", this._jsPlumb.img.src),
                this.appendDisplayElement(this.canvas),
                this._jsPlumb.initialized = !0);
                var e = this.anchorPoint[0] - this._jsPlumb.widthToUse / 2
                  , f = this.anchorPoint[1] - this._jsPlumb.heightToUse / 2;
                c.sizeElement(this.canvas, e, f, this._jsPlumb.widthToUse, this._jsPlumb.heightToUse)
            }
        }
        ,
        this.paint = function(b, c) {
            null != this._jsPlumb && (this._jsPlumb.ready ? this.actuallyPaint(b, c) : a.setTimeout(function() {
                this.paint(b, c)
            }
            .bind(this), 200))
        }
    }
    ,
    c.extend(b.Endpoints.Image, [f, b.Endpoints.AbstractEndpoint], {
        cleanup: function(a) {
            a && (this._jsPlumb.deleted = !0,
            this.canvas && this.canvas.parentNode.removeChild(this.canvas),
            this.canvas = null)
        }
    }),
    b.Endpoints.Blank = function(a) {
        b.Endpoints.AbstractEndpoint.apply(this, arguments);
        this.type = "Blank",
        f.apply(this, arguments),
        this._compute = function(a, b, c, d) {
            return [a[0], a[1], 10, 0]
        }
        ;
        var d = a.cssClass ? " " + a.cssClass : "";
        this.canvas = b.createElement("div", {
            display: "block",
            width: "1px",
            height: "1px",
            background: "transparent",
            position: "absolute"
        }, this._jsPlumb.instance.endpointClass + d),
        this._jsPlumb.instance.appendElement(this.canvas),
        this.paint = function(a, b) {
            c.sizeElement(this.canvas, this.x, this.y, this.w, this.h)
        }
    }
    ,
    c.extend(b.Endpoints.Blank, [b.Endpoints.AbstractEndpoint, f], {
        cleanup: function() {
            this.canvas && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas)
        }
    }),
    b.Endpoints.Triangle = function(a) {
        this.type = "Triangle",
        b.Endpoints.AbstractEndpoint.apply(this, arguments);
        var c = this;
        a = a || {},
        a.width = a.width || 55,
        a.height = a.height || 55,
        this.width = a.width,
        this.height = a.height,
        this._compute = function(a, b, d, e) {
            var f = d.width || c.width
              , g = d.height || c.height
              , h = a[0] - f / 2
              , i = a[1] - g / 2;
            return [h, i, f, g]
        }
    }
    ;
    var g = b.Overlays.AbstractOverlay = function(a) {
        this.visible = !0,
        this.isAppendedAtTopLevel = !0,
        this.component = a.component,
        this.loc = null == a.location ? .5 : a.location,
        this.endpointLoc = null == a.endpointLocation ? [.5, .5] : a.endpointLocation,
        this.visible = a.visible !== !1
    }
    ;
    g.prototype = {
        cleanup: function(a) {
            a && (this.component = null,
            this.canvas = null,
            this.endpointLoc = null)
        },
        reattach: function(a) {},
        setVisible: function(a) {
            this.visible = a,
            this.component.repaint()
        },
        isVisible: function() {
            return this.visible
        },
        hide: function() {
            this.setVisible(!1)
        },
        show: function() {
            this.setVisible(!0)
        },
        incrementLocation: function(a) {
            this.loc += a,
            this.component.repaint()
        },
        setLocation: function(a) {
            this.loc = a,
            this.component.repaint()
        },
        getLocation: function() {
            return this.loc
        },
        updateFrom: function() {}
    },
    b.Overlays.Arrow = function(a) {
        this.type = "Arrow",
        g.apply(this, arguments),
        this.isAppendedAtTopLevel = !1,
        a = a || {};
        var e = this;
        this.length = a.length || 20,
        this.width = a.width || 20,
        this.id = a.id;
        var f = (a.direction || 1) < 0 ? -1 : 1
          , h = a.paintStyle || {
            "stroke-width": 1
        }
          , i = a.foldback || .623;
        this.computeMaxSize = function() {
            return 1.5 * e.width
        }
        ,
        this.elementCreated = function(c, d) {
            if (this.path = c,
            a.events)
                for (var e in a.events)
                    b.on(c, e, a.events[e])
        }
        ,
        this.draw = function(a, b) {
            var e, g, j, k, l;
            if (a.pointAlongPathFrom) {
                if (c.isString(this.loc) || this.loc > 1 || this.loc < 0) {
                    var m = parseInt(this.loc, 10)
                      , n = this.loc < 0 ? 1 : 0;
                    e = a.pointAlongPathFrom(n, m, !1),
                    g = a.pointAlongPathFrom(n, m - f * this.length / 2, !1),
                    j = d.pointOnLine(e, g, this.length)
                } else if (1 === this.loc) {
                    if (e = a.pointOnPath(this.loc),
                    g = a.pointAlongPathFrom(this.loc, -this.length),
                    j = d.pointOnLine(e, g, this.length),
                    f === -1) {
                        var o = j;
                        j = e,
                        e = o
                    }
                } else if (0 === this.loc) {
                    if (j = a.pointOnPath(this.loc),
                    g = a.pointAlongPathFrom(this.loc, this.length),
                    e = d.pointOnLine(j, g, this.length),
                    f === -1) {
                        var p = j;
                        j = e,
                        e = p
                    }
                } else
                    e = a.pointAlongPathFrom(this.loc, f * this.length / 2),
                    g = a.pointOnPath(this.loc),
                    j = d.pointOnLine(e, g, this.length);
                k = d.perpendicularLineTo(e, j, this.width),
                l = d.pointOnLine(e, j, i * this.length);
                var q = {
                    hxy: e,
                    tail: k,
                    cxy: l
                }
                  , r = h.stroke || b.stroke
                  , s = h.fill || b.stroke
                  , t = h.strokeWidth || b.strokeWidth;
                return {
                    component: a,
                    d: q,
                    "stroke-width": t,
                    stroke: r,
                    fill: s,
                    minX: Math.min(e.x, k[0].x, k[1].x),
                    maxX: Math.max(e.x, k[0].x, k[1].x),
                    minY: Math.min(e.y, k[0].y, k[1].y),
                    maxY: Math.max(e.y, k[0].y, k[1].y)
                }
            }
            return {
                component: a,
                minX: 0,
                maxX: 0,
                minY: 0,
                maxY: 0
            }
        }
    }
    ,
    c.extend(b.Overlays.Arrow, g, {
        updateFrom: function(a) {
            this.length = a.length || this.length,
            this.width = a.width || this.width,
            this.direction = null != a.direction ? a.direction : this.direction,
            this.foldback = a.foldback || this.foldback
        }
    }),
    b.Overlays.PlainArrow = function(a) {
        a = a || {};
        var c = b.extend(a, {
            foldback: 1
        });
        b.Overlays.Arrow.call(this, c),
        this.type = "PlainArrow"
    }
    ,
    c.extend(b.Overlays.PlainArrow, b.Overlays.Arrow),
    b.Overlays.Diamond = function(a) {
        a = a || {};
        var c = a.length || 40
          , d = b.extend(a, {
            length: c / 2,
            foldback: 2
        });
        b.Overlays.Arrow.call(this, d),
        this.type = "Diamond"
    }
    ,
    c.extend(b.Overlays.Diamond, b.Overlays.Arrow);
    var h = function(a, b) {
        return (null == a._jsPlumb.cachedDimensions || b) && (a._jsPlumb.cachedDimensions = a.getDimensions()),
        a._jsPlumb.cachedDimensions
    }
      , i = function(a) {
        b.jsPlumbUIComponent.apply(this, arguments),
        g.apply(this, arguments);
        var d = this.fire;
        this.fire = function() {
            d.apply(this, arguments),
            this.component && this.component.fire.apply(this.component, arguments)
        }
        ,
        this.detached = !1,
        this.id = a.id,
        this._jsPlumb.div = null,
        this._jsPlumb.initialised = !1,
        this._jsPlumb.component = a.component,
        this._jsPlumb.cachedDimensions = null,
        this._jsPlumb.create = a.create,
        this._jsPlumb.initiallyInvisible = a.visible === !1,
        this.getElement = function() {
            if (null == this._jsPlumb.div) {
                var c = this._jsPlumb.div = b.getElement(this._jsPlumb.create(this._jsPlumb.component));
                c.style.position = "absolute",
                c.className = this._jsPlumb.instance.overlayClass + " " + (this.cssClass ? this.cssClass : a.cssClass ? a.cssClass : ""),
                this._jsPlumb.instance.appendElement(c),
                this._jsPlumb.instance.getId(c),
                this.canvas = c;
                var d = "translate(-50%, -50%)";
                c.style.webkitTransform = d,
                c.style.mozTransform = d,
                c.style.msTransform = d,
                c.style.oTransform = d,
                c.style.transform = d,
                c._jsPlumb = this,
                a.visible === !1 && (c.style.display = "none")
            }
            return this._jsPlumb.div
        }
        ,
        this.draw = function(a, b, d) {
            var e = h(this);
            if (null != e && 2 === e.length) {
                var f = {
                    x: 0,
                    y: 0
                };
                if (d)
                    f = {
                        x: d[0],
                        y: d[1]
                    };
                else if (a.pointOnPath) {
                    var g = this.loc
                      , i = !1;
                    (c.isString(this.loc) || this.loc < 0 || this.loc > 1) && (g = parseInt(this.loc, 10),
                    i = !0),
                    f = a.pointOnPath(g, i)
                } else {
                    var j = this.loc.constructor === Array ? this.loc : this.endpointLoc;
                    f = {
                        x: j[0] * a.w,
                        y: j[1] * a.h
                    }
                }
                var k = f.x - e[0] / 2
                  , l = f.y - e[1] / 2;
                return {
                    component: a,
                    d: {
                        minx: k,
                        miny: l,
                        td: e,
                        cxy: f
                    },
                    minX: k,
                    maxX: k + e[0],
                    minY: l,
                    maxY: l + e[1]
                }
            }
            return {
                minX: 0,
                maxX: 0,
                minY: 0,
                maxY: 0
            }
        }
    };
    c.extend(i, [b.jsPlumbUIComponent, g], {
        getDimensions: function() {
            return [1, 1]
        },
        setVisible: function(a) {
            this._jsPlumb.div && (this._jsPlumb.div.style.display = a ? "block" : "none",
            a && this._jsPlumb.initiallyInvisible && (h(this, !0),
            this.component.repaint(),
            this._jsPlumb.initiallyInvisible = !1))
        },
        clearCachedDimensions: function() {
            this._jsPlumb.cachedDimensions = null
        },
        cleanup: function(a) {
            a ? null != this._jsPlumb.div && (this._jsPlumb.div._jsPlumb = null,
            this._jsPlumb.instance.removeElement(this._jsPlumb.div)) : (this._jsPlumb && this._jsPlumb.div && this._jsPlumb.div.parentNode && this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div),
            this.detached = !0)
        },
        reattach: function(a) {
            null != this._jsPlumb.div && a.getContainer().appendChild(this._jsPlumb.div),
            this.detached = !1
        },
        computeMaxSize: function() {
            var a = h(this);
            return Math.max(a[0], a[1])
        },
        paint: function(a, b) {
            this._jsPlumb.initialised || (this.getElement(),
            a.component.appendDisplayElement(this._jsPlumb.div),
            this._jsPlumb.initialised = !0,
            this.detached && this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div)),
            this._jsPlumb.div.style.left = a.component.x + a.d.minx + "px",
            this._jsPlumb.div.style.top = a.component.y + a.d.miny + "px"
        }
    }),
    b.Overlays.Custom = function(a) {
        this.type = "Custom",
        i.apply(this, arguments)
    }
    ,
    c.extend(b.Overlays.Custom, i),
    b.Overlays.GuideLines = function() {
        var a = this;
        a.length = 50,
        a.strokeWidth = 5,
        this.type = "GuideLines",
        g.apply(this, arguments),
        b.jsPlumbUIComponent.apply(this, arguments),
        this.draw = function(b, c) {
            var e = b.pointAlongPathFrom(a.loc, a.length / 2)
              , f = b.pointOnPath(a.loc)
              , g = d.pointOnLine(e, f, a.length)
              , h = d.perpendicularLineTo(e, g, 40)
              , i = d.perpendicularLineTo(g, e, 20);
            return {
                connector: b,
                head: e,
                tail: g,
                headLine: i,
                tailLine: h,
                minX: Math.min(e.x, g.x, i[0].x, i[1].x),
                minY: Math.min(e.y, g.y, i[0].y, i[1].y),
                maxX: Math.max(e.x, g.x, i[0].x, i[1].x),
                maxY: Math.max(e.y, g.y, i[0].y, i[1].y)
            }
        }
    }
    ,
    b.Overlays.Label = function(a) {
        this.labelStyle = a.labelStyle;
        this.cssClass = null != this.labelStyle ? this.labelStyle.cssClass : null;
        var c = b.extend({
            create: function() {
                return b.createElement("div")
            }
        }, a);
        if (b.Overlays.Custom.call(this, c),
        this.type = "Label",
        this.label = a.label || "",
        this.labelText = null,
        this.labelStyle) {
            var d = this.getElement();
            if (this.labelStyle.font = this.labelStyle.font || "12px sans-serif",
            d.style.font = this.labelStyle.font,
            d.style.color = this.labelStyle.color || "black",
            this.labelStyle.fill && (d.style.background = this.labelStyle.fill),
            this.labelStyle.borderWidth > 0) {
                var e = this.labelStyle.borderStyle ? this.labelStyle.borderStyle : "black";
                d.style.border = this.labelStyle.borderWidth + "px solid " + e
            }
            this.labelStyle.padding && (d.style.padding = this.labelStyle.padding)
        }
    }
    ,
    c.extend(b.Overlays.Label, b.Overlays.Custom, {
        cleanup: function(a) {
            a && (this.div = null,
            this.label = null,
            this.labelText = null,
            this.cssClass = null,
            this.labelStyle = null)
        },
        getLabel: function() {
            return this.label
        },
        setLabel: function(a) {
            this.label = a,
            this.labelText = null,
            this.clearCachedDimensions(),
            this.update(),
            this.component.repaint()
        },
        getDimensions: function() {
            return this.update(),
            i.prototype.getDimensions.apply(this, arguments)
        },
        update: function() {
            if ("function" == typeof this.label) {
                var a = this.label(this);
                this.getElement().innerHTML = a.replace(/\r\n/g, "<br/>")
            } else
                null == this.labelText && (this.labelText = this.label,
                this.getElement().innerHTML = this.labelText.replace(/\r\n/g, "<br/>"))
        },
        updateFrom: function(a) {
            null != a.label && this.setLabel(a.label)
        }
    })
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumb
      , c = function(b) {
        var c = b._mottle;
        return c || (c = b._mottle = new a.Mottle),
        c
    };
    b.extend(a.jsPlumbInstance.prototype, {
        getEventManager: function() {
            return c(this)
        },
        on: function(a, b, c) {
            return this.getEventManager().on.apply(this, arguments),
            this
        },
        off: function(a, b, c) {
            return this.getEventManager().off.apply(this, arguments),
            this
        }
    })
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumbUtil
      , c = a.jsPlumbInstance
      , d = "jtk-group-collapsed"
      , e = "jtk-group-expanded"
      , f = "[jtk-group-content]"
      , g = "elementDraggable"
      , h = "stop"
      , i = "revert"
      , j = "_groupManager"
      , k = "_jsPlumbGroup"
      , l = "_jsPlumbGroupDrag"
      , m = "group:addMember"
      , n = "group:removeMember"
      , o = "group:add"
      , p = "group:remove"
      , q = "group:expand"
      , r = "group:collapse"
      , s = "groupDragStop"
      , t = "connectionMoved"
      , u = "internal.connectionDetached"
      , v = "removeAll"
      , w = "orphanAll"
      , x = "show"
      , y = "hide"
      , z = function(a) {
        function c(a) {
            delete a.proxies;
            var c, d = i[a.id];
            null != d && (c = function(b) {
                return b.id === a.id
            }
            ,
            b.removeWithFunction(d.connections.source, c),
            b.removeWithFunction(d.connections.target, c),
            delete i[a.id]),
            d = j[a.id],
            null != d && (c = function(b) {
                return b.id === a.id
            }
            ,
            b.removeWithFunction(d.connections.source, c),
            b.removeWithFunction(d.connections.target, c),
            delete j[a.id])
        }
        function f(b, c) {
            for (var d = b.getMembers(), e = 0; e < d.length; e++)
                a[c ? x : y](d[e], !0)
        }
        function g(b) {
            var c = b.getMembers()
              , d = a.getConnections({
                source: c
            }, !0)
              , e = a.getConnections({
                target: c
            }, !0)
              , f = {};
            b.connections.source.length = 0,
            b.connections.target.length = 0;
            var g = function(a) {
                for (var c = 0; c < a.length; c++)
                    f[a[c].id] || (f[a[c].id] = !0,
                    a[c].source._jsPlumbGroup === b ? (a[c].target._jsPlumbGroup !== b && b.connections.source.push(a[c]),
                    i[a[c].id] = b) : a[c].target._jsPlumbGroup === b && (b.connections.target.push(a[c]),
                    j[a[c].id] = b))
            };
            g(d),
            g(e)
        }
        var h = {}
          , i = {}
          , j = {}
          , l = this;
        a.bind("connection", function(a) {
            null != a.source[k] && null != a.target[k] && a.source[k] === a.target[k] ? (i[a.connection.id] = a.source[k],
            j[a.connection.id] = a.source[k]) : (null != a.source[k] && (b.suggest(a.source[k].connections.source, a.connection),
            i[a.connection.id] = a.source[k]),
            null != a.target[k] && (b.suggest(a.target[k].connections.target, a.connection),
            j[a.connection.id] = a.target[k]))
        }),
        a.bind(u, function(a) {
            c(a.connection)
        }),
        a.bind(t, function(a) {
            var b = 0 === a.index ? i : j
              , c = b[a.connection.id];
            if (c) {
                var d = c.connections[0 === a.index ? "source" : "target"]
                  , e = d.indexOf(a.connection);
                e !== -1 && d.splice(e, 1)
            }
        }),
        this.addGroup = function(b) {
            a.addClass(b.getEl(), e),
            h[b.id] = b,
            b.manager = this,
            g(b),
            a.fire(o, {
                group: b
            })
        }
        ,
        this.addToGroup = function(b, c, d) {
            if (b = this.getGroup(b)) {
                var e = b.getEl();
                if (c._isJsPlumbGroup)
                    return;
                var f = c._jsPlumbGroup;
                if (f !== b) {
                    var g = a.getOffset(c, !0)
                      , h = b.collapsed ? a.getOffset(e, !0) : a.getOffset(b.getDragArea(), !0);
                    null != f && (f.remove(c, d),
                    l.updateConnectionsForGroup(f)),
                    b.add(c, d);
                    var i = function(a, c) {
                        var d = 0 === c ? 1 : 0;
                        a.each(function(a) {
                            a.setVisible(!1),
                            a.endpoints[d].element._jsPlumbGroup === b ? (a.endpoints[d].setVisible(!1),
                            l.expandConnection(a, d, b)) : (a.endpoints[c].setVisible(!1),
                            l.collapseConnection(a, c, b))
                        })
                    };
                    b.collapsed && (i(a.select({
                        source: c
                    }), 0),
                    i(a.select({
                        target: c
                    }), 1));
                    var j = a.getId(c);
                    a.dragManager.setParent(c, j, e, a.getId(e), g);
                    var k = {
                        left: g.left - h.left,
                        top: g.top - h.top
                    };
                    a.setPosition(c, k),
                    a.dragManager.revalidateParent(c, j, g),
                    l.updateConnectionsForGroup(b),
                    a.revalidate(j),
                    setTimeout(function() {
                        a.fire(m, {
                            group: b,
                            el: c
                        })
                    }, 0)
                }
            }
        }
        ,
        this.removeFromGroup = function(a, b, c) {
            a = this.getGroup(a),
            a && a.remove(b, null, c)
        }
        ,
        this.getGroup = function(a) {
            var c = a;
            if (b.isString(a) && (c = h[a],
            null == c))
                throw new TypeError("No such group [" + a + "]");
            return c
        }
        ,
        this.getGroups = function() {
            var a = [];
            for (var b in h)
                a.push(h[b]);
            return a
        }
        ,
        this.removeGroup = function(b, c, d, e) {
            b = this.getGroup(b),
            this.expandGroup(b, !0),
            b[c ? v : w](d, e),
            a.remove(b.getEl()),
            delete h[b.id],
            delete a._groups[b.id],
            a.fire(p, {
                group: b
            })
        }
        ,
        this.removeAllGroups = function(a, b, c) {
            for (var d in h)
                this.removeGroup(h[d], a, b, c)
        }
        ;
        var n = this.collapseConnection = function(b, c, d) {
            var e, f = d.getEl(), g = a.getId(f), h = b.endpoints[c].elementId, i = b.endpoints[0 === c ? 1 : 0].element;
            i[k] && !i[k].shouldProxy() && i[k].collapsed || (b.proxies = b.proxies || [],
            e = b.proxies[c] ? b.proxies[c].ep : a.addEndpoint(f, {
                endpoint: d.getEndpoint(b, c),
                anchor: d.getAnchor(b, c),
                parameters: {
                    isProxyEndpoint: !0
                }
            }),
            e.setDeleteOnEmpty(!0),
            b.proxies[c] = {
                ep: e,
                originalEp: b.endpoints[c]
            },
            0 === c ? a.anchorManager.sourceChanged(h, g, b, f) : (a.anchorManager.updateOtherEndpoint(b.endpoints[0].elementId, h, g, b),
            b.target = f,
            b.targetId = g),
            b.proxies[c].originalEp.detachFromConnection(b, null, !0),
            e.connections = [b],
            b.endpoints[c] = e,
            b.setVisible(!0))
        }
        ;
        this.collapseGroup = function(b) {
            if (b = this.getGroup(b),
            null != b && !b.collapsed) {
                var c = b.getEl();
                if (f(b, !1),
                b.shouldProxy()) {
                    var g = function(a, c) {
                        for (var d = 0; d < a.length; d++) {
                            var e = a[d];
                            n(e, c, b)
                        }
                    };
                    g(b.connections.source, 0),
                    g(b.connections.target, 1)
                }
                b.collapsed = !0,
                a.removeClass(c, e),
                a.addClass(c, d),
                a.revalidate(c),
                a.fire(r, {
                    group: b
                })
            }
        }
        ;
        var s = this.expandConnection = function(b, c, d) {
            if (null != b.proxies && null != b.proxies[c]) {
                var e = a.getId(d.getEl())
                  , f = b.proxies[c].originalEp.element
                  , g = b.proxies[c].originalEp.elementId;
                b.endpoints[c] = b.proxies[c].originalEp,
                0 === c ? a.anchorManager.sourceChanged(e, g, b, f) : (a.anchorManager.updateOtherEndpoint(b.endpoints[0].elementId, e, g, b),
                b.target = f,
                b.targetId = g),
                b.proxies[c].ep.detachFromConnection(b, null),
                b.proxies[c].originalEp.addConnection(b),
                delete b.proxies[c]
            }
        }
        ;
        this.expandGroup = function(b, c) {
            if (b = this.getGroup(b),
            null != b && b.collapsed) {
                var g = b.getEl();
                if (f(b, !0),
                b.shouldProxy()) {
                    var h = function(a, c) {
                        for (var d = 0; d < a.length; d++) {
                            var e = a[d];
                            s(e, c, b)
                        }
                    };
                    h(b.connections.source, 0),
                    h(b.connections.target, 1)
                }
                b.collapsed = !1,
                a.addClass(g, e),
                a.removeClass(g, d),
                a.revalidate(g),
                this.repaintGroup(b),
                c || a.fire(q, {
                    group: b
                })
            }
        }
        ,
        this.repaintGroup = function(b) {
            b = this.getGroup(b);
            for (var c = b.getMembers(), d = 0; d < c.length; d++)
                a.revalidate(c[d])
        }
        ,
        this.updateConnectionsForGroup = g,
        this.refreshAllGroups = function() {
            for (var b in h)
                g(h[b]),
                a.dragManager.updateOffsets(a.getId(h[b].getEl()))
        }
    }
      , A = function(c, d) {
        function e(a) {
            return a.offsetParent
        }
        function j(a, b) {
            var d = e(a)
              , f = c.getSize(d)
              , g = c.getSize(a)
              , h = b[0]
              , i = h + g[0]
              , j = b[1]
              , k = j + g[1];
            return i > 0 && h < f[0] && k > 0 && j < f[1]
        }
        function o(a) {
            var b = c.getId(a)
              , d = c.getOffset(a);
            a.parentNode.removeChild(a),
            c.getContainer().appendChild(a),
            c.setPosition(a, d),
            delete a._jsPlumbGroup,
            r(a),
            c.dragManager.clearParent(a, b)
        }
        function p(a) {
            if (!j(a.el, a.pos)) {
                var b = a.el._jsPlumbGroup;
                B ? c.remove(a.el) : o(a.el),
                b.remove(a.el)
            }
        }
        function q(a) {
            var b = c.getId(a);
            c.revalidate(a),
            c.dragManager.revalidateParent(a, b)
        }
        function r(a) {
            a._katavorioDrag && ((B || A) && a._katavorioDrag.off(h, p),
            B || A || !z || (a._katavorioDrag.off(i, q),
            a._katavorioDrag.setRevert(null)))
        }
        function t(a) {
            a._katavorioDrag && ((B || A) && a._katavorioDrag.on(h, p),
            y && a._katavorioDrag.setConstrain(!0),
            x && a._katavorioDrag.setUseGhostProxy(!0),
            B || A || !z || (a._katavorioDrag.on(i, q),
            a._katavorioDrag.setRevert(function(a, b) {
                return !j(a, b)
            })))
        }
        var u = this
          , v = d.el;
        this.getEl = function() {
            return v
        }
        ,
        this.id = d.id || b.uuid(),
        v._isJsPlumbGroup = !0;
        var w = this.getDragArea = function() {
            var a = c.getSelector(v, f);
            return a && a.length > 0 ? a[0] : v
        }
          , x = d.ghost === !0
          , y = x || d.constrain === !0
          , z = d.revert !== !1
          , A = d.orphan === !0
          , B = d.prune === !0
          , C = d.dropOverride === !0
          , D = d.proxied !== !1
          , E = [];
        if (this.connections = {
            source: [],
            target: [],
            internal: []
        },
        this.getAnchor = function(a, b) {
            return d.anchor || "Continuous"
        }
        ,
        this.getEndpoint = function(a, b) {
            return d.endpoint || ["Dot", {
                radius: 10
            }]
        }
        ,
        this.collapsed = !1,
        d.draggable !== !1) {
            var F = {
                stop: function(a) {
                    c.fire(s, jsPlumb.extend(a, {
                        group: u
                    }))
                },
                scope: l
            };
            d.dragOptions && a.jsPlumb.extend(F, d.dragOptions),
            c.draggable(d.el, F)
        }
        d.droppable !== !1 && c.droppable(d.el, {
            drop: function(a) {
                var b = a.drag.el;
                if (!b._isJsPlumbGroup) {
                    var d = b._jsPlumbGroup;
                    if (d !== u) {
                        if (null != d && d.overrideDrop(b, u))
                            return;
                        c.getGroupManager().addToGroup(u, b, !1)
                    }
                }
            }
        });
        var G = function(a, b) {
            for (var c = null == a.nodeType ? a : [a], d = 0; d < c.length; d++)
                b(c[d])
        };
        this.overrideDrop = function(a, b) {
            return C && (z || B || A)
        }
        ,
        this.add = function(a, b) {
            var d = w();
            G(a, function(a) {
                if (null != a._jsPlumbGroup) {
                    if (a._jsPlumbGroup === u)
                        return;
                    a._jsPlumbGroup.remove(a, !0, b, !1)
                }
                a._jsPlumbGroup = u,
                E.push(a),
                c.isAlreadyDraggable(a) && t(a),
                a.parentNode !== d && d.appendChild(a),
                b || c.fire(m, {
                    group: u,
                    el: a
                })
            }),
            c.getGroupManager().updateConnectionsForGroup(u)
        }
        ,
        this.remove = function(a, d, e, f) {
            G(a, function(a) {
                if (delete a._jsPlumbGroup,
                b.removeWithFunction(E, function(b) {
                    return b === a
                }),
                d)
                    try {
                        u.getDragArea().removeChild(a)
                    } catch (a) {
                        jsPlumbUtil.log("Could not remove element from Group " + a)
                    }
                r(a),
                e || c.fire(n, {
                    group: u,
                    el: a
                })
            }),
            f || c.getGroupManager().updateConnectionsForGroup(u)
        }
        ,
        this.removeAll = function(a, b) {
            for (var d = 0, e = E.length; d < e; d++)
                u.remove(E[0], a, b, !0);
            E.length = 0,
            c.getGroupManager().updateConnectionsForGroup(u)
        }
        ,
        this.orphanAll = function() {
            for (var a = 0; a < E.length; a++)
                o(E[a]);
            E.length = 0
        }
        ,
        this.getMembers = function() {
            return E
        }
        ,
        v[k] = this,
        c.bind(g, function(a) {
            a.el._jsPlumbGroup === this && t(a.el)
        }
        .bind(this)),
        this.shouldProxy = function() {
            return D
        }
        ,
        c.getGroupManager().addGroup(this)
    };
    c.prototype.addGroup = function(a) {
        var b = this;
        if (b._groups = b._groups || {},
        null != b._groups[a.id])
            throw new TypeError("cannot create Group [" + a.id + "]; a Group with that ID exists");
        if (null != a.el[k])
            throw new TypeError("cannot create Group [" + a.id + "]; the given element is already a Group");
        var c = new A(b,a);
        return b._groups[c.id] = c,
        a.collapsed && this.collapseGroup(c),
        c
    }
    ,
    c.prototype.addToGroup = function(a, b, c) {
        var d = function(b) {
            var d = this.getId(b);
            this.manage(d, b),
            this.getGroupManager().addToGroup(a, b, c)
        }
        .bind(this);
        if (Array.isArray(b))
            for (var e = 0; e < b.length; e++)
                d(b[e]);
        else
            d(b)
    }
    ,
    c.prototype.removeFromGroup = function(a, b, c) {
        this.getGroupManager().removeFromGroup(a, b, c)
    }
    ,
    c.prototype.removeGroup = function(a, b, c, d) {
        this.getGroupManager().removeGroup(a, b, c, d)
    }
    ,
    c.prototype.removeAllGroups = function(a, b, c) {
        this.getGroupManager().removeAllGroups(a, b, c)
    }
    ,
    c.prototype.getGroup = function(a) {
        return this.getGroupManager().getGroup(a)
    }
    ,
    c.prototype.getGroups = function() {
        return this.getGroupManager().getGroups()
    }
    ,
    c.prototype.expandGroup = function(a) {
        this.getGroupManager().expandGroup(a)
    }
    ,
    c.prototype.collapseGroup = function(a) {
        this.getGroupManager().collapseGroup(a)
    }
    ,
    c.prototype.repaintGroup = function(a) {
        this.getGroupManager().repaintGroup(a)
    }
    ,
    c.prototype.toggleGroup = function(a) {
        a = this.getGroupManager().getGroup(a),
        null != a && this.getGroupManager()[a.collapsed ? "expandGroup" : "collapseGroup"](a)
    }
    ,
    c.prototype.getGroupManager = function() {
        var a = this[j];
        return null == a && (a = this[j] = new z(this)),
        a
    }
    ,
    c.prototype.removeGroupManager = function() {
        delete this[j]
    }
    ,
    c.prototype.getGroupFor = function(a) {
        if (a = this.getElement(a))
            return a[k]
    }
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumb
      , c = a.jsPlumbUtil
      , d = function(a) {
        this.type = "Flowchart",
        a = a || {},
        a.stub = null == a.stub ? 30 : a.stub;
        var c, d, e = b.Connectors.AbstractConnector.apply(this, arguments), f = null == a.midpoint ? .5 : a.midpoint, g = a.alwaysRespectStubs === !0, h = null, i = null, j = null != a.cornerRadius ? a.cornerRadius : 0, k = (a.loopbackRadius || 25,
        function(a) {
            return a < 0 ? -1 : 0 === a ? 0 : 1
        }
        ), l = function(a, b, c, d) {
            if (h !== b || i !== c) {
                var e = null == h ? d.sx : h
                  , f = null == i ? d.sy : i
                  , g = e === b ? "v" : "h"
                  , j = k(b - e)
                  , l = k(c - f);
                h = b,
                i = c,
                a.push([e, f, b, c, g, j, l])
            }
        }, m = function(a) {
            return Math.sqrt(Math.pow(a[0] - a[2], 2) + Math.pow(a[1] - a[3], 2))
        }, n = function(a) {
            var b = [];
            return b.push.apply(b, a),
            b
        }, o = function(a, b, c) {
            for (var d, f = null, g = 0; g < b.length - 1; g++) {
                if (f = f || n(b[g]),
                d = n(b[g + 1]),
                j > 0 && f[4] !== d[4]) {
                    var h = Math.min(j, m(f), m(d));
                    f[2] -= f[5] * h,
                    f[3] -= f[6] * h,
                    d[0] += d[5] * h,
                    d[1] += d[6] * h;
                    var i = f[6] === d[5] && 1 === d[5] || f[6] === d[5] && 0 === d[5] && f[5] !== d[6] || f[6] === d[5] && d[5] === -1
                      , k = d[1] > f[3] ? 1 : -1
                      , l = d[0] > f[2] ? 1 : -1
                      , o = k === l
                      , p = o && i || !o && !i ? d[0] : f[2]
                      , q = o && i || !o && !i ? f[3] : d[1];
                    e.addSegment(a, "Straight", {
                        x1: f[0],
                        y1: f[1],
                        x2: f[2],
                        y2: f[3]
                    }),
                    e.addSegment(a, "Arc", {
                        r: h,
                        x1: f[2],
                        y1: f[3],
                        x2: d[0],
                        y2: d[1],
                        cx: p,
                        cy: q,
                        ac: i
                    })
                } else {
                    var r = f[2] === f[0] ? 0 : f[2] > f[0] ? c.lw / 2 : -(c.lw / 2)
                      , s = f[3] === f[1] ? 0 : f[3] > f[1] ? c.lw / 2 : -(c.lw / 2);
                    e.addSegment(a, "Straight", {
                        x1: f[0] - r,
                        y1: f[1] - s,
                        x2: f[2] + r,
                        y2: f[3] + s
                    })
                }
                f = d
            }
            null != d && e.addSegment(a, "Straight", {
                x1: d[0],
                y1: d[1],
                x2: d[2],
                y2: d[3]
            })
        };
        this._compute = function(a, b) {
            c = [],
            h = null,
            i = null,
            d = null;
            var j = function() {
                return [a.startStubX, a.startStubY, a.endStubX, a.endStubY]
            }
              , k = {
                perpendicular: j,
                orthogonal: j,
                opposite: function(b) {
                    var c = a
                      , d = "x" === b ? 0 : 1
                      , e = {
                        x: function() {
                            return 1 === c.so[d] && (c.startStubX > c.endStubX && c.tx > c.startStubX || c.sx > c.endStubX && c.tx > c.sx) || c.so[d] === -1 && (c.startStubX < c.endStubX && c.tx < c.startStubX || c.sx < c.endStubX && c.tx < c.sx)
                        },
                        y: function() {
                            return 1 === c.so[d] && (c.startStubY > c.endStubY && c.ty > c.startStubY || c.sy > c.endStubY && c.ty > c.sy) || c.so[d] === -1 && (c.startStubY < c.endStubY && c.ty < c.startStubY || c.sy < c.endStubY && c.ty < c.sy)
                        }
                    };
                    return !g && e[b]() ? {
                        x: [(a.sx + a.tx) / 2, a.startStubY, (a.sx + a.tx) / 2, a.endStubY],
                        y: [a.startStubX, (a.sy + a.ty) / 2, a.endStubX, (a.sy + a.ty) / 2]
                    }[b] : [a.startStubX, a.startStubY, a.endStubX, a.endStubY]
                }
            }
              , m = k[a.anchorOrientation](a.sourceAxis)
              , n = "x" === a.sourceAxis ? 0 : 1
              , p = "x" === a.sourceAxis ? 1 : 0
              , q = m[n]
              , r = m[p]
              , s = m[n + 2]
              , t = m[p + 2];
            l(c, m[0], m[1], a);
            var u = a.startStubX + (a.endStubX - a.startStubX) * f
              , v = a.startStubY + (a.endStubY - a.startStubY) * f
              , w = {
                x: [0, 1],
                y: [1, 0]
            }
              , x = {
                perpendicular: function(b) {
                    var c = a
                      , d = {
                        x: [[[1, 2, 3, 4], null, [2, 1, 4, 3]], null, [[4, 3, 2, 1], null, [3, 4, 1, 2]]],
                        y: [[[3, 2, 1, 4], null, [2, 3, 4, 1]], null, [[4, 1, 2, 3], null, [1, 4, 3, 2]]]
                    }
                      , e = {
                        x: [[c.startStubX, c.endStubX], null, [c.endStubX, c.startStubX]],
                        y: [[c.startStubY, c.endStubY], null, [c.endStubY, c.startStubY]]
                    }
                      , f = {
                        x: [[u, c.startStubY], [u, c.endStubY]],
                        y: [[c.startStubX, v], [c.endStubX, v]]
                    }
                      , g = {
                        x: [[c.endStubX, c.startStubY]],
                        y: [[c.startStubX, c.endStubY]]
                    }
                      , h = {
                        x: [[c.startStubX, c.endStubY], [c.endStubX, c.endStubY]],
                        y: [[c.endStubX, c.startStubY], [c.endStubX, c.endStubY]]
                    }
                      , i = {
                        x: [[c.startStubX, v], [c.endStubX, v], [c.endStubX, c.endStubY]],
                        y: [[u, c.startStubY], [u, c.endStubY], [c.endStubX, c.endStubY]]
                    }
                      , j = {
                        x: [c.startStubY, c.endStubY],
                        y: [c.startStubX, c.endStubX]
                    }
                      , k = w[b][0]
                      , l = w[b][1]
                      , m = c.so[k] + 1
                      , n = c.to[l] + 1
                      , o = c.to[l] === -1 && j[b][1] < j[b][0] || 1 === c.to[l] && j[b][1] > j[b][0]
                      , p = e[b][m][0]
                      , q = e[b][m][1]
                      , r = d[b][m][n];
                    return c.segment === r[3] || c.segment === r[2] && o ? f[b] : c.segment === r[2] && q < p ? g[b] : c.segment === r[2] && q >= p || c.segment === r[1] && !o ? i[b] : c.segment === r[0] || c.segment === r[1] && o ? h[b] : void 0
                },
                orthogonal: function(b, c, d, e, f) {
                    var g = a
                      , h = {
                        x: g.so[0] === -1 ? Math.min(c, e) : Math.max(c, e),
                        y: g.so[1] === -1 ? Math.min(c, e) : Math.max(c, e)
                    }[b];
                    return {
                        x: [[h, d], [h, f], [e, f]],
                        y: [[d, h], [f, h], [f, e]]
                    }[b]
                },
                opposite: function(c, d, f, g) {
                    var h = a
                      , i = {
                        x: "y",
                        y: "x"
                    }[c]
                      , j = {
                        x: "height",
                        y: "width"
                    }[c]
                      , k = h["is" + c.toUpperCase() + "GreaterThanStubTimes2"];
                    if (b.sourceEndpoint.elementId === b.targetEndpoint.elementId) {
                        var l = f + (1 - b.sourceEndpoint.anchor[i]) * b.sourceInfo[j] + e.maxStub;
                        return {
                            x: [[d, l], [g, l]],
                            y: [[l, d], [l, g]]
                        }[c]
                    }
                    return !k || 1 === h.so[n] && d > g || h.so[n] === -1 && d < g ? {
                        x: [[d, v], [g, v]],
                        y: [[u, d], [u, g]]
                    }[c] : 1 === h.so[n] && d < g || h.so[n] === -1 && d > g ? {
                        x: [[u, h.sy], [u, h.ty]],
                        y: [[h.sx, v], [h.tx, v]]
                    }[c] : void 0
                }
            }
              , y = x[a.anchorOrientation](a.sourceAxis, q, r, s, t);
            if (y)
                for (var z = 0; z < y.length; z++)
                    l(c, y[z][0], y[z][1], a);
            l(c, m[2], m[3], a),
            l(c, a.tx, a.ty, a),
            o(this, c, a)
        }
    };
    c.extend(d, b.Connectors.AbstractConnector),
    b.registerConnectorType(d, "Flowchart")
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumb
      , c = a.jsPlumbUtil;
    b.Connectors.AbstractBezierConnector = function(a) {
        a = a || {};
        var c, d = a.showLoopback !== !1, e = (a.curviness || 10,
        a.margin || 5), f = (a.proximityLimit || 80,
        a.orientation && "clockwise" === a.orientation), g = a.loopbackRadius || 25, h = !1;
        return this.overrideSetEditable = function() {
            return !h
        }
        ,
        this._compute = function(a, b) {
            var i = b.sourcePos
              , j = b.targetPos
              , k = Math.abs(i[0] - j[0])
              , l = Math.abs(i[1] - j[1]);
            if (d && b.sourceEndpoint.elementId === b.targetEndpoint.elementId) {
                h = !0;
                var m = b.sourcePos[0]
                  , n = b.sourcePos[1] - e
                  , o = m
                  , p = n - g
                  , q = o - g
                  , r = p - g;
                k = 2 * g,
                l = 2 * g,
                a.points[0] = q,
                a.points[1] = r,
                a.points[2] = k,
                a.points[3] = l,
                c.addSegment(this, "Arc", {
                    loopback: !0,
                    x1: m - q + 4,
                    y1: n - r,
                    startAngle: 0,
                    endAngle: 2 * Math.PI,
                    r: g,
                    ac: !f,
                    x2: m - q - 4,
                    y2: n - r,
                    cx: o - q,
                    cy: p - r
                })
            } else
                h = !1,
                this._computeBezier(a, b, i, j, k, l)
        }
        ,
        c = b.Connectors.AbstractConnector.apply(this, arguments)
    }
    ,
    c.extend(b.Connectors.AbstractBezierConnector, b.Connectors.AbstractConnector);
    var d = function(a) {
        a = a || {},
        this.type = "Bezier";
        var c = b.Connectors.AbstractBezierConnector.apply(this, arguments)
          , d = a.curviness || 150
          , e = 10;
        this.getCurviness = function() {
            return d
        }
        ,
        this._findControlPoint = function(a, b, c, f, g, h, i) {
            var j = h[0] !== i[0] || h[1] === i[1]
              , k = [];
            return j ? (0 === i[0] ? k.push(c[0] < b[0] ? a[0] + e : a[0] - e) : k.push(a[0] + d * i[0]),
            0 === i[1] ? k.push(c[1] < b[1] ? a[1] + e : a[1] - e) : k.push(a[1] + d * h[1])) : (0 === h[0] ? k.push(b[0] < c[0] ? a[0] + e : a[0] - e) : k.push(a[0] - d * h[0]),
            0 === h[1] ? k.push(b[1] < c[1] ? a[1] + e : a[1] - e) : k.push(a[1] + d * i[1])),
            k
        }
        ,
        this._computeBezier = function(a, b, d, e, f, g) {
            var h, i, j = this.getGeometry(), k = d[0] < e[0] ? f : 0, l = d[1] < e[1] ? g : 0, m = d[0] < e[0] ? 0 : f, n = d[1] < e[1] ? 0 : g;
            (this.hasBeenEdited() || this.isEditing()) && null != j && null != j.controlPoints && null != j.controlPoints[0] && null != j.controlPoints[1] ? (h = j.controlPoints[0],
            i = j.controlPoints[1]) : (h = this._findControlPoint([k, l], d, e, b.sourceEndpoint, b.targetEndpoint, a.so, a.to),
            i = this._findControlPoint([m, n], e, d, b.targetEndpoint, b.sourceEndpoint, a.to, a.so)),
            c.setGeometry({
                controlPoints: [h, i]
            }, !0),
            c.addSegment(this, "Bezier", {
                x1: k,
                y1: l,
                x2: m,
                y2: n,
                cp1x: h[0],
                cp1y: h[1],
                cp2x: i[0],
                cp2y: i[1]
            })
        }
    };
    c.extend(d, b.Connectors.AbstractBezierConnector),
    b.registerConnectorType(d, "Bezier")
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumb
      , c = a.jsPlumbUtil
      , d = function(a, b, c, d) {
        return a <= c && d <= b ? 1 : a <= c && b <= d ? 2 : c <= a && d >= b ? 3 : 4
    }
      , e = function(a, b, c, d, e, f, g, h, i) {
        return h <= i ? [a, b] : 1 === c ? d[3] <= 0 && e[3] >= 1 ? [a + (d[2] < .5 ? -1 * f : f), b] : d[2] >= 1 && e[2] <= 0 ? [a, b + (d[3] < .5 ? -1 * g : g)] : [a + -1 * f, b + -1 * g] : 2 === c ? d[3] >= 1 && e[3] <= 0 ? [a + (d[2] < .5 ? -1 * f : f), b] : d[2] >= 1 && e[2] <= 0 ? [a, b + (d[3] < .5 ? -1 * g : g)] : [a + f, b + -1 * g] : 3 === c ? d[3] >= 1 && e[3] <= 0 ? [a + (d[2] < .5 ? -1 * f : f), b] : d[2] <= 0 && e[2] >= 1 ? [a, b + (d[3] < .5 ? -1 * g : g)] : [a + -1 * f, b + -1 * g] : 4 === c ? d[3] <= 0 && e[3] >= 1 ? [a + (d[2] < .5 ? -1 * f : f), b] : d[2] <= 0 && e[2] >= 1 ? [a, b + (d[3] < .5 ? -1 * g : g)] : [a + f, b + -1 * g] : void 0
    }
      , f = function(a) {
        a = a || {},
        this.type = "StateMachine";
        var c, f = b.Connectors.AbstractBezierConnector.apply(this, arguments), g = a.curviness || 10, h = a.margin || 5, i = a.proximityLimit || 80;
        a.orientation && "clockwise" === a.orientation;
        this._computeBezier = function(a, b, j, k, l, m) {
            var n = b.sourcePos[0] < b.targetPos[0] ? 0 : l
              , o = b.sourcePos[1] < b.targetPos[1] ? 0 : m
              , p = b.sourcePos[0] < b.targetPos[0] ? l : 0
              , q = b.sourcePos[1] < b.targetPos[1] ? m : 0;
            0 === b.sourcePos[2] && (n -= h),
            1 === b.sourcePos[2] && (n += h),
            0 === b.sourcePos[3] && (o -= h),
            1 === b.sourcePos[3] && (o += h),
            0 === b.targetPos[2] && (p -= h),
            1 === b.targetPos[2] && (p += h),
            0 === b.targetPos[3] && (q -= h),
            1 === b.targetPos[3] && (q += h);
            var r, s, t, u, v = (n + p) / 2, w = (o + q) / 2, x = d(n, o, p, q), y = Math.sqrt(Math.pow(p - n, 2) + Math.pow(q - o, 2)), z = f.getGeometry();
            (this.hasBeenEdited() || this.isEditing()) && null != z ? (r = z.controlPoints[0][0],
            t = z.controlPoints[0][1],
            s = z.controlPoints[1][0],
            u = z.controlPoints[1][1]) : (c = e(v, w, x, b.sourcePos, b.targetPos, g, g, y, i),
            r = c[0],
            s = c[0],
            t = c[1],
            u = c[1],
            f.setGeometry({
                controlPoints: [c, c]
            }, !0)),
            f.addSegment(this, "Bezier", {
                x1: p,
                y1: q,
                x2: n,
                y2: o,
                cp1x: r,
                cp1y: t,
                cp2x: s,
                cp2y: u
            })
        }
    };
    c.extend(f, b.Connectors.AbstractBezierConnector),
    b.registerConnectorType(f, "StateMachine")
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumb
      , c = a.jsPlumbUtil
      , d = "Straight"
      , e = function(a) {
        this.type = d;
        var c = b.Connectors.AbstractConnector.apply(this, arguments);
        this._compute = function(a, b) {
            c.addSegment(this, d, {
                x1: a.sx,
                y1: a.sy,
                x2: a.startStubX,
                y2: a.startStubY
            }),
            c.addSegment(this, d, {
                x1: a.startStubX,
                y1: a.startStubY,
                x2: a.endStubX,
                y2: a.endStubY
            }),
            c.addSegment(this, d, {
                x1: a.endStubX,
                y1: a.endStubY,
                x2: a.tx,
                y2: a.ty
            })
        }
    };
    c.extend(e, b.Connectors.AbstractConnector),
    b.registerConnectorType(e, d)
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumb
      , c = a.jsPlumbUtil
      , d = {
        "stroke-linejoin": "stroke-linejoin",
        "stroke-dashoffset": "stroke-dashoffset",
        "stroke-linecap": "stroke-linecap"
    }
      , e = "stroke-dasharray"
      , f = "dashstyle"
      , g = "linearGradient"
      , h = "radialGradient"
      , i = "defs"
      , j = "fill"
      , k = "stop"
      , l = "stroke"
      , m = "stroke-width"
      , n = "style"
      , o = "none"
      , p = "jsplumb_gradient_"
      , q = "strokeWidth"
      , r = {
        svg: "http://www.w3.org/2000/svg"
    }
      , s = function(a, b) {
        for (var c in b)
            a.setAttribute(c, "" + b[c])
    }
      , t = function(a, c) {
        return c = c || {},
        c.version = "1.1",
        c.xmlns = r.svg,
        b.createElementNS(r.svg, a, null, null, c)
    }
      , u = function(a) {
        return "position:absolute;left:" + a[0] + "px;top:" + a[1] + "px"
    }
      , v = function(a) {
        for (var b = a.querySelectorAll(" defs,linearGradient,radialGradient"), c = 0; c < b.length; c++)
            b[c].parentNode.removeChild(b[c])
    }
      , w = function(a, b, c, d, e) {
        var f = p + e._jsPlumb.instance.idstamp();
        v(a);
        var m;
        m = c.gradient.offset ? t(h, {
            id: f
        }) : t(g, {
            id: f,
            gradientUnits: "userSpaceOnUse"
        });
        var n = t(i);
        a.appendChild(n),
        n.appendChild(m);
        for (var o = 0; o < c.gradient.stops.length; o++) {
            var q = 1 === e.segment || 2 === e.segment ? o : c.gradient.stops.length - 1 - o
              , r = c.gradient.stops[q][1]
              , s = t(k, {
                offset: Math.floor(100 * c.gradient.stops[o][0]) + "%",
                "stop-color": r
            });
            m.appendChild(s)
        }
        var u = c.stroke ? l : j;
        b.setAttribute(u, "url(#" + f + ")")
    }
      , x = function(a, b, c, g, h) {
        if (b.setAttribute(j, c.fill ? c.fill : o),
        b.setAttribute(l, c.stroke ? c.stroke : o),
        c.gradient ? w(a, b, c, g, h) : (v(a),
        b.setAttribute(n, "")),
        c.strokeWidth && b.setAttribute(m, c.strokeWidth),
        c[f] && c[q] && !c[e]) {
            var i = c[f].indexOf(",") === -1 ? " " : ","
              , k = c[f].split(i)
              , p = "";
            k.forEach(function(a) {
                p += Math.floor(a * c.strokeWidth) + i
            }),
            b.setAttribute(e, p)
        } else
            c[e] && b.setAttribute(e, c[e]);
        for (var r in d)
            c[r] && b.setAttribute(d[r], c[r])
    }
      , y = function(a, b, c) {
        a.childNodes.length > c ? a.insertBefore(b, a.childNodes[c]) : a.appendChild(b)
    };
    c.svg = {
        node: t,
        attr: s,
        pos: u
    };
    var z = function(a) {
        var d = a.pointerEventsSpec || "all"
          , e = {};
        b.jsPlumbUIComponent.apply(this, a.originalArgs),
        this.canvas = null,
        this.path = null,
        this.svg = null,
        this.bgCanvas = null;
        var f = a.cssClass + " " + (a.originalArgs[0].cssClass || "")
          , g = {
            style: "",
            width: 0,
            height: 0,
            "pointer-events": d,
            position: "absolute"
        };
        this.svg = t("svg", g),
        a.useDivWrapper ? (this.canvas = b.createElement("div", {
            position: "absolute"
        }),
        c.sizeElement(this.canvas, 0, 0, 1, 1),
        this.canvas.className = f) : (s(this.svg, {
            class: f
        }),
        this.canvas = this.svg),
        a._jsPlumb.appendElement(this.canvas, a.originalArgs[0].parent),
        a.useDivWrapper && this.canvas.appendChild(this.svg);
        var h = [this.canvas];
        return this.getDisplayElements = function() {
            return h
        }
        ,
        this.appendDisplayElement = function(a) {
            h.push(a)
        }
        ,
        this.paint = function(b, d, f) {
            if (null != b) {
                var g, h = [this.x, this.y], i = [this.w, this.h];
                null != f && (f.xmin < 0 && (h[0] += f.xmin),
                f.ymin < 0 && (h[1] += f.ymin),
                i[0] = f.xmax + (f.xmin < 0 ? -f.xmin : 0),
                i[1] = f.ymax + (f.ymin < 0 ? -f.ymin : 0)),
                a.useDivWrapper ? (c.sizeElement(this.canvas, h[0], h[1], i[0], i[1]),
                h[0] = 0,
                h[1] = 0,
                g = u([0, 0])) : g = u([h[0], h[1]]),
                e.paint.apply(this, arguments),
                s(this.svg, {
                    style: g,
                    width: i[0] || 0,
                    height: i[1] || 0
                })
            }
        }
        ,
        {
            renderer: e
        }
    };
    c.extend(z, b.jsPlumbUIComponent, {
        cleanup: function(a) {
            a || null == this.typeId ? (this.canvas && (this.canvas._jsPlumb = null),
            this.svg && (this.svg._jsPlumb = null),
            this.bgCanvas && (this.bgCanvas._jsPlumb = null),
            this.canvas && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas),
            this.bgCanvas && this.bgCanvas.parentNode && this.canvas.parentNode.removeChild(this.canvas),
            this.svg = null,
            this.canvas = null,
            this.path = null,
            this.group = null) : (this.canvas && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas),
            this.bgCanvas && this.bgCanvas.parentNode && this.bgCanvas.parentNode.removeChild(this.bgCanvas))
        },
        reattach: function(a) {
            var b = a.getContainer();
            this.canvas && null == this.canvas.parentNode && b.appendChild(this.canvas),
            this.bgCanvas && null == this.bgCanvas.parentNode && b.appendChild(this.bgCanvas)
        },
        setVisible: function(a) {
            this.canvas && (this.canvas.style.display = a ? "block" : "none")
        }
    }),
    b.ConnectorRenderers.svg = function(a) {
        var c = this
          , d = z.apply(this, [{
            cssClass: a._jsPlumb.connectorClass + (this.isEditable() ? " " + a._jsPlumb.editableConnectorClass : ""),
            originalArgs: arguments,
            pointerEventsSpec: "none",
            _jsPlumb: a._jsPlumb
        }])
          , e = this.setEditable;
        this.setEditable = function(a) {
            var c = e.apply(this, [a]);
            b[c ? "addClass" : "removeClass"](this.canvas, this._jsPlumb.instance.editableConnectorClass)
        }
        ,
        d.renderer.paint = function(d, e, f) {
            var g = c.getSegments()
              , h = ""
              , i = [0, 0];
            if (f.xmin < 0 && (i[0] = -f.xmin),
            f.ymin < 0 && (i[1] = -f.ymin),
            g.length > 0) {
                h = c.getPathData();
                var j = {
                    d: h,
                    transform: "translate(" + i[0] + "," + i[1] + ")",
                    "pointer-events": a["pointer-events"] || "visibleStroke"
                }
                  , k = null
                  , l = [c.x, c.y, c.w, c.h];
                if (d.outlineStroke) {
                    var m = d.outlineWidth || 1
                      , n = d.strokeWidth + 2 * m;
                    k = b.extend({}, d),
                    delete k.gradient,
                    k.stroke = d.outlineStroke,
                    k.strokeWidth = n,
                    null == c.bgPath ? (c.bgPath = t("path", j),
                    b.addClass(c.bgPath, b.connectorOutlineClass),
                    y(c.svg, c.bgPath, 0)) : s(c.bgPath, j),
                    x(c.svg, c.bgPath, k, l, c)
                }
                null == c.path ? (c.path = t("path", j),
                y(c.svg, c.path, d.outlineStroke ? 1 : 0)) : s(c.path, j),
                x(c.svg, c.path, d, l, c)
            }
        }
    }
    ,
    c.extend(b.ConnectorRenderers.svg, z);
    var A = b.SvgEndpoint = function(a) {
        var c = z.apply(this, [{
            cssClass: a._jsPlumb.endpointClass,
            originalArgs: arguments,
            pointerEventsSpec: "all",
            useDivWrapper: !0,
            _jsPlumb: a._jsPlumb
        }]);
        c.renderer.paint = function(a) {
            var c = b.extend({}, a);
            c.outlineStroke && (c.stroke = c.outlineStroke),
            null == this.node ? (this.node = this.makeNode(c),
            this.svg.appendChild(this.node)) : null != this.updateNode && this.updateNode(this.node),
            x(this.svg, this.node, c, [this.x, this.y, this.w, this.h], this),
            u(this.node, [this.x, this.y])
        }
        .bind(this)
    }
    ;
    c.extend(A, z),
    b.Endpoints.svg.Dot = function() {
        b.Endpoints.Dot.apply(this, arguments),
        A.apply(this, arguments),
        this.makeNode = function(a) {
            return t("circle", {
                cx: this.w / 2,
                cy: this.h / 2,
                r: this.radius
            })
        }
        ,
        this.updateNode = function(a) {
            s(a, {
                cx: this.w / 2,
                cy: this.h / 2,
                r: this.radius
            })
        }
    }
    ,
    c.extend(b.Endpoints.svg.Dot, [b.Endpoints.Dot, A]),
    b.Endpoints.svg.Rectangle = function() {
        b.Endpoints.Rectangle.apply(this, arguments),
        A.apply(this, arguments),
        this.makeNode = function(a) {
            return t("rect", {
                width: this.w,
                height: this.h
            })
        }
        ,
        this.updateNode = function(a) {
            s(a, {
                width: this.w,
                height: this.h
            })
        }
    }
    ,
    c.extend(b.Endpoints.svg.Rectangle, [b.Endpoints.Rectangle, A]),
    b.Endpoints.svg.Image = b.Endpoints.Image,
    b.Endpoints.svg.Blank = b.Endpoints.Blank,
    b.Overlays.svg.Label = b.Overlays.Label,
    b.Overlays.svg.Custom = b.Overlays.Custom;
    var B = function(a, c) {
        a.apply(this, c),
        b.jsPlumbUIComponent.apply(this, c),
        this.isAppendedAtTopLevel = !1;
        this.path = null,
        this.paint = function(a, b) {
            if (a.component.svg && b) {
                null == this.path && (this.path = t("path", {
                    "pointer-events": "all"
                }),
                a.component.svg.appendChild(this.path),
                this.elementCreated && this.elementCreated(this.path, a.component),
                this.canvas = a.component.svg);
                var e = c && 1 === c.length ? c[0].cssClass || "" : ""
                  , f = [0, 0];
                b.xmin < 0 && (f[0] = -b.xmin),
                b.ymin < 0 && (f[1] = -b.ymin),
                s(this.path, {
                    d: d(a.d),
                    class: e,
                    stroke: a.stroke ? a.stroke : null,
                    fill: a.fill ? a.fill : null,
                    transform: "translate(" + f[0] + "," + f[1] + ")"
                })
            }
        }
        ;
        var d = function(a) {
            return isNaN(a.cxy.x) || isNaN(a.cxy.y) ? "" : "M" + a.hxy.x + "," + a.hxy.y + " L" + a.tail[0].x + "," + a.tail[0].y + " L" + a.cxy.x + "," + a.cxy.y + " L" + a.tail[1].x + "," + a.tail[1].y + " L" + a.hxy.x + "," + a.hxy.y
        };
        this.transfer = function(a) {
            a.canvas && this.path && this.path.parentNode && (this.path.parentNode.removeChild(this.path),
            a.canvas.appendChild(this.path))
        }
    };
    c.extend(B, [b.jsPlumbUIComponent, b.Overlays.AbstractOverlay], {
        cleanup: function(a) {
            null != this.path && (a ? this._jsPlumb.instance.removeElement(this.path) : this.path.parentNode && this.path.parentNode.removeChild(this.path))
        },
        reattach: function(a) {
            this.path && this.canvas && null == this.path.parentNode && this.canvas.appendChild(this.path)
        },
        setVisible: function(a) {
            null != this.path && (this.path.style.display = a ? "block" : "none")
        }
    }),
    b.Overlays.svg.Arrow = function() {
        B.apply(this, [b.Overlays.Arrow, arguments])
    }
    ,
    c.extend(b.Overlays.svg.Arrow, [b.Overlays.Arrow, B]),
    b.Overlays.svg.PlainArrow = function() {
        B.apply(this, [b.Overlays.PlainArrow, arguments])
    }
    ,
    c.extend(b.Overlays.svg.PlainArrow, [b.Overlays.PlainArrow, B]),
    b.Overlays.svg.Diamond = function() {
        B.apply(this, [b.Overlays.Diamond, arguments])
    }
    ,
    c.extend(b.Overlays.svg.Diamond, [b.Overlays.Diamond, B]),
    b.Overlays.svg.GuideLines = function() {
        var a, c, d = null, e = this;
        b.Overlays.GuideLines.apply(this, arguments),
        this.paint = function(b, g) {
            null == d && (d = t("path"),
            b.connector.svg.appendChild(d),
            e.attachListeners(d, b.connector),
            e.attachListeners(d, e),
            a = t("path"),
            b.connector.svg.appendChild(a),
            e.attachListeners(a, b.connector),
            e.attachListeners(a, e),
            c = t("path"),
            b.connector.svg.appendChild(c),
            e.attachListeners(c, b.connector),
            e.attachListeners(c, e));
            var h = [0, 0];
            g.xmin < 0 && (h[0] = -g.xmin),
            g.ymin < 0 && (h[1] = -g.ymin),
            s(d, {
                d: f(b.head, b.tail),
                stroke: "red",
                fill: null,
                transform: "translate(" + h[0] + "," + h[1] + ")"
            }),
            s(a, {
                d: f(b.tailLine[0], b.tailLine[1]),
                stroke: "blue",
                fill: null,
                transform: "translate(" + h[0] + "," + h[1] + ")"
            }),
            s(c, {
                d: f(b.headLine[0], b.headLine[1]),
                stroke: "green",
                fill: null,
                transform: "translate(" + h[0] + "," + h[1] + ")"
            })
        }
        ;
        var f = function(a, b) {
            return "M " + a.x + "," + a.y + " L" + b.x + "," + b.y
        }
    }
    ,
    c.extend(b.Overlays.svg.GuideLines, b.Overlays.GuideLines)
}
.call("undefined" != typeof window ? window : this),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumb
      , c = a.jsPlumbUtil
      , d = a.Katavorio
      , e = a.Biltong
      , f = function(a, c) {
        c = c || "main";
        var f = "_katavorio_" + c
          , g = a[f]
          , h = a.getEventManager();
        return g || (g = new d({
            bind: h.on,
            unbind: h.off,
            getSize: b.getSize,
            getPosition: function(b, c) {
                var d = a.getOffset(b, c, b._katavorioDrag ? b.offsetParent : null);
                return [d.left, d.top]
            },
            setPosition: function(a, b) {
                a.style.left = b[0] + "px",
                a.style.top = b[1] + "px"
            },
            addClass: b.addClass,
            removeClass: b.removeClass,
            intersects: e.intersects,
            indexOf: function(a, b) {
                return a.indexOf(b)
            },
            scope: a.getDefaultScope(),
            css: {
                noSelect: a.dragSelectClass,
                droppable: "jtk-droppable",
                draggable: "jtk-draggable",
                drag: "jtk-drag",
                selected: "jtk-drag-selected",
                active: "jtk-drag-active",
                hover: "jtk-drag-hover",
                ghostProxy: "jtk-ghost-proxy"
            }
        }),
        g.setZoom(a.getZoom()),
        a[f] = g,
        a.bind("zoom", g.setZoom)),
        g
    }
      , g = function(a, b) {
        var d = function(d) {
            if (null != b[d]) {
                if (c.isString(b[d])) {
                    var e = b[d].match(/-=/) ? -1 : 1
                      , f = b[d].substring(2);
                    return a[d] + e * f
                }
                return b[d]
            }
            return a[d]
        };
        return [d("left"), d("top")]
    };
    b.extend(a.jsPlumbInstance.prototype, {
        animationSupported: !0,
        getElement: function(a) {
            return null == a ? null : (a = "string" == typeof a ? a : null != a.length && null == a.enctype ? a[0] : a,
            "string" == typeof a ? document.getElementById(a) : a)
        },
        removeElement: function(a) {
            f(this).elementRemoved(a),
            this.getEventManager().remove(a)
        },
        doAnimate: function(a, c, d) {
            d = d || {};
            var e = this.getOffset(a)
              , f = g(e, c)
              , h = f[0] - e.left
              , i = f[1] - e.top
              , j = d.duration || 250
              , k = 15
              , l = j / k
              , m = k / j * h
              , n = k / j * i
              , o = 0
              , p = setInterval(function() {
                b.setPosition(a, {
                    left: e.left + m * (o + 1),
                    top: e.top + n * (o + 1)
                }),
                null != d.step && d.step(o, Math.ceil(l)),
                o++,
                o >= l && (window.clearInterval(p),
                null != d.complete && d.complete())
            }, k)
        },
        destroyDraggable: function(a, b) {
            f(this, b).destroyDraggable(a)
        },
        destroyDroppable: function(a, b) {
            f(this, b).destroyDroppable(a)
        },
        initDraggable: function(a, b, c) {
            f(this, c).draggable(a, b)
        },
        initDroppable: function(a, b, c) {
            f(this, c).droppable(a, b)
        },
        isAlreadyDraggable: function(a) {
            return null != a._katavorioDrag
        },
        isDragSupported: function(a, b) {
            return !0
        },
        isDropSupported: function(a, b) {
            return !0
        },
        isElementDraggable: function(a) {
            return a = b.getElement(a),
            a._katavorioDrag && a._katavorioDrag.isEnabled()
        },
        getDragObject: function(a) {
            return a[0].drag.getDragElement()
        },
        getDragScope: function(a) {
            return a._katavorioDrag && a._katavorioDrag.scopes.join(" ") || ""
        },
        getDropEvent: function(a) {
            return a[0].e
        },
        getUIPosition: function(a, b) {
            var c = a[0].el;
            if (null == c.offsetParent)
                return null;
            var d = a[0].finalPos || a[0].pos
              , e = {
                left: d[0],
                top: d[1]
            };
            if (c._katavorioDrag && c.offsetParent !== this.getContainer()) {
                var f = this.getOffset(c.offsetParent);
                e.left += f.left,
                e.top += f.top
            }
            return e
        },
        setDragFilter: function(a, b, c) {
            a._katavorioDrag && a._katavorioDrag.setFilter(b, c)
        },
        setElementDraggable: function(a, c) {
            a = b.getElement(a),
            a._katavorioDrag && a._katavorioDrag.setEnabled(c)
        },
        setDragScope: function(a, b) {
            a._katavorioDrag && a._katavorioDrag.k.setDragScope(a, b)
        },
        setDropScope: function(a, b) {
            a._katavorioDrop && a._katavorioDrop.length > 0 && a._katavorioDrop[0].k.setDropScope(a, b)
        },
        addToPosse: function(a, c) {
            var d = Array.prototype.slice.call(arguments, 1)
              , e = f(this);
            b.each(a, function(a) {
                a = [b.getElement(a)],
                a.push.apply(a, d),
                e.addToPosse.apply(e, a)
            })
        },
        setPosse: function(a, c) {
            var d = Array.prototype.slice.call(arguments, 1)
              , e = f(this);
            b.each(a, function(a) {
                a = [b.getElement(a)],
                a.push.apply(a, d),
                e.setPosse.apply(e, a)
            })
        },
        removeFromPosse: function(a, c) {
            var d = Array.prototype.slice.call(arguments, 1)
              , e = f(this);
            b.each(a, function(a) {
                a = [b.getElement(a)],
                a.push.apply(a, d),
                e.removeFromPosse.apply(e, a)
            })
        },
        removeFromAllPosses: function(a) {
            var c = f(this);
            b.each(a, function(a) {
                c.removeFromAllPosses(b.getElement(a))
            })
        },
        setPosseState: function(a, c, d) {
            var e = f(this);
            b.each(a, function(a) {
                e.setPosseState(b.getElement(a), c, d)
            })
        },
        dragEvents: {
            start: "start",
            stop: "stop",
            drag: "drag",
            step: "step",
            over: "over",
            out: "out",
            drop: "drop",
            complete: "complete",
            beforeStart: "beforeStart"
        },
        animEvents: {
            step: "step",
            complete: "complete"
        },
        stopDrag: function(a) {
            a._katavorioDrag && a._katavorioDrag.abort()
        },
        addToDragSelection: function(a) {
            f(this).select(a)
        },
        removeFromDragSelection: function(a) {
            f(this).deselect(a)
        },
        clearDragSelection: function() {
            f(this).deselectAll()
        },
        trigger: function(a, b, c, d) {
            this.getEventManager().trigger(a, b, c, d)
        },
        doReset: function() {
            for (var a in this)
                0 === a.indexOf("_katavorio_") && this[a].reset()
        }
    });
    var h = function(a) {
        var b = function() {
            /complete|loaded|interactive/.test(document.readyState) && "undefined" != typeof document.body && null != document.body ? a() : setTimeout(b, 9)
        };
        b()
    };
    h(b.init)
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = a.Farahey = {};
    "undefined" != typeof exports && (exports.Farahey = b);
    var c = function(a, b, c) {
        for (var d = 0, e = a.length, f = -1, g = 0; d < e; )
            if (f = parseInt((d + e) / 2),
            g = c(a[f], b),
            g < 0)
                d = f + 1;
            else {
                if (!(g > 0))
                    return f;
                e = f
            }
        return d
    }
      , d = a.Biltong
      , e = function(a, b, d) {
        var e = c(a, b, d);
        a.splice(e, 0, b)
    }
      , f = function(a, b) {
        var c = a
          , e = {}
          , f = function(a) {
            if (!e[a[1]]) {
                var c = b(a[2]);
                e[a[1]] = {
                    l: a[0][0],
                    t: a[0][1],
                    w: c[0],
                    h: c[1],
                    center: [a[0][0] + c[0] / 2, a[0][1] + c[1] / 2]
                }
            }
            return e[a[1]]
        };
        this.setOrigin = function(a) {
            c = a,
            e = {}
        }
        ,
        this.compare = function(a, b) {
            var e = d.lineLength(c, f(a).center)
              , g = d.lineLength(c, f(b).center);
            return e < g ? -1 : e == g ? 0 : 1
        }
    }
      , g = function(a, b, c, d) {
        return a[b] <= d && d <= a[b] + a[c]
    }
      , h = [function(a, b) {
        return a.x + a.w - b.x
    }
    , function(a, b) {
        return a.x - (b.x + b.w)
    }
    ]
      , i = [function(a, b) {
        return a.y + a.h - b.y
    }
    , function(a, b) {
        return a.y - (b.y + b.h)
    }
    ]
      , j = [null, [h[0], i[1]], [h[0], i[0]], [h[1], i[0]], [h[1], i[1]]]
      , k = function(a, b, c, d, e) {
        isNaN(c) && (c = 0);
        var f, h, i, k = b.y + b.h, l = c == 1 / 0 || c == -(1 / 0) ? b.x + b.w / 2 : (k - d) / c, m = Math.atan(c);
        return g(b, "x", "w", l) ? (f = j[e][1](a, b),
        h = f / Math.sin(m),
        i = h * Math.cos(m),
        {
            left: i,
            top: f
        }) : (i = j[e][0](a, b),
        h = i / Math.cos(m),
        f = h * Math.sin(m),
        {
            left: i,
            top: f
        })
    }
      , l = b.calculateSpacingAdjustment = function(a, b) {
        var c = a.center || [a.x + a.w / 2, a.y + a.h / 2]
          , e = b.center || [b.x + b.w / 2, b.y + b.h / 2]
          , f = d.gradient(c, e)
          , g = d.quadrant(c, e)
          , h = f == 1 / 0 || f == -(1 / 0) || isNaN(f) ? 0 : c[1] - f * c[0];
        return k(a, b, f, h, g)
    }
      , m = b.paddedRectangle = function(a, b, c) {
        return {
            x: a[0] - c[0],
            y: a[1] - c[1],
            w: b[0] + 2 * c[0],
            h: b[1] + 2 * c[1]
        }
    }
      , n = function(a, b, c, e, f, g, h, i, j, k, n, o, p) {
        g = g || [0, 0],
        k = k || function() {}
        ,
        n = n || 2;
        var q, r, s = m(g, [1, 1], e), t = 1, u = !0, v = {}, w = function(a, b, c, d) {
            v[a] = !0,
            b[0] += c,
            b[1] += d
        }, x = function() {
            for (var g = 0; g < a.length; g++)
                if (!o(a[g][1], a[g][2])) {
                    var v = b[a[g][1]]
                      , y = a[g][1]
                      , z = (a[g][2],
                    c[a[g][1]])
                      , A = m(v, z, e);
                    !p && h(a[g][1], a[g][2]) && d.intersects(s, A) && (q = l(s, A),
                    r = f(a[g][1], v, q),
                    w(y, v, r.left, r.top)),
                    A = m(v, z, e);
                    for (var B = 0; B < a.length; B++)
                        if (g != B) {
                            if (o(a[B][1], a[B][2]))
                                continue;
                            if (h(a[B][1], a[B][2])) {
                                var C = b[a[B][1]]
                                  , D = c[a[B][1]]
                                  , E = m(C, D, e);
                                d.intersects(A, E) && (u = !0,
                                q = l(A, E),
                                r = f(a[B][1], C, q),
                                w(a[B][1], C, r.left, r.top))
                            }
                        }
                }
            i && k(),
            u && t < n && (u = !1,
            t++,
            i ? window.setTimeout(x, j) : x())
        };
        return x(),
        v
    }
      , o = function(a) {
        if (null == a)
            return null;
        if ("[object Array]" === Object.prototype.toString.call(a)) {
            var b = [];
            return b.push.apply(b, a),
            b
        }
        var c = [];
        for (var d in a)
            c.push(a[d]);
        return c
    }
      , p = function(a) {
        var b, c = a.getPosition, d = a.getSize, g = a.getId, h = a.setPosition, i = a.padding || [20, 20], j = a.constrain || function(a, b, c) {
            return c
        }
        , k = [], l = {}, m = {}, p = o(a.elements || []), q = a.origin || [0, 0], r = a.executeNow, s = (this.getOrigin = function() {
            return q
        }
        ,
        a.filter || function(a) {
            return !0
        }
        ), t = a.exclude || function(a) {
            return !1
        }
        , u = a.orderByDistanceFromOrigin, v = new f(q,d), w = a.updateOnStep, x = a.stepInterval || 350, y = a.debug, z = function() {
            var a = document.createElement("div");
            a.style.position = "absolute",
            a.style.width = "10px",
            a.style.height = "10px",
            a.style.backgroundColor = "red",
            document.body.appendChild(a),
            b = a
        }, A = function(a) {
            u && 0 != k.length ? e(k, a, v.compare) : k.push(a)
        }, B = function(a) {
            var b, e, f, h;
            b = e = 1 / 0,
            f = h = -(1 / 0);
            for (var i = 0; i < a.length; i++) {
                var j = c(a[i])
                  , k = d(a[i])
                  , n = g(a[i]);
                l[n] = [j.left, j.top],
                A([[j.left, j.top], n, a[i]]),
                m[n] = k,
                b = Math.min(b, j.left),
                e = Math.min(e, j.top),
                f = Math.max(f, j.left + k[0]),
                h = Math.max(h, j.top + k[1])
            }
            return [b, f, e, h]
        }, C = function() {
            return v.setOrigin(q),
            k = [],
            l = {},
            m = {},
            B(p)
        }, D = function(a) {
            if (p.length > 1) {
                a = a || {};
                var b = a.filter || s
                  , c = a.padding || i
                  , d = a.iterations
                  , e = a.exclude || t
                  , f = a.excludeFocus
                  , g = n(k, l, m, c, j, q, b, w, x, E, d, e, f);
                E(g)
            }
        }, E = function(a) {
            for (var b = 0; b < p.length; b++) {
                var c = g(p[b]);
                a[c] && h(p[b], {
                    left: l[c][0],
                    top: l[c][1]
                })
            }
        }, F = function(a) {
            null != a && (q = a,
            v.setOrigin(a))
        };
        return this.execute = function(a, b) {
            F(a),
            C(),
            D(b)
        }
        ,
        this.executeAtCenter = function(a) {
            var b = C();
            F([(b[0] + b[1]) / 2, (b[2] + b[3]) / 2]),
            D(a)
        }
        ,
        this.executeAtEvent = function(c, d) {
            var e = a.container
              , f = a.getContainerPosition(e)
              , g = c.pageX - f.left + e.scrollLeft
              , h = c.pageY - f.top + e.scrollTop;
            y && (b.style.left = c.pageX + "px",
            b.style.top = c.pageY + "px"),
            this.execute([g, h], d)
        }
        ,
        this.setElements = function(a) {
            return p = o(a),
            this
        }
        ,
        this.addElement = function(a, b) {
            return null == a || !b && p.indexOf(a) !== -1 || p.push(a),
            this
        }
        ,
        this.addElements = function(a, b) {
            if (b)
                Array.prototype.push.apply(p, a);
            else
                for (var c = 0; c < a.length; c++)
                    this.addElement(a[c]);
            return this
        }
        ,
        this.getElements = function() {
            return p
        }
        ,
        this.removeElement = function(a) {
            for (var b = -1, c = 0; c < p.length; c++)
                if (p[c] == a) {
                    b = c;
                    break
                }
            return b != -1 && p.splice(b, 1),
            this
        }
        ,
        this.setPadding = function(a) {
            i = a
        }
        ,
        this.setConstrain = function(a) {
            j = a
        }
        ,
        this.setFilter = function(a) {
            s = a
        }
        ,
        this.reset = function() {
            p.length = 0
        }
        ,
        y && z(),
        r && this.execute(),
        this
    };
    b.getInstance = function(a) {
        return new p(a)
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    var a = this
      , b = function(a) {
        return a.length > 0 ? a[a.length - 1] : null
    }
      , c = "undefined" != typeof navigator && /MSIE\s([\d.]+)/.test(navigator.userAgent) ? new Number(RegExp.$1) : -1
      , d = c > -1 && c < 9
      , e = function(a, b, c) {
        var d = function(b, c) {
            for (var d = [], e = 0; e < b.length; e++) {
                var f = g({}, b[e]);
                d.push(f),
                g(f.atts, c.atts, function(b, c) {
                    p(b, c, f, null, a)
                })
            }
            return d
        }
        .bind(this);
        this.template = c.template,
        this.getFunctionBody = function(b) {
            return a.compile(d(a.parse(c.template, null, {
                originalCustomTag: b.tag,
                context: b.context
            }), b), !1, !0, !0)
        }
        .bind(this),
        this.getFunctionEnd = function() {
            return ";_els.pop();"
        }
        ,
        this.rendered = c.rendered || function() {}
        ,
        this.updated = c.updated || function() {}
    }
      , f = function(a, b) {
        for (var c = 0; c < a.length; c++) {
            var d = a[c];
            null != d && 0 !== d.length && b(c, d)
        }
    }
      , g = function(a, b, c) {
        for (var d in b)
            a[d] = b[d],
            c && c(d, a[d]);
        return a
    }
      , h = function(a, b, c) {
        if (null == a)
            return null;
        if ("$data" === b || null == b)
            return a;
        var d = b.match(/^\{(.*)\}$/);
        if (d) {
            for (var e = {}, f = d[1].split(","), g = 0; g < f.length; g++) {
                var i = f[g].split(":")
                  , j = h(a, i[1]);
                e[n(i[0])] = j || i[1].replace(/'/g, "")
            }
            return e
        }
        b = b.replace(/\['([^']*)'\]/g, ".$1");
        var k = a
          , l = k
          , m = null;
        return b.replace(/([^\.])+/g, function(a, b, d, e) {
            if (null == m) {
                var f = a.match(/([^\[0-9]+){1}(\[)([0-9+])/)
                  , g = d + a.length >= e.length
                  , h = function() {
                    return l[f[1]] || function() {
                        return l[f[1]] = [],
                        l[f[1]]
                    }()
                };
                if (g)
                    if (f) {
                        var i = h()
                          , j = f[3];
                        null == c ? m = i[j] : i[j] = c
                    } else
                        null == c ? m = l[a] : l[a] = c;
                else if (f) {
                    var k = h();
                    l = k[f[3]] || function() {
                        return k[f[3]] = {},
                        k[f[3]]
                    }()
                } else
                    l = l[a] || function() {
                        return l[a] = {},
                        l[a]
                    }()
            }
        }),
        m
    }
      , i = function(b) {
        var c = a.document.getElementById(b);
        return null != c ? c.innerHTML : null
    }
      , j = function(a) {
        return "[object Array]" === Object.prototype.toString.call(a)
    }
      , k = function(a) {
        for (var b = [], c = 0; c < a.length; c++)
            j(a[c]) ? b.push.apply(b, k(a[c])) : b[b.length] = a[c];
        return b
    }
      , l = function(a, b) {
        for (var c = [], d = 0, e = a.length; d < e; d++)
            c.push(b(a[d]));
        return k(c)
    }
      , m = function(a, b) {
        for (var c = [], d = 0, e = a.length; d < e; d++)
            b(a[d]) && c.push(a[d]);
        return c
    }
      , n = function(a) {
        if (null == a)
            return a;
        for (var b = a.replace(/^\s\s*/, ""), c = /\s/, d = b.length; c.test(b.charAt(--d)); )
            ;
        return b.slice(0, d + 1)
    }
      , o = function(a, b, c, d, e) {
        var f = r()
          , g = {
            w: b,
            e: [],
            u: f
        };
        e.bindings[f] = g;
        var h = function() {
            return null != d ? "try {  if(" + d + ") { out = out.replace(this.e[k][0], eval(this.e[k][1])); } else out=''; } catch(__) { out='';}" : "try { out = out.replace(this.e[k][0], eval(this.e[k][1])); } catch(__) { out=out.replace(this.e[k][0], '');}"
        }
          , i = function() {
            return null != d ? "var out='';try { with($data) { if (" + d + ") out = this.w; else return null; }}catch(_){return null;}" : "var out = this.w;"
        };
        return g.reapply = new Function("$data",i() + "for (var k = 0; k < this.e.length; k++) { with($data) { " + h() + " }} return out;"),
        c.bindings[a] = g,
        b.replace(/\$\{([^\}]*)\}/g, function(a, b, c, d) {
            g.e.push([a, b])
        }),
        f
    }
      , p = function(a, b, c, d, e) {
        c.atts[a] = b,
        o(a, b, c, d, e)
    }
      , q = function(a, b) {
        function c(a, c) {
            var d = a.match(/([^=]+)=['"](.*)['"]/);
            return null == d && null == c ? e.atts[a] = "" : null == d ? p(a, "", e, c, b) : p(d[1], d[2], e, c, b),
            d
        }
        for (var d = b.parseAttributes(a), e = {
            el: n(d[0]),
            atts: {},
            bindings: {}
        }, f = 1; f < d.length; f++) {
            var g = n(d[f]);
            if (null != g && g.length > 0) {
                var h = g.match(b.inlineIfRe);
                if (h)
                    for (var i = h[2].split(b.attributesRe), j = 0; j < i.length; j++) {
                        var k = n(i[j]);
                        null != k && k.length > 0 && c(k, h[1])
                    }
                else
                    c(g)
            }
        }
        return e
    }
      , r = function(a) {
        var b = a ? "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx" : "xxxxxxxx-xxxx-4xxx";
        return b.replace(/[xy]/g, function(a) {
            var b = 16 * Math.random() | 0
              , c = "x" == a ? b : 3 & b | 8;
            return c.toString(16)
        })
    }
      , s = function(a) {
        if (null == a || 0 === a.length)
            return !1;
        for (var b = a.length - 1; b > -1; b--)
            if ("each" === a[b].type)
                return !0;
        return !1
    }
      , t = function(a, b) {
        var c = this.bindings[b];
        return null == c ? "" : c.reapply(a)
    }
      , u = function(a, b) {
        this.uuid = r(),
        this.children = [],
        this.instance = b,
        b.entries[this.uuid] = this
    }
      , v = function(a, b) {
        u.apply(this, arguments);
        var c = q(a, b);
        null != c.atts["r-toggle"] && null != b.toggleManager && (this.discard = b.toggleManager(c.atts["r-toggle"]) === !1);
        var d = c.el.split(":");
        this.tag = c.el,
        2 === d.length && (this.namespace = d[0]),
        this.atts = c.atts,
        this.bindings = c.bindings,
        this.type = "element",
        this.compile = function(a, b) {
            var c = a.customTags[this.tag] || a.globalTags[this.tag];
            if (c) {
                for (var d = c.getFunctionBody(this), e = a.customTags[this.tag] ? "_rotors.customTags['" + this.tag + "'].rendered(_le, _rotors, data[0]);" : "_rotors.globalTags['" + this.tag + "'].rendered(_le, _rotors, data[0]);", f = 0; f < this.children.length; f++)
                    this.children[f].precompile && (d += this.children[f].precompile(a)),
                    d += this.children[f].compile(a),
                    this.children[f].postcompile && (d += this.children[f].postcompile(a));
                return d += "_le=_els.pop();" + e + "_rotors.pet(_eid,'" + this.uuid + "');"
            }
            var g = "/* element entry " + this.uuid + " */;";
            if (this.remove !== !0) {
                g += a.getExecutionContent(this.tag, this.uuid, !1, this.namespace);
                for (var h in this.atts)
                    if (this.atts.hasOwnProperty(h)) {
                        var i;
                        i = null != this.bindings[h] ? "_rotors.bind(data[0], '" + this.bindings[h].u + "');" : "'" + this.atts[h] + "'",
                        g += "__a=" + i + ";if(__a!=null) {_rotors.setAttribute(e,'" + h + "',__a || '');}"
                    }
            }
            for (var j = 0; j < this.children.length; j++)
                this.children[j].precompile && (g += this.children[j].precompile(a)),
                g += this.children[j].compile(a),
                this.children[j].postcompile && (g += this.children[j].postcompile(a));
            return this.remove === !0 || b || (g += "_le=_els.pop();",
            g += "_rotors.pet(_eid, '" + this.uuid + "');"),
            g
        }
        ;
        var e = function(a, c) {
            b.each(c.split(";"), function(b) {
                var c = b.indexOf(":")
                  , d = b.substring(0, c);
                a.style[d] = b.substring(c + 1)
            })
        };
        this.update = function(a, c) {
            for (var d in this.atts)
                if (this.atts.hasOwnProperty(d) && "class" !== d) {
                    var f;
                    f = null != this.bindings[d] ? this.bindings[d].reapply(c) : "'" + this.atts[d] + "'",
                    null != f && ("style" === d && null != a.style ? e(a, f) : a.setAttribute(d, f))
                }
            if (this.originalCustomTag) {
                var g = b.customTags[this.originalCustomTag] || b.globalTags[this.originalCustomTag];
                g && g.updated(a, c)
            }
        }
    }
      , w = function(a) {
        this.uuid = r(),
        this.comment = a,
        this.compile = function() {
            return ""
        }
    }
      , x = function(a, b) {
        u.apply(this, arguments),
        this.value = a.value,
        this.type = "text",
        this.bindings = {};
        var c = function() {
            return "_rotors.bind(data[0], '" + this.bindings.__element.u + "', typeof $key !== 'undefined' ? $key : null, typeof $value !== 'undefined' ? $value : null)"
        }
        .bind(this);
        this.compile = function(a) {
            return a.getExecutionContent(c(), this.uuid, !0) + ";_rotors.pet(_eid, '" + this.uuid + "');"
        }
        ,
        this.update = function(a, b) {
            a.nodeValue = this.bindings.__element.reapply(b)
        }
    }
      , y = function() {
        this.childNodes = [],
        this.appendChild = function(a) {
            this.childNodes.push(a)
        }
        ,
        this.toString = function() {
            for (var a = "", b = 0; b < this.childNodes.length; b++)
                a += this.childNodes[b].toString();
            return a
        }
    }
      , z = function(a) {
        y.apply(this),
        this.tag = a;
        var b = {};
        this.setAttribute = function(a, c) {
            b[a] = c
        }
        ,
        this.getAttribute = function(a) {
            return b[a]
        }
        ,
        this.setAttributeNS = function(a, c, d) {
            b[a + ":" + c] = d
        }
        ,
        this.toString = function() {
            var a = "<" + this.tag
              , c = "";
            for (var d in b)
                c += " " + d + '="' + b[d] + '"';
            a = a + c + ">";
            for (var e = 0; e < this.childNodes.length; e++)
                a += this.childNodes[e].toString();
            return a + "</" + this.tag + ">"
        }
    }
      , A = function(a) {
        this.nodeValue = a,
        this.toString = function() {
            return this.nodeValue
        }
    }
      , B = function(a) {
        return a.isBrowser ? i : null
    }
      , C = function(a, b, c) {
        return function(d) {
            var e = c ? null : a.cache[d];
            return null == e && (e = b(d)),
            null == e && (e = a.defaultTemplate),
            null != e && (a.cache[d] = e),
            e
        }
    }
      , D = function(a) {
        a = a || {},
        this.cache = {},
        this.templateCache = {},
        this.customTags = {},
        null != a.defaultTemplate && this.setDefaultTemplate(a.defaultTemplate),
        this.templateResolver = a.templateResolver ? a.templateResolver : a.templates ? function(b) {
            return a.templates[b]
        }
        : B(this),
        this.toggleManager = null
    }
      , E = function(a, b) {
        for (var c in b)
            b.hasOwnProperty(c) && (a[c] = b[c])
    };
    E(D.prototype, {
        bindings: {},
        entries: {},
        executions: {},
        bind: t,
        defaultTemplate: "<div></div>",
        defaultCompiledTemplate: null,
        setDefaultTemplate: function(a) {
            null != a ? (this.defaultTemplate = a,
            this.defaultCompiledTemplate = this.compile(this.parse(a))) : this.clearDefaultTemplate()
        },
        clearDefaultTemplate: function() {
            this.defaultTemplate = null,
            this.defaultCompiledTemplate = null
        },
        clearCache: function() {
            this.cache = {},
            this.templateCache = {}
        },
        namespaceHandlers: {
            svg: function(a) {
                return "e = document.createElementNS('http://www.w3.org/2000/svg', '" + a.split(":")[1] + "');e.setAttribute('version', '1.1');e.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');"
            }
        },
        namespaces: {
            xlink: "http://www.w3.org/1999/xlink"
        },
        each: function(a, b, c, d) {
            var e;
            if (j(a))
                for (e = 0; e < a.length; e++)
                    b(a[e], c, e, d);
            else
                for (e in a)
                    a.hasOwnProperty(e) && b({
                        $key: e,
                        $value: a[e]
                    }, c, e, d)
        },
        openRe: new RegExp("<([^/>]*?)>$|<([^/].*[^/])>$"),
        closeRe: new RegExp("^</([^>]+)>"),
        openCloseRe: new RegExp("<(.*)(/>$)"),
        tokenizerRe: /(<[^\^>]+\/>)|(<!--[\s\S]*?-->)|(<[\/a-zA-Z0-9\-:]+(?:\s*[a-zA-Z\-]+=\"[^\"]*\"|\s*[a-zA-Z\-]+='[^']+'|\s*[a-zA-Z\-]|\s*\{\{.*\}\})*>)/,
        commentRe: /<!--[\s\S]*?-->/,
        attributesRe: /([a-zA-Z0-9\-_:]+="[^"]*")|(\{\{if [^(?:\}\})]+\}\}.*\{\{\/if\}\})/,
        inlineIfRe: /\{\{if ([^\}]+)\}\}(.*)\{\{\/if\}\}/,
        singleExpressionRe: /^[\s]*\$\{([^\}]*)\}[\s]*$/,
        parseAttributes: function(a) {
            return null == a ? a : this.filterEmpty(a.replace("/>", ">").split(/^<|>$/)[1].split(this.attributesRe))
        },
        map: l,
        flatten: k,
        filter: m,
        data: h,
        uuid: r,
        filterEmpty: function(a) {
            return m(a, function(a) {
                return null != a && n(a).length > 0
            })
        },
        isBrowser: function() {
            return "undefined" != typeof navigator
        }(),
        isOldIE: function() {
            return d
        },
        cf: function() {
            return this.isBrowser ? this.isOldIE() ? a.document.createElement("div") : a.document.createDocumentFragment() : new y
        },
        ctn: function(b) {
            return this.isBrowser ? a.document.createTextNode(b) : new A(b)
        },
        ce: function(b) {
            return this.isBrowser ? a.document.createElement(b) : new z(b)
        },
        customElements: {
            "r-each": {
                parse: function(a, b, c, d) {
                    a.context = a.atts.in,
                    a.type = "each"
                },
                compile: function(a) {
                    var b = function() {
                        var b = "function(item, _rotorsLoopId, _rotorsLoopIndex, _rotorsLoopContext) { ";
                        b += "data.unshift(item);$value=item;$key=_rotorsLoopIndex;";
                        for (var c = 0; c < this.children.length; c++)
                            b += this.children[c].compile(a);
                        return b += "data.splice(0,1);",
                        b += "}"
                    }
                    .bind(this)
                      , c = ";_rotors.te(null, _eid, '" + this.uuid + "');"
                      , d = this.context ? ';data.unshift(_rotors.data(data[0], "' + this.context + '"));' : ""
                      , e = "_rotors.each(data[0], " + b() + ",'" + this.uuid + "', '" + this.context.replace(/'/g, "\\'") + "');"
                      , f = this.context ? ";data.splice(0, 1);" : ""
                      , g = ";_rotors.pet(_eid, '" + this.uuid + "');";
                    return c + d + e + f + g
                }
            },
            "r-if": {
                parse: function(a, b, c, d) {
                    a.test = a.atts.test
                },
                compile: function(a) {
                    var b, c = "", d = "", e = this.happyFlowChildren || this.children;
                    for (b = 0; b < e.length; b++)
                        c += e[b].compile(a) + ";";
                    if (null != this.happyFlowChildren) {
                        for (d = "else {",
                        b = 0; b < this.children.length; b++)
                            d += this.children[b].compile(a) + ";";
                        d += "}"
                    }
                    return ";with (data[0]) { if(" + this.test + ") { " + c + " }" + d + "}"
                }
            },
            "r-else": {
                remove: !0,
                parse: function(a, b, c, d, e) {
                    var f = I.peek(e);
                    null != f && "r-if" === f.tag && (f.happyFlowChildren = f.children,
                    f.children = [])
                },
                compile: function(a) {}
            },
            "r-for": {
                parse: function(a, b, c, d, e) {
                    a.loop = a.atts.loop
                },
                compile: function(a) {
                    var b = "";
                    b += "var __limit; with(data[0]){__limit=(" + this.loop + ");}",
                    b += "for(var $index=0;$index<__limit;$index++){data[0].$index=$index;";
                    for (var c = 0; c < this.children.length; c++)
                        b += this.children[c].compile(a) + ";";
                    return b += "}delete data[0].$index;"
                }
            },
            "r-tmpl": {
                remove: !0,
                parse: function(a, b, c, d, e, f) {
                    if (a.type = "template",
                    a.context = a.atts.context,
                    a.atts.lookup)
                        a.lookup = a.atts.lookup,
                        a.default = a.atts.default || "",
                        a.compile = function(b) {
                            return ';with(data[0]){var tlid=eval("' + a.lookup.replace(/[\$\{\}]/g, "") + '");}if (_rotors.templateCache[tlid] == null){var ___t = _rotors.templateResolver(tlid) || _rotors.templateResolver("' + a.default + '");_rotors.templateCache[tlid]=_rotors.compile(_rotors.parse(___t));} eval(_rotors.templateCache[tlid].functionBody);'
                        }
                        ;
                    else {
                        a.templateId = a.atts.id;
                        var g = s(e);
                        if (f.indexOf(a.templateId) !== -1) {
                            if (!g)
                                throw new TypeError("recursive template call [" + a.templateId + "]");
                            a.compile = function(b) {
                                return ";eval(_rotors.templateCache['" + a.templateId + "'].functionBody);"
                            }
                        } else {
                            var h = c(a.templateId);
                            f.push(a.templateId);
                            var i = d.parse(h, c, null, f);
                            null == d.templateCache[a.templateId] && (d.templateCache[a.templateId] = d.compile(i));
                            for (var j = 0; j < i.length; j++)
                                i[j].context = a.context;
                            d.debug("nested ast", i),
                            a.children = i,
                            f.pop()
                        }
                    }
                },
                precompile: function(a) {
                    return this.context ? ';data.unshift(_rotors.data(data[0], "' + this.context + '"));' : ""
                },
                postcompile: function(a) {
                    return this.context ? ";data.splice(0, 1);" : ""
                }
            },
            "r-html": {
                parse: function(a, b, c, d) {},
                compile: function(a) {
                    return ";var __hp=_rotors.parse(data[0].value),__hc=_rotors.compile(__hp,true);var __f=__hc(data[0], _rotors);Rotors.peek(_els).appendChild(__f.childNodes[0]);"
                }
            }
        },
        globalTags: {},
        registerTag: function(a, b, c) {
            this[c ? "globalTags" : "customTags"][a] = new e(this,a,b)
        },
        setAttribute: function(a, b, c) {
            var d = b.split(":");
            1 === d.length || null == this.namespaces[d[0]] ? a.setAttribute(d[0], c) : a.setAttributeNS(this.namespaces[d[0]], d[1], c)
        },
        setToggleManager: function(a) {
            this.toggleManager = a
        },
        debugEnabled: !1,
        debug: function() {
            this.debugEnabled && console.log.apply(console, arguments)
        },
        maybeDebug: function() {
            this.debugEnabled && arguments[0] && console.log.apply(console, arguments)
        },
        parse: function(a, b, c, d) {
            d = d || [],
            b = C(this, b || this.templateResolver, null);
            var e = []
              , g = []
              , h = this
              , i = function(a, b) {
                var c = a.match(b);
                return null != c && c
            }
              , j = function() {
                return e.length > 0 ? e[e.length - 1] : null
            }
              , k = function(a) {
                var b = j();
                return null != b && b.tag == a
            }
              , l = function(a, b) {
                e.length > 0 && j().children.push(a),
                b ? 0 == e.length && g.push(a) : e.push(a)
            }
              , m = function(a) {
                l(a, !0)
            }
              , p = function() {
                var a = e.pop();
                if (0 !== e.length || a.discard) {
                    if (a.discard) {
                        var b = I.peek(e);
                        b && b.children.pop()
                    }
                } else
                    g.push(a);
                return a
            }
              , q = function(a, b, c, d, f) {
                var g = new v(a,d)
                  , h = d.customElements[g.tag];
                return h && (h.parse(g, b, c, d, e, f),
                h.compile && (g.compile = h.compile),
                g.precompile = h.precompile,
                g.postcompile = h.postcompile,
                g.custom = !0,
                g.remove = h.remove,
                d.debug("  element is a custom element"),
                d.maybeDebug(g.remove, "  element's root should not appear in output")),
                g
            }
              , r = [{
                re: h.commentRe,
                handler: function(a, b, c, d) {
                    d.debug("comment", a, b),
                    l(new w(a), !0)
                }
            }, {
                re: h.openRe,
                handler: function(a, b, c, d, e) {
                    d.debug("open element", a, b);
                    var f = q(a, b, c, d, e);
                    l(f, f.remove)
                }
            }, {
                re: h.closeRe,
                handler: function(a, b, c, d) {
                    d.debug("close element", a, b);
                    var e = d.customElements[b[1]];
                    if (null == e || !e.remove) {
                        if (!k(b[1]))
                            throw new TypeError("Unbalanced closing tag '" + b[1] + "'; opening tag was '" + p().tag + "'");
                        p()
                    }
                }
            }, {
                re: h.openCloseRe,
                handler: function(a, b, c, d, e) {
                    d.debug("open and close element", a, b);
                    var f = q(a, b, c, d, e);
                    l(f, !0)
                }
            }, {
                re: /.*/,
                handler: function(a, b, c, d) {
                    d.debug("text node", a);
                    var e = new x({
                        value: a
                    },d);
                    m(e),
                    o("__element", a, e, null, d)
                }
            }];
            if (f(n(a).split(this.tokenizerRe), function(a, c) {
                for (var e = n(c), f = 0; f < r.length; f++) {
                    var g = i(e, r[f].re);
                    if (g) {
                        r[f].handler(c, g, b, this, d);
                        break
                    }
                }
            }
            .bind(this)),
            g.length > 0 && c)
                for (var s in c)
                    g[0][s] = c[s];
            return g
        },
        compile: function(a, b, c, d) {
            for (var e = "data=[data||{}];var frag=_rotors.cf(),_els=[],e,_le,__a,$value,$key,_eid = _rotors.nec();_els.push(frag);", f = "return frag;", g = [], h = 0; h < a.length; h++) {
                var i = "";
                a[h].precompile && (i += a[h].precompile(this)),
                i += a[h].compile(this, d),
                a[h].postcompile && (i += a[h].postcompile(this)),
                g.push(i)
            }
            var j = g.join("");
            if (this.debug("function body :", j),
            c)
                return j;
            var k = new Function("data,_rotors",e + j + f)
              , l = this;
            if (b)
                return k;
            var m = function(a) {
                return k.apply(this, [a, l])
            };
            return m.functionBody = j,
            m
        },
        nec: function() {
            var a = this.uuid();
            return this.executions[a] = {
                current: [{
                    children: []
                }]
            },
            a
        },
        te: function(a, b, c, d) {
            var e = {
                el: a,
                children: [],
                id: c,
                index: d
            };
            this.executions[b].current[0].children.push(e);
            var f = c + (null != d ? "-" + d : "");
            this.executions[b][f] = e,
            this.executions[b].current.unshift(e)
        },
        pet: function(a, b) {
            this.executions[a].current = this.executions[a].current.splice(1)
        },
        getExecutionContent: function(a, b, c, d, e) {
            var f = null != d ? this.namespaceHandlers[d](a) : c ? "e=_rotors.ctn(" + a + ");" : "e=_rotors.ce('" + a + "');";
            return f + "Rotors.peek(_els).appendChild(e);" + (c ? "" : "_els.push(e);") + "e._rotors=_rotors.entries['" + b + "'];e._rotorsEid=_eid;if(typeof _rotorsLoopId !== 'undefined') {e._rotorsLoopId=_rotorsLoopId;e._rotorsLoopIndex=_rotorsLoopIndex;e._rotorsLoopContext=_rotorsLoopContext;}_rotors.te(e, _eid, '" + b + "', typeof _rotorsLoopIndex != 'undefined' ? _rotorsLoopIndex : null);"
        },
        updaters: {},
        onUpdate: function(a, b) {
            if (null != a._rotors) {
                var c = a._rotors.instance;
                a._RotorsUpdate = a._RotorsUpdate || r(),
                c.updaters[a._RotorsUpdate] = c.updaters[a._RotorsUpdate] || [],
                c.updaters[a._RotorsUpdate].push(b)
            }
        },
        update: function(a, b) {
            var c, d, e, f = [], g = a._rotorsEid;
            if (null != g && null != a._rotors) {
                e = a._rotors.instance,
                c = e.executions[g];
                var h = a._rotorsLoopIndex
                  , i = a._rotors.uuid + (null != h ? "-" + h : "");
                d = c[i];
                var j = function(a, b, c) {
                    null != a && (a._rotors.update(a, b),
                    a._RotorsUpdate && e.updaters[a._RotorsUpdate] && f.push([a, e.updaters[a._RotorsUpdate], b]));
                    for (var d = 0; d < c.children.length; d++) {
                        var g = e.entries[c.children[d].id]
                          , h = "each" === e.entries[c.id].type
                          , i = h && null != c.children[d].el && null != c.children[d].el._rotorsLoopIndex ? b[c.children[d].el._rotorsLoopIndex] : e.data(b, g.context);
                        j(c.children[d].el, i, c.children[d])
                    }
                };
                j(a, b, d);
                for (var k = 0; k < f.length; k++)
                    for (var l = f[k], m = 0; m < l[1].length; m++)
                        try {
                            l[1][m](l[0], l[2])
                        } catch (a) {}
            }
        },
        updateExternal: function(a, b) {
            b = b || {};
            var c, d, e, f = function(a) {
                if (a.nodeType === Node.ELEMENT_NODE) {
                    for (var g = 0, i = a.attributes.length; g < i; g++)
                        c = a.attributes[g],
                        "rotors" === c.name ? (d = c.value,
                        a.innerHTML = h(b, d)) : 0 === c.name.indexOf("rotors-") && (d = c.value,
                        e = c.name.substring(7),
                        a.setAttribute(e, h(b, d)));
                    for (g = 0; g < a.childNodes.length; g++)
                        f(a.childNodes[g])
                }
            };
            f(a)
        },
        remove: function(a) {
            a._RotorsUpdate && this.updaters[a._RotorsUpdate] && delete this.updaters[a._RotorsUpdate],
            a._rotorsEid && this.executions[a._rotorsEid] && delete this.executions[a._rotorsEid]
        },
        template: function(a, b, c, d) {
            var e, f = d ? null : this.templateCache[a];
            if (null != f)
                return e = f(b),
                this.isOldIE() ? e.childNodes[0] : e;
            c = C(this, c || this.templateResolver, d);
            var g = c(a);
            if (null != g) {
                var h = this.parse(g, c, null, [a])
                  , i = this.compile(h);
                return this.templateCache[a] = i,
                e = i(b),
                this.isOldIE() ? e.childNodes[0] : e
            }
            return this.cf()
        },
        precompileTemplate: function(a, b) {
            var c = this.parse(a, b || this.templateResolver);
            return this.compile(c, !0)
        },
        precompileTemplates: function(a, b) {
            var c = function(c) {
                var d = a[c];
                return d || (b || this.templateResolver)(c)
            }
              , d = {};
            for (var e in a)
                d[e] = this.precompileTemplate(a[e], c);
            return d
        },
        importTemplate: function(a, b) {
            var c = this;
            b = "string" == typeof b ? Function("data", "_rotors", b) : b,
            this.templateCache[a] = function(a) {
                return b.apply(c, [a, c])
            }
        },
        importTemplates: function(a) {
            for (var b in a)
                this.importTemplate(b, a[b])
        },
        importBindings: function(a) {
            this.bindings = this.bindings || {};
            for (var b in a) {
                var c = a[b];
                this.bindings[b] = {
                    e: c.e,
                    u: c.u,
                    w: c.w,
                    reapply: Function("$data", c.reapply)
                }
            }
        }
    });
    var F = function(a) {
        return new D(a)
    }
      , G = function(a) {
        var b = {};
        for (var c in a.bindings) {
            var d = a.bindings[c];
            b[c] = {
                e: d.e,
                u: d.u,
                w: d.w,
                reapply: String(d.reapply).replace(/^function\s*\S+\s*\([^)]*\)\s*\{|\}$/g, "")
            }
        }
        return b
    }
      , H = function(b, c) {
        c = c || "rotors";
        var d, e = a.Rotors.newInstance(), f = {}, g = new RegExp("<script type=['\"]" + c + "['\"] id=['\"]([^'\"]+)['\"]>((.*\n)*?)</script>","g");
        d = b.replace(g, function(a, b, c) {
            return f[b] = c,
            ""
        });
        var h = [{}, null, d];
        for (var i in f)
            h[0][i] = String(e.precompileTemplate(f[i], function(a) {
                return f[a]
            })).replace(/^function\s*\S+\s*\([^)]*\)\s*\{|\}$/g, "");
        return h[1] = G(e),
        h
    }
      , I = a.Rotors = {
        newInstance: F,
        precompile: H,
        data: h,
        version: "0.3.17",
        peek: b
    };
    "undefined" != typeof exports && (exports.Rotors = I,
    exports.RotorsInstance = D)
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    var a = this;
    a.jsPlumbToolkitUtil = a.jsPlumbToolkitUtil || {};
    var b = a.jsPlumbToolkitUtil
      , c = function(a, b) {
        return function() {
            return a.apply(b, arguments)
        }
    };
    b.requestAnimationFrame = c(a.requestAnimationFrame || a.webkitRequestAnimationFrame || a.mozRequestAnimationFrame || a.oRequestAnimationFrame || a.msRequestAnimationFrame || function(b, c) {
        a.setTimeout(b, 10)
    }
    , a);
    b.ajax = function(a) {
        var b = window.XMLHttpRequest ? new XMLHttpRequest : new ActiveXObject("Microsoft.XMLHTTP")
          , c = a.type || "GET";
        if (b) {
            var d = "json" === a.dataType ? function(a) {
                return JSON.parse(a)
            }
            : function(a) {
                return a
            }
            ;
            b.open(c, a.url, !0);
            var e = a.headers || {};
            for (var f in e)
                b.setRequestHeader(f, e[f]);
            b.onreadystatechange = function() {
                4 === b.readyState && ("2" === ("" + b.status)[0] ? a.success(d(b.responseText)) : a.error && a.error(b.responseText, b.status))
            }
            ,
            b.send(a.data ? JSON.stringify(a.data) : null)
        } else
            a.error && a.error("ajax not supported")
    }
    ,
    b.debounce = function(a, b) {
        b = b || 150;
        var c = null;
        return function() {
            window.clearTimeout(c),
            c = window.setTimeout(a, b)
        }
    }
    ,
    b.xml = {
        setNodeText: function(a, b) {
            a.text = b;
            try {
                a.textContent = b
            } catch (a) {}
        },
        getNodeText: function(a) {
            return null != a ? a.text || a.textContent : ""
        },
        getChild: function(a, b) {
            for (var c = null, d = 0; d < a.childNodes.length; d++)
                if (1 === a.childNodes[d].nodeType && a.childNodes[d].nodeName === b) {
                    c = a.childNodes[d];
                    break
                }
            return c
        },
        getChildren: function(a, b) {
            for (var c = [], d = 0; d < a.childNodes.length; d++)
                1 === a.childNodes[d].nodeType && a.childNodes[d].nodeName === b && c.push(a.childNodes[d]);
            return c
        },
        xmlToString: function(a) {
            try {
                return (new XMLSerializer).serializeToString(a).replace(/\s*xmlns=\"http\:\/\/www.w3.org\/1999\/xhtml\"/g, "")
            } catch (b) {
                try {
                    return a.xml
                } catch (a) {
                    throw new Error("Cannot serialize XML " + a)
                }
            }
            return !1
        },
        createElement: function(a, b, c) {
            var d;
            try {
                d = new ActiveXObject("Microsoft.XMLDOM").createNode(1, a, "")
            } catch (b) {
                d = document.createElement(a)
            }
            if (c && jsPlumbToolkitUtil.xml.setNodeText(d, c),
            b)
                for (var e in b)
                    d.setAttribute(e, b[e]);
            return d
        }
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this;
    a.jsPlumbToolkitUtil = a.jsPlumbToolkitUtil || {};
    var b = a.jsPlumbToolkitUtil
      , c = a.jsPlumbUtil;
    b.fastTrim = function(a) {
        for (var b = a.replace(/^\s\s*/, ""), c = /\s/, d = b.length; c.test(b.charAt(--d)); )
            ;
        return b.slice(0, d + 1)
    }
    ,
    b.uuid = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(a) {
            var b = 16 * Math.random() | 0
              , c = "x" == a ? b : 3 & b | 8;
            return c.toString(16)
        })
    }
    ,
    b.each = function(a, b) {
        a = null == a.length || "string" == typeof a ? [a] : a;
        for (var c = 0; c < a.length; c++)
            b(a[c])
    }
    ,
    b.populate = function(a, b) {
        var d = function(a) {
            var c = a.match(/(\${.*?})/g);
            if (null != c)
                for (var d = 0; d < c.length; d++) {
                    var e = b[c[d].substring(2, c[d].length - 1)];
                    e && (a = a.replace(c[d], e))
                }
            return a
        }
          , e = function(a) {
            if (null != a) {
                if (c.isString(a))
                    return d(a);
                if (c.isArray(a)) {
                    for (var b = [], f = 0; f < a.length; f++)
                        b.push(e(a[f]));
                    return b
                }
                if (c.isObject(a)) {
                    var b = {};
                    for (var f in a)
                        b[f] = e(a[f]);
                    return b
                }
                return a
            }
        };
        return e(a)
    }
    ,
    b.mergeWithParents = function(a, b, d) {
        d = d || "parent";
        var e = function(a) {
            return a ? b[a] : null
        }
          , f = function(a) {
            return a ? e(a[d]) : null
        }
          , g = function(a, b) {
            if (null == a)
                return b;
            var d = c.merge(a, b);
            return g(f(a), d)
        }
          , h = function(a) {
            if (null == a)
                return {};
            if ("string" == typeof a)
                return e(a);
            if (a.length) {
                for (var b, c = !1, d = 0; !c && d < a.length; )
                    b = h(a[d]),
                    b ? c = !0 : d++;
                return b
            }
        }
          , i = h(a);
        return i ? g(f(i), i) : {}
    }
    ,
    "undefined" != typeof exports && (exports.jsPlumbToolkitUtil = b)
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    var a = this
      , b = a.jsPlumb
      , c = a.jsPlumbUtil
      , d = {
        nodeTraverseStart: "startNodeTraversal",
        nodeTraverseEnd: "endNodeTraversal",
        start: "startOverlayAnimation",
        end: "endOverlayAnimation"
    }
      , e = {
        nodeTraversing: "jtk-animate-node-traversing",
        edgeTraversing: "jtk-animate-edge-traversing",
        nodeTraversable: "jtk-animate-node-traversable",
        edgeTraversable: "jtk-animate-edge-traversable"
    };
    b.Connection.prototype.animateOverlay = function(a, f) {
        var g = this
          , h = new c.EventGenerator
          , i = g.getConnector().getLength();
        f = f || {};
        var j, k, l, m = c.uuid(), n = f.forwards !== !1, o = f.rate || 30, p = f.dwell || 250, q = f.speed || 100, r = i / q * 1e3, s = r / o, t = 1 / s * (n ? 1 : -1), u = f.isFinal !== !1, v = n ? 0 : 1, w = v, x = function() {
            return n ? w >= 1 : w <= 0
        }, y = n ? g.source : g.target, z = n ? g.target : g.source;
        if ("string" == typeof a)
            l = [a, {
                location: v,
                id: m
            }];
        else {
            var A = b.extend({}, a[1]);
            A.location = v,
            A.id = m,
            l = [a[0], A]
        }
        var B = function() {
            g.removeOverlay(m),
            window.clearInterval(j),
            u ? (b.addClass(z, e.nodeTraversing),
            window.setTimeout(function() {
                b.removeClass(z, e.nodeTraversing),
                g.removeClass(e.edgeTraversing),
                h.fire(d.end, g)
            }, p)) : (g.removeClass(e.edgeTraversing),
            h.fire(d.end, g))
        }
          , C = function() {
            w += t,
            x() ? B() : (k.loc = w,
            g.repaint())
        }
          , D = function() {
            h.fire(d.start, g),
            k = g.addOverlay(l),
            j = window.setInterval(C, o)
        }
          , E = function() {
            h.fire(d.nodeTraverseStart, {
                connection: g,
                element: y
            }),
            b.addClass(y, e.nodeTraversing),
            g.addClass(e.edgeTraversing),
            window.setTimeout(function() {
                b.removeClass(y, e.nodeTraversing),
                h.fire(d.nodeTraverseEnd, {
                    connection: g,
                    element: y
                }),
                D()
            }, p)
        };
        return f.previous ? f.previous.bind(d.end, E) : E(),
        h
    }
}
.call("undefined" == typeof window ? this : window),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = ["node", "port", "edge", "group"]
      , c = ["Refreshed", "Added", "Removed", "Updated", "Moved"]
      , d = ["edge"]
      , e = ["Source", "Target"]
      , f = function(a, b, c, d) {
        for (var e = 0; e < a.length; e++)
            for (var f = 0; f < b.length; f++)
                c.bind(a[e] + b[f], d)
    };
    a.jsPlumbToolkitUtil.AutoSaver = function(a, g, h, i, j, k, l) {
        function m(a) {
            return function() {
                a && a.apply(a, arguments),
                l && l()
            }
        }
        var n = !1
          , o = function() {
            if (!n) {
                try {
                    k && k()
                } catch (a) {}
                a.save({
                    url: g,
                    success: m(i),
                    error: m(j),
                    headers: h
                })
            }
        };
        a.bind("dataLoadStart", function() {
            n = !0
        }),
        a.bind("dataLoadEnd", function() {
            n = !1
        }),
        a.bind("graphClearStart", function() {
            n = !0
        }),
        a.bind("graphCleared", function() {
            n = !1
        }),
        f(b, c, a, o),
        f(d, e, a, o)
    }
    ,
    a.jsPlumbToolkitUtil.CatchAllEventHandler = function(a) {
        var g = function() {
            a.fire("dataUpdated")
        };
        f(b, c, a, g),
        f(d, e, a, g)
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    var a = this
      , b = a.jsPlumbToolkitUtil
      , c = a.jsPlumbUtil;
    b.Selection = function(a) {
        c.EventGenerator.apply(this, arguments);
        var d, e = a.toolkit, f = [], g = [], h = [], i = Math.Infinity, j = Math.Infinity, k = Math.Infinity, l = a.generator, m = {}, n = this, o = a.onClear || function() {}
        , p = function(a) {
            return "Edge" === a.objectType ? h : "Node" === a.objectType ? f : g
        }, q = function(a) {
            var c = []
              , e = p(a)
              , f = "Edge" === a.objectType ? j : "Node" === a.objectType ? i : k;
            if (e.length >= f) {
                if (d === b.Selection.DISCARD_NEW)
                    return !1;
                c = e.splice(0, 1),
                r(c[0], "Removed"),
                delete m[c[0].getFullId()]
            }
            return e.push(a),
            r(a, "Added"),
            c
        }, r = function(a, b) {
            var c = a.objectType.toLowerCase() + b
              , d = {
                Group: {
                    data: a.data,
                    group: a
                },
                Node: {
                    data: a.data,
                    node: a
                },
                Port: {
                    data: a.data,
                    node: a.node,
                    port: a
                },
                Edge: {
                    data: a.data,
                    edge: a
                }
            };
            n.fire(c, d[a.objectType])
        };
        this.getModel = e.getModel,
        this.setSuspendGraph = e.setSuspendGraph,
        this.getNodeId = e.getNodeId,
        this.getGroupId = e.getNodeId,
        this.getEdgeId = e.getEdgeId,
        this.getPortId = e.getPortId,
        this.getNodeType = e.getNodeType,
        this.getGroupType = e.getNodeType,
        this.getEdgeType = e.getEdgeType,
        this.getPortType = e.getPortType,
        this.getObjectInfo = e.getObjectInfo,
        this.isDebugEnabled = e.isDebugEnabled;
        var s = function(a, b) {
            if (!m[a.getFullId()]) {
                var c = q(a);
                return c === !1 ? [[], []] : (m[a.getFullId()] = a,
                b && b(a, !0),
                [[a], c])
            }
            return [[], []]
        }
          , t = function(a, b) {
            var d = c.removeWithFunction(p(a), function(b) {
                return b.id == a.id
            });
            return d && r(a, "Removed"),
            delete m[a.getFullId()],
            b && b(a, !1),
            [[], []]
        }
          , u = function(a, b) {
            return m[a.getFullId()] ? t(a, b) : s(a, b)
        }
          , v = function(a, b, d) {
            var f, g = [], h = [];
            if (null == a)
                return g;
            var i = function(a) {
                var j;
                if (c.isString(a))
                    j = e.getNode(a) || e.getEdge(a) || e.getGroup(a),
                    null != j && (f = b(j, d),
                    g.push.apply(g, f[0]),
                    h.push.apply(h, f[1]));
                else if (a.eachNode && a.eachEdge)
                    a.eachNode(function(a, b) {
                        i(b)
                    }),
                    a.eachEdge(function(a, b) {
                        i(b)
                    }),
                    a.eachGroup && a.eachGroup(function(a, b) {
                        i(b)
                    });
                else if (a.each)
                    a.each(function(a, b) {
                        i(b.vertex || b)
                    });
                else if (null != a.length)
                    for (var k = 0; k < a.length; k++)
                        i(a[k], d);
                else
                    f = b(a, d),
                    g.push.apply(g, f[0]),
                    h.push.apply(h, f[1])
            };
            return i(a),
            [g, h]
        }
        .bind(this);
        e.bind("nodeRemoved", function(a) {
            t(a.node)
        }),
        e.bind("groupRemoved", function(a) {
            t(a.group)
        }),
        e.bind("portRemoved", function(a) {
            t(a.port)
        }),
        e.bind("edgeRemoved", function(a) {
            t(a.edge)
        }),
        e.bind("edgeTarget", function(a) {
            m[a.edge.getFullId()] && n.fire("edgeTarget", a)
        }),
        e.bind("edgeSource", function(a) {
            m[a.edge.getFullId()] && n.fire("edgeSource", a)
        }),
        e.bind("nodeUpdated", function(a) {
            m[a.node.getFullId()] && n.fire("nodeUpdated", a)
        }),
        e.bind("groupUpdated", function(a) {
            m[a.group.getFullId()] && n.fire("groupUpdated", a)
        }),
        e.bind("edgeUpdated", function(a) {
            m[a.edge.getFullId()] && n.fire("edgeUpdated", a)
        }),
        e.bind("portUpdated", function(a) {
            m[a.port.getFullId()] && n.fire("portUpdated", a)
        }),
        this.remove = function(a, b) {
            return v(a, t, b)
        }
        ,
        this.append = function(a, b) {
            return v(a, s, b)
        }
        ,
        this.toggle = function(a, b) {
            return v(a, u, b)
        }
        ,
        this.setMaxNodes = function(a) {
            i = a
        }
        ,
        this.setMaxEdges = function(a) {
            j = a
        }
        ,
        this.setCapacityPolicy = function(a) {
            d = a
        }
        ,
        this.clear = function(a) {
            f.length = 0,
            h.length = 0,
            g.length = 0,
            m = {},
            a || o(this)
        }
        ,
        this.reload = function() {
            if (null != l) {
                this.clear();
                var a;
                for (this.fire("dataLoadStart"),
                l(this, e),
                a = 0; a < g.length; a++)
                    n.fire("groupAdded", g[a]);
                for (a = 0; a < f.length; a++)
                    n.fire("nodeAdded", f[a]);
                for (a = 0; a < h.length; a++)
                    n.fire("edgeAdded", h[a]);
                this.fire("dataLoadEnd")
            }
        }
        ,
        this.each = function(a, b) {
            for (var d = "Edge" === b ? h : "Group" === b ? g : f, e = 0; e < d.length; e++)
                try {
                    a(e, d[e])
                } catch (a) {
                    c.log("Selection iterator function failed", a)
                }
        }
        ,
        this.eachNode = this.each,
        this.eachGroup = function(a) {
            this.each(a, "Group")
        }
        ,
        this.eachNodeOrGroup = function(a) {
            this.each(a, "Node"),
            this.each(a, "Group")
        }
        ,
        this.eachEdge = function(a) {
            this.each(a, "Edge")
        }
        ,
        this.getNodeCount = function() {
            return f.length
        }
        ,
        this.getNodeAt = function(a) {
            return f[a]
        }
        ,
        this.getNodes = function() {
            return f
        }
        ,
        this.getNode = e.getNode,
        this.getGroupAt = function(a) {
            return g[a]
        }
        ,
        this.getGroups = function() {
            return g
        }
        ,
        this.getGroup = e.getGroup,
        this.getGroupCount = function() {
            return g.length
        }
        ,
        this.getAll = function() {
            var a = [];
            return Array.prototype.push.apply(a, f),
            Array.prototype.push.apply(a, h),
            Array.prototype.push.apply(a, g),
            a
        }
        ,
        this.getAllEdgesFor = function(a) {
            for (var b = a.getAllEdges(), c = [], d = 0; d < b.length; d++)
                null != m[b[d].getId()] && c.push(b[d]);
            return c
        }
        ,
        this.getEdgeCount = function() {
            return h.length
        }
        ,
        this.get = this.getNodeAt = function(a) {
            return f[a]
        }
        ,
        this.getEdge = this.getEdgeAt = function(a) {
            return h[a]
        }
        ,
        this.setCapacityPolicy(b.Selection.DISCARD_EXISTING)
    }
    ,
    b.Selection.DISCARD_EXISTING = "discardExisting",
    b.Selection.DISCARD_NEW = "discardNew"
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumbGraph = {};
    b.version = "0.1",
    b.name = "jsPlumbGraph";
    var c = function(a, b) {
        var c = {};
        this.setAttribute = function(a, b) {
            c[a] = b
        }
        ,
        this.getAttribute = function(a) {
            return c[a]
        }
        ;
        var d = b.getType(a || {});
        this.getType = function() {
            return d
        }
        ,
        this.setType = function(a) {
            d = a
        }
        ,
        this.graph = b
    }
      , d = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(a) {
            var b = 16 * Math.random() | 0
              , c = "x" == a ? b : 3 & b | 8;
            return c.toString(16)
        })
    }
      , e = function(a, b, c) {
        if (null == a)
            return d();
        if ("string" == typeof a)
            return a;
        var e = b || c.getIdFunction();
        return e(a) || d()
    }
      , f = function(a) {
        return "string" == typeof a ? {
            id: a
        } : a
    }
      , g = b.Vertex = b.Node = function(a, d, g) {
        c.apply(this, [a, g]),
        this.objectType = "Node",
        this.id = e(a, d, g),
        this.data = f(a),
        this.getFullId = function() {
            return this.id
        }
        ;
        var i = []
          , j = 0
          , k = 0
          , l = []
          , m = []
          , n = {};
        this.getEdges = function(a) {
            if (null == a || null == a.filter)
                return i;
            for (var b = [], c = 0; c < i.length; c++)
                a.filter(i[c]) && b.push(i[c]);
            return b
        }
        ,
        this.getSourceEdges = function() {
            return this.getEdges({
                filter: function(a) {
                    return a.source == this
                }
                .bind(this)
            })
        }
        ,
        this.getTargetEdges = function() {
            return this.getEdges({
                filter: function(a) {
                    return a.target == this
                }
                .bind(this)
            })
        }
        ,
        this.addEdge = function(a) {
            i.push(a),
            a.source !== this && a.isDirected() || k++,
            a.target !== this && a.isDirected() || j++
        }
        ,
        this.deleteEdge = function(a) {
            for (var b = -1, c = 0; c < i.length; c++)
                if (i[c].getId() === a.getId()) {
                    b = c;
                    break
                }
            return b > -1 && (i.splice(b, 1),
            a.source !== this && a.isDirected() || k--,
            a.target !== this && a.isDirected() || j--,
            !0)
        }
        ,
        this.getAllEdges = function(a) {
            for (var b = this.getEdges(a).slice(0), c = 0; c < l.length; c++)
                b.push.apply(b, l[c].getEdges(a));
            return b
        }
        ,
        this.addGraph = function(a) {
            return a = "string" == typeof a ? new b.Graph({
                id: a
            }) : a,
            m.push(a),
            a.id || (a.id = "" + m.length),
            a
        }
        ,
        this.getGraph = function(a) {
            for (var b = 0; b < m.length; b++)
                if (m[b].id === a)
                    return m[b]
        }
        ,
        this.getIndegreeCentrality = function() {
            for (var a = 0, b = 0; b < l.length; b++)
                a += l[b].getIndegreeCentrality();
            return j + a
        }
        ,
        this.getOutdegreeCentrality = function() {
            for (var a = 0, b = 0; b < l.length; b++)
                a += l[b].getOutdegreeCentrality();
            return k + a
        }
        ,
        this.getPorts = function() {
            return l
        }
        ,
        this.addPort = function(a, b) {
            var c = e(a, b, g)
              , d = this.getPort(c);
            return null == d && (d = new h(a,b,this),
            l.push(d),
            n[d.id] = d),
            d
        }
        ,
        this.setPort = function(a, b) {
            var c = this.getPort(a);
            return c || (c = this.addPort({
                id: a
            })),
            c.data = b,
            c.setType(this.graph.getType(b)),
            c
        }
        ,
        this.getPort = function(a) {
            return n[a]
        }
        ;
        var o = function(a) {
            return a.constructor == b.Port ? a.id : a
        };
        this.removePort = function(a) {
            if (a) {
                for (var b = o(a), c = -1, d = !1, e = 0; e < l.length; e++)
                    if (l[e].id === b) {
                        c = e;
                        break
                    }
                if (c != -1) {
                    var f = l[c];
                    g.deleteVertex(f),
                    l.splice(c, 1),
                    d = !0
                }
                delete n[b]
            }
            return d
        }
        ;
        var p = 0
          , q = {};
        this.setDefaultInternalCost = function(a) {
            p = a
        }
        ,
        this.getInternalEdge = function(a, b) {
            var c = o(a)
              , d = o(b)
              , e = {
                source: n[c],
                target: n[d],
                cost: 1 / 0
            };
            if (e.source && e.target) {
                var f = q[c + "-" + d] || {
                    cost: p,
                    directed: !1
                };
                for (var g in f)
                    e[g] = f[g]
            }
            return e
        }
        ,
        this.setInternalEdge = function(a, b, c, d) {
            var e = o(a)
              , f = o(b);
            return q[e + "-" + f] = {
                cost: c || p,
                directed: d
            },
            this.getInternalEdge(a, b)
        }
        ,
        this.inspect = function() {
            for (var a = "{ id:" + this.id + ", edges:[\n", b = 0; b < i.length; b++)
                a += i[b].inspect() + "\n";
            return a += "]}"
        }
    }
      , h = b.Port = function(a, b, c) {
        g.apply(this, [a, b, c.graph]),
        this.objectType = "Port",
        this.getNode = function() {
            return c
        }
        ,
        this.getFullId = function() {
            return c.id + this.graph.getPortSeparator() + this.id
        }
        ,
        this.isChildOf = function(a) {
            return c == a
        }
        ,
        this.getPorts = this.addPort = this.deletePort = this.getPort = null
    }
      , i = b.Edge = function(a) {
        c.call(this, a.data, a.graph),
        this.source = a.source,
        this.target = a.target,
        this.objectType = "Edge";
        var b = a.cost || 1
          , d = !(a.directed === !1)
          , e = a.id
          , f = null;
        this.data = a.data || {},
        this.getCost = function() {
            return b
        }
        ,
        this.setCost = function(a) {
            b = a
        }
        ,
        this.getId = this.getFullId = function() {
            return null === e ? this.source.id + "_" + this.target.id : e
        }
        ,
        this.setId = function(a) {
            e = a
        }
        ,
        this.isDirected = function() {
            return d
        }
        ,
        this.setDirected = function(a) {
            d = a
        }
        ,
        this.inspect = function() {
            if (null != e)
                return "{ id:" + e + ", connectionId:" + f + ", cost:" + b + ", directed:" + d + ", source:" + this.source.id + ", target:" + this.target.id + "}"
        }
    }
      , j = b.Group = function(a, b, c) {
        g.apply(this, arguments),
        this.objectType = "Group";
        var d = []
          , e = {};
        this.addVertex = this.addNode = function(a) {
            return null == e[a.id] && (d.push(a),
            e[a.id] = a,
            a.group = this,
            !0)
        }
        ,
        this.getVertexCount = this.getNodeCount = function() {
            return d.length
        }
        ,
        this.getVertices = this.getNodes = function() {
            return d
        }
        ,
        this.deleteVertex = this.deleteNode = function(a) {
            if (a = "string" == typeof a ? e[a] : a) {
                var b = d.indexOf(a);
                b != -1 && (d.splice(b, 1),
                delete e[a.id]),
                delete a.group
            }
        }
        ,
        this.cleanup = function(a) {
            var b, e = this.getAllDirectEdges(), f = e.length;
            for (b = 0; b < f; b++)
                c.deleteEdge(e[0]);
            var g = d.length;
            for (b = 0; b < g; b++)
                a ? c.deleteVertex(d[0]) : delete d[0].group;
            d.length = 0
        }
        ,
        this.getAllDirectEdges = function(a) {
            var b, c = [];
            c.push.apply(c, this.getEdges(a).slice(0));
            var d = this.getPorts();
            for (b = 0; b < d.length; b++)
                c.push.apply(c, d[b].getEdges(a));
            return c
        }
        ,
        this.getAllEdges = function(a) {
            for (var b = [], c = {}, e = 0; e < d.length; e++)
                Array.prototype.push.apply(b, d[e].getAllEdges(a).filter(function(a) {
                    var b = a.getId()
                      , d = null == c[b];
                    return c[b] = !0,
                    d
                }));
            return b.push.apply(b, this.getAllDirectEdges(a)),
            b
        }
    }
      , k = b.Cluster = function(a) {
        this.vertices = [a],
        this.addVertex = function(a) {
            this.vertices.push(a)
        }
    }
      , l = (b.Graph = function(a) {
        a = a || {},
        this.vertices = [],
        this.edges = [],
        this.groups = [],
        this.id = a.id;
        var c = {}
          , d = 0
          , f = {}
          , h = 0
          , l = {}
          , m = 0
          , n = !(a.defaultDirected === !1)
          , q = a.defaultCost || 1
          , r = a.idFunction || function(a) {
            return a.id
        }
          , s = a.typeFunction || function(a) {
            return a.type || "default"
        }
          , t = a.enableSubgraphs === !0
          , u = a.portSeparator || "."
          , v = {}
          , w = function(a) {
            delete v[a.id]
        }
          , x = function(a) {
            v[a.id] = a
        }
          , y = function() {
            v = {}
        };
        this.setIdFunction = function(a) {
            r = a
        }
        ,
        this.getIdFunction = function() {
            return r
        }
        ,
        this.setTypeFunction = function(a) {
            s = a
        }
        ,
        this.getType = function(a) {
            return s(a)
        }
        ,
        this.getTopLevelElements = function() {
            return v
        }
        ,
        this.setEnableSubgraphs = function(a) {
            t = a
        }
        ,
        this.setPortSeparator = function(a) {
            u = a
        }
        ,
        this.getPortSeparator = function() {
            return u
        }
        ;
        var z = function(a, d) {
            if (null == a)
                return null;
            if ("string" != typeof a) {
                if (a.constructor == b.Port || a.constructor == b.Node || a.constructor == b.Group)
                    return a;
                var e = a;
                if (a = r(a),
                "string" != typeof a)
                    return e
            }
            var f = t ? a.split("/") : [a]
              , g = function(a) {
                if (c[a])
                    return c[a];
                if (l[a])
                    return l[a];
                var b = a.split(u)
                  , e = b[0]
                  , f = c[e] || l[e];
                if (2 === b.length && null != f) {
                    var g = f.getPort(b[1]);
                    return null == g && d && (g = f.addPort(b[1])),
                    g
                }
                return f
            };
            if (1 == f.length)
                return g(f[0]);
            if (f.length > 1 && f % 2 == 0)
                throw "Subgraph path format error.";
            for (var h = null, i = null, j = 0; j < f.length - 1; j += 2)
                h = g(f[j]),
                i = h.getGraph(f[j + 1]);
            return i.getVertex(f[f.length - 1])
        };
        this.clear = function() {
            this.vertices.length = 0,
            this.groups.length = 0,
            d = 0,
            h = 0,
            c = {},
            f = {},
            l = {},
            y()
        }
        ,
        this.getVertices = this.getNodes = function() {
            return this.vertices
        }
        ,
        this.getVertexCount = this.getNodeCount = function() {
            return this.vertices.length
        }
        ,
        this.getVertexAt = this.getNodeAt = function(a) {
            return this.vertices[a]
        }
        ,
        this.getEdgeCount = function() {
            return h
        }
        ,
        this.addEdge = function(a, b, c) {
            var d = null == a.directed ? n === !0 : !(a.directed === !1)
              , g = a.cost || q
              , j = e(a.data, b, this)
              , k = z(a.source, !0)
              , l = z(a.target, !0);
            if (null == k || null == k.objectType)
                throw new TypeError("Unknown source node [" + a.source + "]");
            if (null == l || null == l.objectType)
                throw new TypeError("Unknown target node [" + a.target + "]");
            if (c && !c(k, l))
                return null;
            var m = new i({
                source: k,
                target: l,
                cost: g,
                directed: d,
                data: a.data || {},
                id: j,
                graph: this
            });
            return m.source.addEdge(m),
            m.source !== m.target && m.target.addEdge(m),
            f[j] = m,
            h++,
            m
        }
        ,
        this.addVertex = this.addNode = function(a, b) {
            var e = new g(a,b || r,this);
            return c[e.id] ? null : (this.vertices.push(e),
            c[e.id] = e,
            e._id = d++,
            x(e),
            e)
        }
        ,
        this.addVertices = this.addNodes = function(a, b) {
            for (var c = 0; c < a.length; c++)
                this.addVertex(a[c], b || r)
        }
        ,
        this.addGroup = function(a, b) {
            var c = new j(a,b || r,this);
            return l[c.id] ? l[c.id] : (this.groups.push(c),
            l[c.id] = c,
            c._id = m++,
            x(c),
            c)
        }
        ,
        this.getGroupCount = function() {
            return this.groups.length
        }
        ,
        this.getGroupAt = function(a) {
            return this.groups[a]
        }
        ,
        this.addVertexToGroup = function(a, b) {
            b = "string" == typeof b ? l[b] : b,
            a = z(a),
            a && b && (b.addVertex(a),
            w(a))
        }
        ,
        this.addVerticesToGroup = function(a, b) {
            for (var c = 0; c < a.length; c++)
                this.addVertexToGroup(a[c], b)
        }
        ,
        this.deleteVertexFromGroup = function(a) {
            a = z(a),
            a && a.group && (a.group.deleteVertex(a),
            x(a))
        }
        ,
        this.deleteVerticesFromGroup = function(a, b) {
            for (var c = 0; c < a.length; c++)
                this.deleteVertexFromGroup(a[c], b)
        }
        ,
        this.deleteGroup = function(a, b) {
            if (a = "string" == typeof a ? l[a] : a) {
                a.cleanup(b),
                delete l[a.id];
                for (var c = -1, d = 0; d < this.groups.length; d++)
                    if (this.groups[d].id === a.id) {
                        c = d;
                        break
                    }
                return c > -1 && this.groups.splice(c, 1),
                w(a),
                a
            }
        }
        ,
        this.getGroup = function(a) {
            return "string" == typeof a ? l[a] : a
        }
        ,
        this.deleteVertex = this.deleteNode = function(a) {
            var b = z(a);
            if (b) {
                for (var e = -1, f = 0; f < this.vertices.length; f++)
                    if (this.vertices[f].id === b.id) {
                        e = f;
                        break
                    }
                e > -1 && (this.vertices.splice(e, 1),
                null != b.group && b.group.deleteVertex(b));
                for (var g = b.getEdges(), i = 0; i < g.length; i++)
                    this.deleteEdge(g[i]);
                if (h -= g.length,
                b.getPorts)
                    for (var j = b.getPorts(), k = 0; k < j.length; k++)
                        this.deleteVertex(j[k]);
                delete c[b.id],
                d--,
                w(b)
            }
        }
        ,
        this.deleteEdge = function(a) {
            if (a = this.getEdge(a),
            null != a) {
                var b = z(a.source);
                b && b.deleteEdge(a) && h--;
                var c = z(a.target);
                c && c.deleteEdge(a),
                delete f[a.getId()]
            }
        }
        ,
        this.getEdge = function(a) {
            if (null != a) {
                if ("string" != typeof a) {
                    if (a.constructor == b.Edge)
                        return a;
                    var c = a;
                    if (a = r(a),
                    "string" != typeof a)
                        return c
                }
                return f[a]
            }
        }
        ,
        this.getEdges = function(a) {
            a = a || {};
            var b, c = a.source, d = a.target, e = a.filter || function() {
                return !0
            }
            , g = function(a) {
                return !(null != c && a.source == j !== c || null != d && a.target == j !== d)
            }, h = [], i = function(a) {
                e(a) && g(a) && h.push(a)
            };
            if (a.node) {
                var j = z(a.node)
                  , k = j.getAllEdges();
                for (b = 0; b < k.length; b++)
                    i(k[b])
            } else
                for (b in f)
                    i(f[b]);
            return h
        }
        ,
        this.getAllEdges = function() {
            var a = [];
            for (var b in f)
                a.push(f[b]);
            return a
        }
        ,
        this.findPath = function(a, b, c, d, e) {
            return a = z(a),
            b = z(b),
            p.compute({
                graph: this,
                source: a,
                target: b,
                strict: !(c === !1),
                nodeFilter: d,
                edgeFilter: e
            })
        }
        ,
        this.getDistance = function(a, b, c) {
            var d = this.findPath(a, b, c);
            return d.pathDistance
        }
        ,
        this.getVertex = this.getNode = z,
        this.setTarget = function(a, b) {
            if (b = z(b),
            null == b)
                return {
                    success: !1
                };
            var c = a.target;
            return a.target.deleteEdge(a),
            a.target = b,
            b.addEdge(a),
            {
                old: c,
                edge: a,
                new: b,
                success: !0
            }
        }
        ,
        this.setSource = function(a, b) {
            if (b = z(b),
            null == b)
                return {
                    success: !1
                };
            var c = a.source;
            return a.source.deleteEdge(a),
            a.source = b,
            b.addEdge(a),
            {
                old: c,
                edge: a,
                new: b,
                success: !0
            }
        }
        ,
        this.printPath = function(a, b) {
            a = z(a),
            b = z(b);
            for (var c = this.findPath(a, b).path, d = "[" + a.id + " - " + b.id + "] : ", e = 0; e < c.length; e++)
                d = d + "{ vertex:" + c[e].vertex.id + ", cost:" + c[e].cost + ", edge: " + (c[e].edge && c[e].edge.getId()) + " } ";
            return d
        }
        ,
        this.getDiameter = function(a) {
            for (var b = 0, c = 0; c < this.vertices.length; c++)
                for (var d = 0; d < this.vertices.length; d++)
                    if (d != c) {
                        var e = p.compute({
                            graph: this,
                            source: this.vertices[c],
                            target: this.vertices[d]
                        });
                        if (null == e.path || 0 == e.path.length) {
                            if (!a)
                                return 1 / 0
                        } else
                            b = Math.max(b, e.pathDistance)
                    }
            return b
        }
        ,
        this.diameter = this.getDiameter,
        this.getCentrality = function(a) {
            return a = z(a),
            (a.getIndegreeCentrality() + a.getOutdegreeCentrality()) / (this.getVertexCount() - 1)
        }
        ,
        this.getDegreeCentrality = this.getCentrality,
        this.getIndegreeCentrality = function(a) {
            return a = z(a),
            a.getIndegreeCentrality() / (this.getVertexCount() - 1)
        }
        ,
        this.getOutdegreeCentrality = function(a) {
            return a = z(a),
            a.getOutdegreeCentrality() / (this.getVertexCount() - 1)
        }
        ,
        this.getCloseness = function(a) {
            return 1 / this.getFarness(a)
        }
        ,
        this.getFarness = function(a) {
            a = z(a);
            var b = p.compute({
                graph: this,
                source: a,
                target: a,
                processAll: !0
            })
              , c = 0;
            for (var d in b.dist)
                c += b.dist[d];
            return c / (this.getVertexCount() - 1)
        }
        ,
        this.getBetweenness = function(a) {
            var b = this.getVertexCount()
              , c = (b - 1) * (b - 2) / 2
              , d = 0
              , e = 0
              , f = function(a, b, c, d, e) {
                var g = c.parents[a][b];
                if (0 == g.length) {
                    var h = d.slice();
                    h.unshift(a),
                    e.push(h)
                } else
                    for (var i = 0; i < g.length; i++)
                        if (d.indexOf(g[i][0].id) == -1) {
                            var h = d.slice();
                            h.unshift(g[i][0].id),
                            f(a, g[i][0].id, c, h, e)
                        }
            };
            a = z(a);
            var g = o.compute({
                graph: this,
                focus: a
            });
            for (var h in g.paths)
                for (var i in g.paths[h])
                    if (h != i) {
                        var j = []
                          , k = 0;
                        f(h, i, g, [i], j);
                        for (var l = 0; l < j.length; l++) {
                            var m = j[l].indexOf(a.id);
                            m > 0 && m < j[l].length - 1 && k++
                        }
                        d += k / j.length,
                        e += k
                    }
            return d / c
        }
        ,
        this.inspect = function() {
            for (var a = "", b = 0; b < this.vertices.length; b++)
                a += this.vertices[b].inspect() + "\n";
            return a
        }
        ,
        this.serialize = function() {
            for (var a, b, c, d, e = {
                nodes: [],
                edges: [],
                ports: [],
                groups: []
            }, f = 0; f < this.vertices.length; f++) {
                a = this.vertices[f],
                e.nodes.push(a.data),
                b = a.getAllEdges(),
                c = a.getPorts();
                for (var g = 0; g < b.length; g++)
                    if (b[g].source == a || "Port" === b[g].source.objectType && b[g].source.getNode() == a) {
                        var h = {
                            source: b[g].source.getFullId(),
                            target: b[g].target.getFullId()
                        };
                        b[g].data && (h.data = b[g].data),
                        e.edges.push(h)
                    }
                for (var i = 0; i < c.length; i++) {
                    var j = {};
                    for (var k in c[i].data)
                        j[k] = c[i].data[k];
                    j.id = c[i].getFullId(),
                    e.ports.push(j)
                }
            }
            for (f = 0; f < this.groups.length; f++) {
                d = this.groups[f],
                e.groups.push(d.data),
                b = d.getEdges();
                for (var g = 0; g < b.length; g++)
                    if (b[g].source === d) {
                        var h = {
                            source: d.getFullId(),
                            target: b[g].target.getFullId()
                        };
                        b[g].data && (h.data = b[g].data),
                        e.edges.push(h)
                    }
            }
            return e
        }
        ,
        this.getClusters = function() {
            var a, b = [], c = {}, d = function(a, e) {
                if (null != a && !c[a.id]) {
                    null == e ? (e = new k(a),
                    b.push(e)) : e.addVertex(a),
                    c[a.id] = !0;
                    for (var f = a.getAllEdges(), g = 0; g < f.length; g++) {
                        var h = f[g].source === a ? f[g].target : f[g].source;
                        d(h, e)
                    }
                }
            };
            for (a = 0; a < this.vertices.length; a++)
                d(this.vertices[a]);
            for (a = 0; a < this.groups.length; a++)
                d(this.groups[a]);
            return b
        }
    }
    ,
    function(a, b, c, d, e) {
        for (var f = -1, g = null, h = 1 / 0, i = 0; i < a.length; i++)
            if (!b[i]) {
                var j = e(a[i]);
                j < h && (h = j,
                f = i,
                g = a[i])
            }
        return {
            node: g,
            index: f
        }
    }
    )
      , m = function(a, b) {
        var c = b.getFullId()
          , d = a[c];
        return null == d && (c = b.getNode ? b.getNode().id : b.id,
        d = a[c]),
        null == d ? null : {
            p: d,
            id: c
        }
    }
      , n = function(a, b, c, d, e, f) {
        for (var g = [], h = d, i = m(b, h); null != i; )
            g.splice(0, 0, {
                vertex: h,
                cost: a[i.id],
                edge: c[i.id]
            }),
            h = i.p,
            i = m(b, h);
        return g.splice(0, 0, {
            vertex: h,
            cost: 0,
            edge: null
        }),
        g
    }
      , o = {
        getPath: function(a, b, c, d) {
            if (a[c.id][d.id] == 1 / 0)
                return null;
            var e = b[c.id][d.id];
            return null == e ? " " : o.getPath(a, b, c, e) + " " + e.id + " " + o.getPath(a, b, e, d)
        },
        getPaths: function(a, b, c, d, e) {
            if (a[c.id][d.id] == 1 / 0)
                return null;
            var f = b[c.id][d.id];
            return 0 == f.length ? " " : o.getPaths(a, b, c, f[0]) + " " + f[0].id + " " + o.getPaths(a, b, f[0], d)
        },
        compute: function(a) {
            var b, c, d, e = a.graph, f = e.getVertexCount(), g = {}, h = {};
            for (b = 0; b < f; b++) {
                var i = e.getVertexAt(b);
                for (g[i.id] || (g[i.id] = {}),
                h[i.id] || (h[i.id] = {}),
                g[i.id][i.id] = 0,
                c = 0; c < f; c++)
                    if (b != c) {
                        var j = e.getVertexAt(c);
                        g[i.id][j.id] || (g[i.id][j.id] = 1 / 0),
                        h[i.id][j.id] || (h[i.id][j.id] = [])
                    }
                var k = i.getEdges();
                for (d = 0; d < k.length; d++)
                    k[d].source == i ? g[i.id][k[d].target.id] = k[d].getCost() : (g[k[d].source.id] || (g[k[d].source.id] = {},
                    h[k[d].source.id] = {}),
                    g[i.id][k[d].source.id] = k[d].getCost())
            }
            for (d = 0; d < f; d++)
                for (b = 0; b < f; b++)
                    for (c = 0; c < f; c++)
                        if (b != c && c != d && b != d) {
                            var l = e.getVertexAt(b).id
                              , m = e.getVertexAt(c).id
                              , n = e.getVertexAt(d).id;
                            g[l][n] + g[n][m] <= g[l][m] && g[l][n] + g[n][m] != 1 / 0 && (g[l][m] = g[l][n] + g[n][m],
                            h[l][m] || (h[l][m] = []),
                            h[l][m].unshift([e.getVertexAt(d), g[l][m]]))
                        }
            return {
                paths: g,
                parents: h
            }
        }
    }
      , p = {
        compute: function(a) {
            for (var b = a.graph, c = a.source, d = a.target, e = a.nodeFilter, f = a.edgeFilter, g = {}, h = {}, i = {}, j = {
                dist: g,
                previous: h,
                edges: i,
                path: []
            }, k = a.processAll, m = {}, o = {}, p = !(a.strict === !1), q = function(a) {
                return a.getFullId ? a.getFullId() : a.id
            }, r = [], s = function(a) {
                var b = o[a.getFullId()];
                return m[b.v.id]
            }, t = function(a, b) {
                var c, d;
                if ("Port" === a.objectType) {
                    for (g[a.getFullId()] = b,
                    c = s(a),
                    d = 0; d < c.length; d++)
                        c[d].p != a && (g[c[d].p.getFullId()] = b + a.getNode().getInternalEdge(a, c[d].p).cost);
                    p || (g[a.getNode().id] = b)
                } else
                    for (g[a.id] = b,
                    c = m[a.id],
                    d = 0; d < c.length; d++)
                        g[c[d].p.getFullId()] = b
            }, u = function(a) {
                return e && !e(a) ? 1 / 0 : g[q(a)]
            }, v = function(a, b, c) {
                if ("Port" === a.objectType) {
                    for (var d = s(a), e = 0; e < d.length; e++)
                        h[d[e].p.getFullId()] = c.node;
                    p || (h[a.getNode().id] = c.node)
                }
                h[b] = c.node
            }, w = function(a, b, c) {
                if ("Port" === a.objectType) {
                    for (var d = s(a), e = 0; e < d.length; e++)
                        i[d[e].p.getFullId()] = c;
                    p || (i[a.getNode().id] = c)
                }
                i[b] = c
            }, x = 0; x < b.vertices.length; x++) {
                var y = b.vertices[x]
                  , z = y.getPorts();
                r.push(y);
                var A = {
                    v: y,
                    i: r.length - 1
                };
                m[y.id] = [],
                t(y, 1 / 0);
                for (var B = 0; B < z.length; B++)
                    r.push(z[B]),
                    o[z[B].getFullId()] = A,
                    m[y.id].push({
                        p: z[B],
                        i: r.length - 1
                    }),
                    t(z[B], 1 / 0)
            }
            if (null == c && (c = b.getVertex(a.sourceId)),
            null == d && (d = b.getVertex(a.targetId)),
            null == c || null == d)
                return j;
            var C = c
              , D = d;
            c.getNode && (C = c.getNode()),
            d.getNode && (D = d.getNode()),
            t(c, 0);
            for (var E = new Array(b.vertices.length), F = 0, G = function(a, b, c, d) {
                for (var e = 0; e < b.length; e++) {
                    var f = b[e];
                    if (c(f)) {
                        var g = d(f)
                          , h = g.tp || g.tn
                          , i = q(h)
                          , j = u(a.node) + f.getCost()
                          , k = u(h);
                        j < k && (t(h, j),
                        v(h, i, a),
                        w(h, i, f))
                    }
                }
            }; F < r.length; ) {
                var H = l(r, E, g, q, u)
                  , I = H.node ? q(H.node) : null;
                if (!H.node || u(H.node) == 1 / 0)
                    break;
                if (d && (I == q(d) || !p && H.node.isChildOf && H.node.isChildOf(d)) && (j.path = n(g, h, i, d, q),
                j.pathDistance = j.path[j.path.length - 1].cost,
                !k))
                    break;
                E[H.index] = !0,
                F += 1,
                G(H, H.node.getAllEdges(), function(a) {
                    return !(f && !f(a)) && (!a.isDirected() || H.node == a.source || !p && a.source.isChildOf && a.source.isChildOf(H.node))
                }, function(a) {
                    var b = a.source.getNode ? a.source.getNode() : a.source
                      , c = a.source.getNode ? a.source : null
                      , d = a.target.getNode ? a.target.getNode() : a.target
                      , e = a.target.getNode ? a.target : null;
                    return a.source == H.node || !p && a.source.isChildOf && a.source.isChildOf(H.node) ? {
                        tn: d,
                        tp: e
                    } : {
                        tn: b,
                        tp: c
                    }
                })
            }
            return j
        }
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumbUtil
      , c = a.jsPlumb
      , d = a.jsPlumbToolkitUtil
      , e = a.jsPlumbGraph
      , f = "type"
      , g = "default"
      , h = function(a) {
        return a.id
    };
    a.jsPlumbToolkitInstance = function(i) {
        i = i || {};
        var j = i.idFunction || h
          , k = i.typeProperty || f
          , l = i.edgeTypeProperty || f
          , m = i.portTypeProperty || f
          , n = i.typeFunction || function(a) {
            return a[k] || g
        }
          , o = i.edgeIdFunction || j
          , p = i.edgeTypeFunction || function(a) {
            return a[l] || g
        }
          , q = i.portIdFunction || j
          , r = i.portTypeFunction || function(a) {
            return a[m] || g
        }
          , s = i.portExtractor
          , t = this
          , u = !1
          , v = !1
          , w = i.model || {}
          , x = function(a, c, e) {
            c = null != c && b.isObject(c) ? c : {},
            c = b.clone(c),
            c.id = c.id || d.uuid(),
            c.type = c.type || (null == a ? null : a.type || a),
            e(c)
        }
          , y = i.nodeFactory || x
          , z = i.edgeFactory || x
          , A = i.portFactory || x
          , B = i.groupFactory || x
          , C = i.autoSave && i.saveUrl
          , D = i.saveUrl
          , E = i.saveHeaders
          , F = i.onAutoSaveSuccess || function() {}
          , G = i.onAutoSaveError || function() {}
          , H = i.doNotUpdateOriginalData === !0
          , I = i.onBeforeAutoSave || function() {}
          , J = i.onAfterAutoSave || function() {}
          , K = {
            portSeparator: i.portSeparator,
            defaultCost: i.defaultCost,
            defaultDirected: i.defaultDirected,
            enableSubgraphs: i.enableSubgraphs
        }
          , L = i.createMissingGroups === !0;
        b.EventGenerator.apply(this, arguments);
        var M = new e.Graph(K);
        C && new d.AutoSaver(this,D,E,F,G,I,J),
        new d.CatchAllEventHandler(this),
        this.getNodeFactory = function() {
            return y
        }
        ,
        this.getGroupFactory = function() {
            return B
        }
        ,
        this.getEdgeFactory = function() {
            return z
        }
        ,
        this.getPortFactory = function() {
            return A
        }
        ,
        this.setNodeFactory = function(a) {
            y = a
        }
        ,
        this.setGroupFactory = function(a) {
            B = a
        }
        ,
        this.setEdgeFactory = function(a) {
            z = a
        }
        ,
        this.setPortFactory = function(a) {
            A = a
        }
        ,
        this.setDebugEnabled = function(a) {
            v = a
        }
        ,
        this.isDebugEnabled = function() {
            return v
        }
        ,
        this.getModel = function() {
            return w || {}
        }
        ;
        var N, O = function() {
            return null == N && (N = new a.jsPlumbToolkit.Model(w || {})),
            N
        }, P = function(a, b) {
            if (null == w)
                return !0;
            var c = this.getType(a)
              , d = this.getType(b)
              , e = O()
              , f = a.getNode ? a.getNode() : a
              , g = b.getNode ? b.getNode() : b
              , h = "Node" == a.objectType ? e.getNodeDefinition(c) : e.getPortDefinition(c)
              , i = "Node" == b.objectType ? e.getNodeDefinition(d) : e.getPortDefinition(d)
              , j = this.getNodeType(f)
              , k = this.getNodeType(g)
              , l = e.getNodeDefinition(j)
              , m = e.getNodeDefinition(k);
            return !(null != h.maxConnections && a.getEdges().length >= h.maxConnections) && (!(null != i.maxConnections && b.getEdges().length >= i.maxConnections) && (a == b ? !(l.allowLoopback === !1 || h.allowLoopback === !1 || i.allowLoopback === !1 || m.allowLoopback === !1) : f != g || !(l.allowNodeLoopback === !1 || h.allowNodeLoopback === !1 || i.allowNodeLoopback === !1 || m.allowNodeLoopback === !1)))
        }
        .bind(this);
        this.beforeConnect = i.beforeConnect || P,
        this.beforeMoveConnection = i.beforeMoveConnection || P,
        this.beforeStartConnect = i.beforeStartConnect || function(a, b) {
            return {}
        }
        ,
        this.beforeDetach = i.beforeDetach || function(a, b, c) {
            return !0
        }
        ,
        this.beforeStartDetach = i.beforeStartDetach || function(a, b) {
            return !0
        }
        ,
        this.setSuspendGraph = function(a) {
            u = a
        }
        ,
        this.setDoNotUpdateOriginalData = function(a) {
            H = a
        }
        ,
        this.getTypeFunction = function() {
            return n
        }
        ,
        this.connect = function(a) {
            a = a || {};
            var b;
            if (!u) {
                var d = M.getVertex(a.source)
                  , e = M.getVertex(a.target)
                  , f = a.cost
                  , g = a.directed;
                if (!d) {
                    if (a.doNotCreateMissingNodes)
                        return;
                    d = M.addVertex(a.source),
                    t.fire("nodeAdded", {
                        data: {},
                        node: d
                    })
                }
                if (!e) {
                    if (a.doNotCreateMissingNodes)
                        return;
                    e = M.addVertex(a.target),
                    t.fire("nodeAdded", {
                        data: {},
                        node: e
                    })
                }
                var h = this.beforeStartConnect(d, p(a.data || {}));
                if (h) {
                    var i = a.data || {};
                    "object" == typeof h && c.extend(i, h);
                    var j = this.beforeConnect(d, e, i);
                    j !== !1 && (b = M.addEdge({
                        source: d,
                        target: e,
                        cost: f,
                        directed: g,
                        data: i
                    }),
                    t.fire("edgeAdded", {
                        edge: b
                    }))
                }
            }
            return b
        }
        ,
        this.clear = function() {
            return this.fire("graphClearStart"),
            M.clear(),
            this.fire("graphCleared"),
            this
        }
        ,
        this.getGraph = function() {
            return M
        }
        ,
        this.getNodeCount = function() {
            return M.getVertexCount()
        }
        ,
        this.getNodeAt = function(a) {
            return M.getVertexAt(a)
        }
        ,
        this.getNodes = function() {
            return M.getVertices()
        }
        ,
        this.eachNode = function(a) {
            for (var b, c = 0, d = M.getVertexCount(); c < d; c++)
                b = M.getVertexAt(c),
                a(c, b)
        }
        ,
        this.eachGroup = function(a) {
            for (var b, c = 0, d = M.getGroupCount(); c < d; c++)
                b = M.getGroupAt(c),
                a(c, b)
        }
        ,
        this.eachEdge = function(a) {
            for (var b = M.getEdges(), c = 0, d = b.length; c < d; c++)
                a(c, b[c])
        }
        ,
        this.getEdgeCount = function() {
            return M.getEdgeCount()
        }
        ,
        this.getGroupCount = function() {
            return M.getGroupCount()
        }
        ,
        this.getGroupAt = function(a) {
            return M.getGroupAt(a)
        }
        ,
        this.getClusters = function() {
            return M.getClusters()
        }
        ,
        this.getNodeId = function(a) {
            return b.isObject(a) ? j(a) : a
        }
        ,
        this.getNodeType = function(a) {
            return n(a) || "default"
        }
        ,
        this.getEdgeId = function(a) {
            return b.isObject(a) ? o(a) : a;
        }
        ,
        this.getEdgeType = function(a) {
            return p(a) || "default"
        }
        ,
        this.getPortId = function(a) {
            return b.isObject(a) ? q(a) : a
        }
        ,
        this.getPortType = function(a) {
            return r(a) || "default"
        }
        ,
        this.getType = function(a) {
            var b = "Node" === a.objectType ? n : "Port" === a.objectType ? r : p;
            return b(a.data) || "default"
        }
        ,
        this.setType = function(a, b) {
            var c = this.getType(a);
            if (c !== b) {
                var d = "Node" === a.objectType ? k : "Port" === a.objectType ? m : l
                  , e = a.objectType.charAt(0).toLowerCase() + a.objectType.substring(1) + "TypeChanged";
                a.data[d] = b,
                this.fire(e, {
                    obj: a,
                    previousType: c,
                    newType: b
                })
            }
        }
        ,
        this.addNode = function(b, c, e) {
            var f = j(b);
            null == f && "string" != typeof b && (b.id = d.uuid());
            var g = M.addNode(b, j);
            if (null != g) {
                if (null != s) {
                    var h = s(g.data, g);
                    if (null != h)
                        for (var i = 0; i < h.length; i++)
                            g.addPort(h[i])
                }
                if ("string" != typeof b && null != b.group) {
                    var k = this.getGroup(b.group);
                    null == k && L && (k = M.addGroup(b.group)),
                    null != k && k.addVertex(g)
                }
                return V || H || a.jsPlumbToolkitIO.manage("addNode", T, U, g, j || M.getIdFunction(), t),
                e || t.fire("nodeAdded", {
                    data: b,
                    node: g,
                    eventInfo: c
                }),
                g
            }
            return M.getNode(f)
        }
        ,
        this.addFactoryNode = function(a, b, c) {
            b = 2 != arguments.length || null != arguments[1] && "object" != typeof arguments[1] ? {} : arguments[1],
            c = 3 == arguments.length ? arguments[2] : "function" == typeof arguments[1] ? arguments[1] : null,
            b.type = b.type || a,
            y(a, b, function(a) {
                var b = this.addNode(a);
                c && c(b)
            }
            .bind(this))
        }
        ,
        this.addNodes = function(a) {
            for (var b = 0; b < a.length; b++)
                t.addNode.apply(t, [a[b]]);
            return t
        }
        ,
        this.addGroup = function(b, c, e) {
            var f = j(b);
            null == f && "string" != typeof b && (b.id = d.uuid());
            var g = M.addGroup(b, j);
            return V || H || a.jsPlumbToolkitIO.manage("addGroup", T, U, g, j || M.getIdFunction(), t),
            e || t.fire("groupAdded", {
                data: b,
                group: g,
                eventInfo: c
            }),
            g
        }
        ,
        this.addToGroup = function(a, b) {
            var c = !1;
            return a = t.getNode(a),
            b = t.getGroup(b),
            a && b && (c = b.addVertex(a),
            c && (a.data.group = b.id,
            t.fire("group:addMember", {
                node: a,
                group: this.getGroup(b)
            }),
            t.fire("dataUpdated"))),
            c
        }
        ,
        this.removeFromGroup = function(a, b) {
            a = t.getNode(a);
            var c;
            return a && a.group && (c = a.group,
            c.deleteVertex(a),
            delete a.data.group,
            b || t.fire("group:removeMember", {
                node: a,
                group: c
            }),
            t.fire("dataUpdated")),
            c
        }
        ,
        this.removeGroup = function(b, c, d) {
            var e = M.deleteGroup(b, c);
            e && (V || H || a.jsPlumbToolkitIO.manage("removeGroup", T, U, e, j || M.getIdFunction(), t),
            d || t.fire("groupRemoved", {
                group: e,
                removeChildNodes: c
            }))
        }
        ,
        this.getNode = function(a) {
            return M.getVertex(a)
        }
        ,
        this.getEdge = function(a) {
            return M.getEdge(a)
        }
        ,
        this.getGroup = function(a) {
            return M.getGroup(a)
        }
        ,
        this.exists = function(a) {
            for (var b = 0; b < arguments.length; b++)
                if (null == M.getVertex(arguments[b]))
                    return !1;
            return !0
        }
        ,
        this.removeNode = function(b, c) {
            b = b.constructor === e.Vertex || b.constructor === e.Port ? b : M.getVertex(b);
            for (var d = b.getAllEdges() || [], f = 0; f < d.length; f++)
                t.removeEdge(d[f]);
            return M.deleteVertex(b.id),
            V || H || a.jsPlumbToolkitIO.manage("removeNode", T, U, b, j || M.getIdFunction(), t),
            c || t.fire("nodeRemoved", {
                node: b,
                nodeId: b.id,
                edges: d
            }),
            t
        }
        ,
        this.addEdge = function(b, c, d) {
            var e = M.addEdge(b, o, this.beforeConnect);
            return V || H || a.jsPlumbToolkitIO.manage("addEdge", T, U, e, o || M.getIdFunction(), t),
            d || t.fire("edgeAdded", {
                edge: e,
                source: c,
                geometry: b.geometry,
                addedByMouse: b.addedByMouse
            }, null),
            e
        }
        ,
        this.removeEdge = function(b, c) {
            return b = M.getEdge(b),
            null != b && (M.deleteEdge(b),
            V || H || a.jsPlumbToolkitIO.manage("removeEdge", T, U, b, o || M.getIdFunction(), t),
            t.fire("edgeRemoved", {
                edge: b,
                source: c
            }, null)),
            t
        }
        ,
        this.edgeMoved = function(a, b, c) {
            var d = (a[0 === c ? "source" : "target"],
            0 === c ? "setSource" : "setTarget");
            return this[d](a, b)
        }
        ,
        this.setTarget = function(a, b, c) {
            var d = M.setTarget.apply(M, arguments);
            return d.success === !1 || c || t.fire("edgeTarget", d),
            d
        }
        ,
        this.setSource = function(a, b, c) {
            var d = M.setSource.apply(M, arguments);
            return d.success === !1 || c || t.fire("edgeSource", d),
            d
        }
        ,
        this.addNewPort = function(b, c, d, e) {
            b = M.getVertex(b),
            A({
                node: b,
                type: c
            }, d, function(c) {
                var d = q(c)
                  , f = b.addPort(d);
                f.data = c,
                V || H || a.jsPlumbToolkitIO.manage("addPort", T, U, {
                    node: b,
                    port: f
                }, q || M.getIdFunction(), t),
                e || t.fire("portAdded", {
                    node: b,
                    data: c,
                    port: f
                }, null)
            })
        }
        ,
        this.addPort = function(b, c, d) {
            var e = b.addPort(c, q);
            return V || H || a.jsPlumbToolkitIO.manage("addPort", T, U, {
                node: b,
                port: e
            }, q || M.getIdFunction(), t),
            d || t.fire("portAdded", {
                node: b,
                data: c,
                port: e
            }, null),
            e
        }
        ,
        this.removePort = function(a, b, c) {
            var d = !1;
            a = a.constructor === e.Vertex || a.constructor === e.Port ? a : M.getVertex(a);
            var f = a.getPort(b);
            if (f) {
                var g = f.getAllEdges();
                if (d = a.removePort(f),
                d && !c) {
                    t.fire("portRemoved", {
                        node: a,
                        port: f,
                        edges: g
                    }, null);
                    for (var h = 0; h < g.length; h++)
                        t.removeEdge(g[h])
                }
            }
            return d
        }
        ,
        this.remove = function(a) {
            if (null != a) {
                var b = t.getObjectInfo(a);
                t.setSuspendRendering(!0);
                try {
                    if (!b.obj || "Node" !== b.type && "Edge" !== b.type && "Group" !== b.type) {
                        for (; a.getNodeCount() > 0; )
                            t.removeNode(a.getNodeAt(0));
                        for (; a.getEdgeCount() > 0; )
                            t.removeEdge(a.getEdgeAt(0));
                        for (; a.getGroupCount() > 0; )
                            t.removeGroup(a.getGroupAt(0))
                    } else
                        t["remove" + b.type](b.obj)
                } finally {
                    t.setSuspendRendering(!1, !0)
                }
            }
        }
        ,
        this.setSuspendRendering = function(a, b) {
            for (var c in ba)
                ba[c].setSuspendRendering(a, b)
        }
        ,
        this.batch = function(a) {
            t.setSuspendRendering(!0);
            try {
                a()
            } catch (a) {
                jsPlumbUtil.log("Error in transaction " + a)
            } finally {
                t.setSuspendRendering(!1, !0)
            }
        }
        ;
        var Q = function(a, c, d, e, f) {
            var g = M.getNode(a);
            if (g && g.objectType) {
                if (c)
                    for (var h in c)
                        b.replace(g.data, h, c[h]);
                t.fire(d, e(g), null)
            }
        }
        .bind(this);
        this.updateNode = function(a, b) {
            Q(a, b, "nodeUpdated", function(a) {
                return {
                    node: a,
                    updates: b || {}
                }
            })
        }
        ,
        this.updatePort = function(a, b) {
            Q(a, b, "portUpdated", function(a) {
                return {
                    port: a,
                    node: a.getNode(),
                    updates: b || {}
                }
            })
        }
        ,
        this.updateEdge = function(a, c) {
            var d = M.getEdge(a);
            if (d) {
                if (c)
                    for (var e in c)
                        null == d.data[e] ? d.data[e] = c[e] : b.replace(d.data, e, c[e]);
                t.fire("edgeUpdated", {
                    edge: d,
                    updates: c || {}
                }, null)
            }
        }
        ,
        this.update = function(a, c) {
            return b.isString(a) && (a = this.getNode(a)),
            a && a.objectType && this["update" + a.objectType](a, c),
            a
        }
        ,
        this.getPath = function(b) {
            return new a.jsPlumbToolkit.Path(this,b)
        }
        ;
        var R = this.findGraphObject = function(a) {
            return null == a ? null : "*" === a ? M : a.constructor === e.Vertex || a.constructor === e.Port ? a : b.isString(a) || b.isObject(a) ? M.getVertex(a) : null
        }
          , S = function(a, b, c) {
            a = a || {};
            var d = []
              , f = {}
              , g = function(a) {
                f[a.getId()] || (d.push(a),
                f[a.getId()] = !0)
            }
              , h = function(d, f, h, i) {
                if (null != d)
                    for (var j = d[b]({
                        filter: a.filter
                    }), k = 0; k < j.length; k++) {
                        var l = f && d === M || j[k].source === d || c && j[k].source.constructor === e.Port && j[k].source.getNode() === d
                          , m = h && d === M || j[k].target === d || c && j[k].target.constructor === e.Port && j[k].target.getNode() === d;
                        (f && l || h && m || i && (l || m)) && g(j[k])
                    }
            };
            return h(R(a.source), !0, !1, !1),
            h(R(a.target), !1, !0, !1),
            h(R(a.element), !1, !1, !0),
            d
        };
        this.getEdges = function(a) {
            return S(a, "getEdges", !1)
        }
        ,
        this.getAllEdges = function() {
            return M.getAllEdges()
        }
        ,
        this.getAllEdgesFor = function(a, b) {
            return a.getAllEdges({
                filter: b
            })
        }
        ,
        this.selectAllEdges = function() {
            return this.filter(function(a) {
                return "Edge" === a.objectType
            })
        }
        ,
        this.addAllEdgesToSelection = function() {
            this.addToSelection(this.getAllEdges())
        }
        ;
        var T, U, V, W = function(b, c, e) {
            b = b || {};
            var f = b.type || "json"
              , g = b.data
              , h = b.url
              , i = b.jsonp
              , j = b.onload
              , k = b.parameters || {}
              , l = b.error || function() {}
            ;
            if (null == g && null == h)
                throw new TypeError("You must supply either data or url to load.");
            var m = function(b) {
                T = b,
                U = f,
                V = !0,
                t.fire(c),
                a.jsPlumbToolkitIO.parse(f, b, t, k),
                aa(e),
                j && j(t, b),
                t.fire("graphChanged")
            };
            if (g)
                m(g);
            else if (h) {
                if (i) {
                    var n = h.indexOf("?") === -1 ? "?" : "&";
                    h = h + n + "callback=?"
                }
                var o = "json" === f ? f : b.dataType
                  , p = b.headers || {
                    Accept: "application/json"
                };
                d.ajax({
                    url: h,
                    success: m,
                    dataType: o,
                    error: l,
                    headers: p
                })
            }
            return t
        };
        this.load = function(a) {
            return W(a, "dataLoadStart", "dataLoadEnd")
        }
        ,
        this.append = function(a) {
            return W(a, "dataAppendStart", "dataAppendEnd")
        }
        ,
        this.save = function(a) {
            a = a || {};
            var b = this.exportData(a)
              , e = {
                "Content-Type": "application/json"
            };
            return c.extend(e, a.headers || {}),
            d.ajax({
                url: a.url,
                type: "POST",
                data: b,
                success: a.success || function() {}
                ,
                error: a.error || function() {}
                ,
                headers: e
            }),
            t
        }
        ,
        this.exportData = function(b) {
            return b = b || {},
            a.jsPlumbToolkitIO.exportData(b.type || "json", t, b.parameters)
        }
        ;
        var X = function(a) {
            return new d.Selection({
                toolkit: t,
                onClear: a || function() {}
            })
        }
          , Y = X(function(a) {
            t.fire("selectionCleared", {
                selection: a
            })
        });
        i.maxSelectedNodes && Y.setMaxNodes(i.maxSelectedNodes),
        i.maxSelectedEdges && Y.setMaxEdges(i.maxSelectedEdges),
        i.selectionCapacityPolicy && Y.setCapacityPolicy(i.selectionCapacityPolicy);
        var Z = function(a, b, c, d) {
            return b || c.clear(!0),
            c.append(a, function(a) {
                d && t.fire("select", {
                    append: b,
                    obj: a,
                    selection: c
                })
            })
        };
        this.setSelection = function(a) {
            Z(a, !1, Y, !0)
        }
        ,
        this.select = function(a, b) {
            var c = X()
              , d = Z(a, !0, c);
            if (b)
                for (var e = 0; e < d[0].length; e++) {
                    var f = d[0][e];
                    if ("Node" === f.objectType || "Port" === f.objectType)
                        for (var g = f.getAllEdges(), h = 0; h < g.length; h++)
                            c.append(g[h])
                }
            return c
        }
        ;
        var $ = function(a, b, c, d) {
            for (var e = a.getAllEdges(), f = 0, g = e.length; f < g; f++)
                if (e[f].source === a || e[f].getNode && e[f].getNode() === a) {
                    var h = e[f].target
                      , i = h.getFullId();
                    d[i] || (b.append(h),
                    c && b.append(e[f]),
                    d[i] = !0,
                    $(h, b, c, d))
                }
        };
        this.selectDescendants = function(a, b, c) {
            var d = t.getObjectInfo(a)
              , e = X();
            if (d.obj && "Node" === d.obj.objectType) {
                b && Z(d.obj, !0, e);
                var f = {};
                f[d.obj.getFullId()] = !0,
                $(d.obj, e, c, f)
            }
            return e
        }
        ,
        this.filter = function(a, b) {
            var c = "function" == typeof a ? a : function(c) {
                var d = c.data
                  , e = !1;
                for (var f in a) {
                    var g = a[f] === d[f];
                    if (!g && !b)
                        return !1;
                    e = e || g
                }
                return e
            }
              , d = X();
            return this.eachNode(function(a, b) {
                c(b) && d.append(b);
                for (var e = b.getPorts(), f = 0; f < e.length; f++)
                    c(e[f]) && d.append(e[f])
            }),
            this.eachEdge(function(a, b) {
                c(b) && d.append(b)
            }),
            this.eachGroup(function(a, b) {
                c(b) && d.append(b)
            }),
            d
        }
        ,
        this.addToSelection = function(a) {
            var b = this.getObjectInfo(a);
            if (b) {
                var c = Z(b.obj, !0, Y, !0);
                _("deselect", c[1]),
                _("select", c[0])
            }
        }
        ;
        var _ = function(a, b) {
            for (var c = 0; c < b.length; c++)
                t.fire(a, {
                    obj: b[c],
                    selection: Y
                })
        };
        this.toggleSelection = function(a) {
            var b = this.getObjectInfo(a);
            if (b) {
                var c = []
                  , d = Y.toggle(b.obj, function(a, b) {
                    b || c.push(a)
                });
                _("deselect", d[1]),
                _("deselect", c),
                _("select", d[0])
            }
        }
        ,
        this.removeFromSelection = function(a) {
            var b = this.getObjectInfo(a);
            b && Y.remove(b.obj, function(a) {
                t.fire("deselect", {
                    obj: a,
                    selection: Y
                })
            })
        }
        ,
        this.addPathToSelection = function(a) {
            this.addToSelection(this.getPath(a))
        }
        ,
        this.selectAll = function() {
            throw new TypeError("not implemented")
        }
        ,
        this.clearSelection = Y.clear,
        this.getSelection = function() {
            return Y
        }
        ,
        this.setMaxSelectedNodes = function(a) {
            Y.setMaxNodes(a)
        }
        ,
        this.setMaxSelectedEdges = function(a) {
            Y.setMaxEdges(a)
        }
        ,
        this.setSelectionCapacityPolicy = function(a) {
            Y.setCapacityPolicy(a)
        }
        ;
        var aa = function(a) {
            t.setSuspendGraph(!0),
            t.fire(a),
            t.setSuspendGraph(!1),
            V = !1
        }
          , ba = {};
        if (this.render = function(e, f) {
            var g = c.extend({}, f || {});
            c.extend(g, e),
            g.toolkit = t,
            null != e.selection && (e.selection.constructor === d.Selection ? g.toolkit = e.selection : g.toolkit = new d.Selection({
                generator: e.selection,
                toolkit: t
            }));
            var h = g.type || a.jsPlumbToolkit.DefaultRendererType
              , i = new a.jsPlumbToolkit.Renderers[h](g)
              , j = g.id || b.uuid();
            return ba[j] = i,
            i.id = j,
            i
        }
        ,
        this.getRenderer = function(a) {
            return ba[a]
        }
        ,
        this.getRenderers = function() {
            return ba
        }
        ,
        this.getObjectInfo = function(a, d) {
            var e = {
                els: {},
                obj: null,
                type: null,
                id: null,
                el: null
            }
              , f = function(a) {
                if (null != a)
                    return a.jtk ? a : f(a.parentNode)
            }
              , g = function(a) {
                var b = {};
                for (var c in ba)
                    b[c] = [ba[c], ba[c].getRenderedElement(a)];
                return b
            };
            if (null != a) {
                if (a.eachNode && a.eachEdge)
                    return {
                        obj: a
                    };
                if (b.isArray(a))
                    return {
                        obj: a
                    };
                var h = c.getElement(a);
                if (null != h && h.jtk)
                    e.el = h,
                    e.obj = h.jtk.port || h.jtk.node;
                else if (null != a.tagName) {
                    var i = f(h);
                    null != i && (e.el = i,
                    e.obj = i.jtk.port || i.jtk.node || i.jtk.group)
                } else {
                    if ("string" == typeof a ? a = this.getNode(a) : "object" == typeof a && "undefined" == typeof a.objectType && (a = this.getNode(j(a))),
                    null == a)
                        return e;
                    e.obj = a,
                    null != d && (e.el = d(a))
                }
                null == d && (e.els = g(e.obj)),
                null != e.obj && (e.id = e.obj.id,
                e.type = e.obj.objectType)
            }
            return e
        }
        ,
        i.data) {
            var ca = i.dataType || "json";
            t.load({
                data: i.data,
                type: ca
            })
        }
    }
    ,
    b.extend(a.jsPlumbToolkitInstance, b.EventGenerator),
    a.jsPlumbToolkit = new a.jsPlumbToolkitInstance({}),
    a.jsPlumbToolkit.DefaultRendererType = null,
    a.jsPlumbToolkit.ready = c.ready,
    a.jsPlumbToolkit.Renderers = {},
    a.jsPlumbToolkit.Widgets = {};
    var i = function(b) {
        return new a.jsPlumbToolkitInstance(b)
    };
    a.jsPlumbToolkit.newInstance = i,
    "undefined" != typeof exports && (exports.jsPlumbToolkit = a.jsPlumbToolkit,
    exports.newInstance = i)
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    var a = this
      , b = a.jsPlumbToolkit
      , c = a.jsPlumbToolkitUtil
      , d = a.jsPlumbUtil;
    b.Model = function(a, e) {
        a = a || {},
        a.nodes = a.nodes || {},
        a.edges = a.edges || {},
        a.ports = a.ports || {},
        a.groups = a.groups || {};
        var f, g, h = {}, i = function(b) {
            var d = c.mergeWithParents([b, "default"], a.nodes);
            return delete d.parent,
            d
        }, j = function(b) {
            var d = c.mergeWithParents([b, "default"], a.edges);
            return delete d.parent,
            d
        }, k = function(b, d) {
            var e = d && d.ports ? c.mergeWithParents([b, "default"], d.ports) : c.mergeWithParents([b, "default"], a.ports);
            return delete e.parent,
            e
        }, l = function(b) {
            var d = c.mergeWithParents([b, "default"], a.groups);
            return delete d.parent,
            d
        };
        if ("undefined" != typeof e) {
            for (var m in a.edges) {
                if (f = j(m),
                f.overlays)
                    for (g = 0; g < f.overlays.length; g++)
                        if (d.isArray(f.overlays[g]) && f.overlays[g][1].events)
                            for (var n in f.overlays[g][1].events)
                                f.overlays[g][1].events[n] = function(a, b) {
                                    return function(c, d) {
                                        a.call(b, {
                                            overlay: c,
                                            e: d,
                                            component: c.component,
                                            edge: c.component.edge
                                        })
                                    }
                                }(f.overlays[g][1].events[n], f.overlays[g]);
                e.registerConnectionType(m, f)
            }
            for (g in a.ports)
                f = k(g),
                e.registerEndpointType(g, f);
            if (a.states)
                for (var o in a.states)
                    h[o] = new b.UIState(o,a.states[o],e)
        }
        return {
            getNodeDefinition: i,
            getEdgeDefinition: j,
            getPortDefinition: k,
            getGroupDefinition: l,
            getState: function(a) {
                return h[a]
            }
        }
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    var a = jsPlumbToolkit.ready
      , b = function(a) {
        var b = 0
          , c = function() {
            b--,
            b <= 0 && e()
        };
        this.add = function(d) {
            b++,
            jsPlumbToolkitUtil.ajax({
                url: d,
                success: function(b) {
                    var d = a.innerHTML;
                    d += b,
                    a.innerHTML = d,
                    c()
                },
                error: function(a) {
                    c()
                }
            })
        }
        ,
        this.ensureNotEmpty = function() {
            b <= 0 && e()
        }
    }
      , c = []
      , d = !1
      , e = function() {
        d = !0;
        for (var b = 0; b < c.length; b++)
            a.call(a, c[b])
    };
    jsPlumbToolkit.ready = function(b) {
        d ? a.call(a, b) : c.push(b)
    }
    ,
    jsPlumb.ready(function() {
        var a = document.getElementById("jsPlumbToolkitTemplates");
        if (a)
            e();
        else {
            a = document.createElement("div"),
            a.style.display = "none",
            a.id = "jsPlumbToolkitTemplates",
            document.body.appendChild(a);
            for (var c = new b(a), d = document.getElementsByTagName("script"), f = 0; f < d.length; f++) {
                var g = d[f].getAttribute("type")
                  , h = d[f].getAttribute("src");
                "text/x-jtk-templates" == g && c.add(h)
            }
            c.ensureNotEmpty()
        }
    })
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    this.jsPlumbToolkit.Classes = {
        LASSO: "jtk-lasso",
        LASSO_SELECT_DEFEAT: "jtk-lasso-select-defeat",
        MINIVIEW: "jtk-miniview",
        MINIVIEW_CANVAS: "jtk-miniview-canvas",
        MINIVIEW_PANNER: "jtk-miniview-panner",
        MINIVIEW_ELEMENT: "jtk-miniview-element",
        MINIVIEW_GROUP_ELEMENT: "jtk-miniview-group-element",
        MINIVIEW_PANNING: "jtk-miniview-panning",
        MINIVIEW_COLLAPSE: "jtk-miniview-collapse",
        MINIVIEW_COLLAPSED: "jtk-miniview-collapsed",
        NODE: "jtk-node",
        PORT: "jtk-port",
        GROUP: "jtk-group",
        SELECT_DEFEAT: "jtk-drag-select-defeat",
        SURFACE: "jtk-surface",
        SURFACE_NO_PAN: "jtk-surface-nopan",
        SURFACE_CANVAS: "jtk-surface-canvas",
        SURFACE_PAN: "jtk-surface-pan",
        SURFACE_PAN_LEFT: "jtk-surface-pan-left",
        SURFACE_PAN_TOP: "jtk-surface-pan-top",
        SURFACE_PAN_RIGHT: "jtk-surface-pan-right",
        SURFACE_PAN_BOTTOM: "jtk-surface-pan-bottom",
        SURFACE_PAN_ACTIVE: "jtk-surface-pan-active",
        SURFACE_SELECTED_ELEMENT: "jtk-surface-selected-element",
        SURFACE_SELECTED_CONNECTION: "jtk-surface-selected-connection",
        SURFACE_PANNING: "jtk-surface-panning",
        SURFACE_ELEMENT_DRAGGING: "jtk-surface-element-dragging",
        SURFACE_DROPPABLE_NODE: "jtk-surface-droppable-node",
        TOOLBAR: "jtk-toolbar",
        TOOLBAR_TOOL: "jtk-tool",
        TOOLBAR_TOOL_SELECTED: "jtk-tool-selected",
        TOOLBAR_TOOL_ICON: "jtk-tool-icon"
    },
    this.jsPlumbToolkit.Constants = {
        click: "click",
        start: "start",
        stop: "stop",
        drop: "drop",
        disabled: "disabled",
        pan: "pan",
        select: "select",
        drag: "drag",
        left: "left",
        right: "right",
        top: "top",
        bottom: "bottom",
        width: "width",
        height: "height",
        leftmin: "leftmin",
        leftmax: "leftmax",
        topmin: "topmin",
        topmax: "topmax",
        min: "min",
        max: "max",
        nominalSize: "50px",
        px: "px",
        onepx: "1px",
        nopx: "0px",
        em: "em",
        absolute: "absolute",
        relative: "relative",
        none: "none",
        block: "block",
        hidden: "hidden",
        div: "div",
        id: "id",
        plusEquals: "+=",
        minusEquals: "-=",
        dot: ".",
        transform: "transform",
        transformOrigin: "transform-origin",
        nodeType: "Node",
        portType: "Port",
        edgeType: "Edge",
        groupType: "Group",
        surfaceNodeDragScope: "surfaceNodeDrag",
        mistletoeLayoutType: "Mistletoe",
        surfaceType: "Surface",
        jtkStatePrefix: "jtk-state-",
        msgCannotSaveState: "Cannot save state",
        msgCannotRestoreState: "Cannot restore state"
    },
    this.jsPlumbToolkit.Attributes = {
        jtkNodeId: "jtk-node-id",
        relatedNodeId: "related-node-id"
    },
    this.jsPlumbToolkit.Methods = {
        addClass: "addClass",
        removeClass: "removeClass"
    },
    this.jsPlumbToolkit.Events = {
        beforeDrop: "beforeDrop",
        beforeDetach: "beforeDetach",
        click: "click",
        canvasClick: "canvasClick",
        canvasDblClick: "canvasDblClick",
        connection: "connection",
        connectionAborted: "connectionAborted",
        connectionDetached: "connectionDetached",
        connectionMoved: "connectionMoved",
        connectionDragStop: "connectionDragStop",
        contentDimensions: "contentDimensions",
        contextmenu: "contextmenu",
        dataLoadStart: "dataLoadStart",
        dataAppendStart: "dataAppendStart",
        dataLoadEnd: "dataLoadEnd",
        dataAppendEnd: "dataAppendEnd",
        dblclick: "dblclick",
        drag: "drag",
        drop: "drop",
        dragover: "dragover",
        dragend: "dragend",
        edgeAdded: "edgeAdded",
        edgeRemoved: "edgeRemoved",
        edgeTypeChanged: "edgeTypeChanged",
        elementDragged: "elementDragged",
        elementAdded: "elementAdded",
        elementRemoved: "elementRemoved",
        endOverlayAnimation: "endOverlayAnimation",
        graphClearStart: "graphClearStart",
        graphCleared: "graphCleared",
        groupAdded: "groupAdded",
        groupDragStop: "groupDragStop",
        groupExpand: "group:expand",
        groupCollapse: "group:collapse",
        groupRemoved: "groupRemoved",
        groupMemberAdded: "group:addMember",
        groupMemberRemoved: "group:removeMember",
        groupMoveEnd: "groupMoveEnd",
        groupUpdated: "groupUpdated",
        lassoEnd: "lasso:end",
        modeChanged: "modeChanged",
        mousedown: "mousedown",
        mousemove: "mousemove",
        mouseout: "mouseout",
        mouseup: "mouseup",
        mouseenter: "mouseenter",
        mouseleave: "mouseleave",
        mouseover: "mouseover",
        nodeAdded: "nodeAdded",
        nodeDropped: "nodeDropped",
        nodeMoveStart: "nodeMoveStart",
        nodeMoveEnd: "nodeMoveEnd",
        nodeRemoved: "nodeRemoved",
        edgeTarget: "edgeTarget",
        nodeTypeChanged: "nodeTypeChanged",
        edgeSource: "edgeSource",
        objectRepainted: "objectRepainted",
        pan: "pan",
        portAdded: "portAdded",
        portRemoved: "portRemoved",
        portTypeChanged: "portTypeChanged",
        redraw: "redraw",
        start: "start",
        startOverlayAnimation: "startOverlayAnimation",
        stateRestored: "stateRestored",
        stop: "stop",
        tap: "tap",
        touchend: "touchend",
        touchmove: "touchmove",
        touchstart: "touchstart",
        unload: "unload",
        portRefreshed: "portRefreshed",
        nodeRefreshed: "nodeRefreshed",
        edgeRefreshed: "edgeRefreshed",
        nodeRendered: "nodeRendered",
        nodeUpdated: "nodeUpdated",
        portUpdated: "portUpdated",
        edgeUpdated: "edgeUpdated",
        zoom: "zoom",
        relayout: "relayout",
        deselect: "deselect",
        selectionCleared: "selectionCleared",
        resize: "resize",
        anchorChanged: "anchorChanged"
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this;
    a.jsPlumbToolkit.util = {
        Cookies: {
            get: function(a) {
                document.cookie.match(new RegExp(a + "=[a-zA-Z0-9.()=|%/_]+($|;)","g"));
                return val && 0 != val.length ? unescape(val[0].substring(a.length + 1, val[0].length).replace(";", "")) || null : null
            },
            set: function(a, b, c, d) {
                var e = [a + "=" + escape(b), "/",  true ? window.location.host : domain]
                  , f = function() {
                    if ("NaN" == parseInt(d))
                        return "";
                    var a = new Date;
                    return a.setTime(a.getTime() + 60 * parseInt(d) * 60 * 1e3),
                    a.toGMTString()
                };
                return d && e.push(f(d)),
                document.cookie = e.join("; ")
            },
            unset: function(b, c, d) {
                c = c && "string" == typeof c ? c : "",
                d = d && "string" == typeof d ? d : "",
                a.jsPlumbToolkit.util.Cookies.get(b) && a.jsPlumbToolkit.util.Cookies.set(b, "", "Thu, 01-Jan-70 00:00:01 GMT", c, d)
            }
        },
        Storage: {
            set: function(b, c) {
                "undefined" == typeof localStorage ? a.jsPlumbToolkit.util.Cookies.set(b, c) : localStorage.setItem(b, c)
            },
            get: function(b) {
                return "undefined" == typeof localStorage ? a.jsPlumbToolkit.util.Cookies.read(b) : localStorage.getItem(b)
            },
            clear: function(b) {
                "undefined" == typeof localStorage ? a.jsPlumbToolkit.util.Cookies.unset(b) : localStorage.removeItem(b)
            },
            clearAll: function() {
                if ("undefined" == typeof localStorage)
                    ;
                else
                    for (; localStorage.length > 0; ) {
                        var a = localStorage.key(0);
                        localStorage.removeItem(a)
                    }
            },
            setJSON: function(b, c) {
                if ("undefined" == typeof JSON)
                    throw new TypeError("JSON undefined. Cannot store value.");
                a.jsPlumbToolkit.util.Storage.set(b, JSON.stringify(c))
            },
            getJSON: function(b) {
                if ("undefined" == typeof JSON)
                    throw new TypeError("JSON undefined. Cannot retrieve value.");
                return JSON.parse(a.jsPlumbToolkit.util.Storage.get(b))
            }
        }
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumbToolkit
      , c = b
      , d = a.jsPlumbUtil;
    c.Path = function(a, b) {
        this.bind = a.bind,
        this.getModel = a.getModel,
        this.setSuspendGraph = a.setSuspendGraph,
        this.getNodeId = a.getNodeId,
        this.getEdgeId = a.getEdgeId,
        this.getPortId = a.getPortId,
        this.getNodeType = a.getNodeType,
        this.getEdgeType = a.getEdgeType,
        this.getPortType = a.getPortType;
        for (var c = a.getGraph().findPath(b.source, b.target, b.strict, b.nodeFilter, b.edgeFilter), e = function() {
            for (var b = 0; b < c.path.length; b++)
                c.path[b].edge && a.removeEdge(c.path[b].edge);
            return this
        }
        .bind(this), f = function() {
            for (var b = 0; b < c.path.length; b++)
                a.removeNode(c.path[b].vertex);
            return this
        }
        .bind(this), g = function(b, d) {
            var e = a.findGraphObject(b)
              , f = !1;
            if (e)
                for (var g = 0; g < c.path.length; g++)
                    if (c.path[g].vertex == e || c.path[g].edge == e || !d && "Port" == c.path[g].vertex.objectType && c.path[g].vertex.isChildOf(e)) {
                        f = !0;
                        break
                    }
            return f
        }, h = [], i = {}, j = 0; j < c.path.length; j++)
            h.push(c.path[j].vertex),
            i[a.getNodeId(c.path[j].vertex)] = [c.path[j].vertex, j];
        this.getNodes = function() {
            return h
        }
        ,
        this.getNode = function(a) {
            return i["string" == typeof a ? a : a.id][0]
        }
        ,
        this.getAllEdgesFor = function(a) {
            var b = i[a.id][1];
            return b < c.path.length - 1 ? [c.path[b + 1].edge] : []
        }
        ;
        var k = function(a, b) {
            for (var e = b || 0; e < c.path.length; e++)
                try {
                    a(e, c.path[e])
                } catch (a) {
                    d.log("Path iterator function failed", a)
                }
        };
        this.each = function(a) {
            k(function(b, c) {
                a(b, c)
            })
        }
        ,
        this.eachNode = function(a) {
            k(function(b, c) {
                a(b, c.vertex)
            })
        }
        ,
        this.eachEdge = function(a) {
            k(function(b, c) {
                a(b, c.edge)
            }, 1)
        }
        ,
        this.getNodeCount = function() {
            return c.path.length
        }
        ,
        this.getNodeAt = function(a) {
            return c.path[a].vertex
        }
        ,
        this.getEdgeCount = function() {
            return 0 == c.path.length ? 0 : c.path.length - 1
        }
        ,
        this.getEdgeAt = function(a) {
            return a < 0 && (a = c.path.length - 1 + a),
            c.path.length > a + 1 ? c.path[a + 1].edge : null
        }
        ,
        this.path = c,
        this.deleteEdges = e,
        this.deleteNodes = f,
        this.deleteAll = f,
        this.isEmpty = function() {
            return 0 == c.path.length
        }
        ,
        this.getCost = function() {
            return c.pathDistance
        }
        ,
        this.contains = g,
        this.exists = function() {
            return null != c.pathDistance
        }
        ,
        this.selectEdges = function(a) {
            return _selectEdges(a, "getEdges", !1)
        }
        ,
        this.selectAllEdges = function(a) {
            return _selectEdges(a, "getAllEdges", !0)
        }
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumbToolkitIO = {}
      , c = a.jsPlumbUtil
      , d = a.jsPlumb
      , e = function(a, b, c) {
        for (var d = a.nodes || [], e = a.edges || [], f = a.ports || [], g = a.groups || [], h = 0; h < g.length; h++)
            b.addGroup(g[h]);
        for (var i = 0; i < d.length; i++)
            b.addNode(d[i]);
        for (var j = 0; j < f.length; j++)
            if (f[j].nodeId) {
                var k = b.getNode(f[j].nodeId);
                if (null == k)
                    throw new TypeError("Unknown node [" + f[j].nodeId + "]");
                k.addPort(f[j])
            }
        for (var l = 0; l < e.length; l++) {
            var m = {
                source: e[l].source,
                target: e[l].target,
                cost: e[l].cost || 1,
                directed: e[l].directed,
                data: e[l].data
            };
            e[l].geometry && (m.geometry = e[l].geometry),
            b.addEdge(m)
        }
    }
      , f = function(a, b) {
        return a.getGraph().serialize()
    }
      , g = function(a, b, c) {
        var d = function(a) {
            var c = b.addNode(a);
            if (a.children)
                for (var e = 0; e < a.children.length; e++) {
                    var f = b.addNode(a.children[e]);
                    b.addEdge({
                        source: c,
                        target: f
                    }),
                    d(a.children[e])
                }
        };
        d(a)
    };
    b.exporters = {
        json: f
    },
    b.parsers = {
        json: e,
        "hierarchical-json": g
    },
    b.managers = {
        json: {
            removeNode: function(a, b, d) {
                var e = d(b.data);
                c.removeWithFunction(a.nodes, function(a) {
                    return a.id == e
                })
            },
            removeEdge: function(a, b, d) {
                var e = d(b.data);
                c.removeWithFunction(a.edges, function(a) {
                    return a.data && a.data.id == e
                })
            },
            addNode: function(a, b, c) {
                a.nodes = a.nodes || [],
                a.nodes.push(b.data)
            },
            addEdge: function(a, b, c) {
                var d = {
                    source: b.source.getFullId(),
                    target: b.target.getFullId(),
                    data: b.data || {}
                };
                a.edges = a.edges || [],
                a.edges.push(d)
            },
            addPort: function(a, b, c) {
                a.ports = a.ports || [];
                var e = d.extend({}, b.port.data || {});
                e.id = b.port.getFullId(),
                a.ports.push(e)
            },
            removePort: function(a, b, d) {
                var e = b.port.getFullId();
                c.removeWithFunction(a.ports, function(a) {
                    return a.id == e
                })
            }
        }
    },
    b.parse = function(a, c, d, e) {
        var f = b.parsers[a];
        if (null == f)
            throw new Error("jsPlumb Toolkit - parse - [" + a + "] is an unsupported type");
        return f(c, d, e)
    }
    ,
    b.exportData = function(a, c, d) {
        var e = b.exporters[a];
        if (null === e)
            throw new Error("jsPlumb Toolkit - exportData - [" + a + "]  is an unsupported type");
        return e(c, d)
    }
    ,
    b.manage = function(a, c, d, e, f, g) {
        b.managers[d] && b.managers[d][a] && b.managers[d][a](c, e, f)
    }
    ,
    "undefined" != typeof exports && (exports.jsPlumbToolkitIO = b)
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    var a = this
      , b = a.jsPlumbToolkit
      , c = b;
    c.Support = {
        ingest: function(c) {
            var d = c.jsPlumb || a.jsPlumb;
            if (!d.getContainer())
                throw new TypeError("No Container set on jsPlumb instance. Cannot continue.");
            var e = b.newInstance()
              , f = d.select()
              , g = {}
              , h = function() {
                return "default"
            }
              , i = c.idFunction || function(a) {
                return d.getId(a)
            }
              , j = c.typeFunction || h
              , k = c.idFunction || function(a) {
                return a.id
            }
              , l = c.edgeTypeFunction || h
              , m = c.render !== !1
              , n = function(a) {
                var b = i(a)
                  , c = j(a)
                  , f = d.getId(a);
                null == g[f] && (g[f] = e.addNode({
                    id: b,
                    type: c
                }, null, !0),
                a.jtk = {
                    node: g[f]
                })
            }
              , o = function(a) {
                var b = g[a.sourceId]
                  , c = g[a.targetId]
                  , d = k(a)
                  , f = l(a);
                a.edge = e.addEdge({
                    source: b,
                    target: c,
                    data: {
                        id: d,
                        type: f
                    }
                }, null, !0)
            };
            if (c.nodeSelector)
                for (var p = d.getContainer().querySelectorAll(c.nodeSelector), q = 0; q < p.length; q++) {
                    var r = d.getId(p[q]);
                    n(p[q], r),
                    d.manage(r, p[q])
                }
            var s = d.getManagedElements();
            for (var r in s)
                n(s[r].el, r);
            if (f.each(function(a) {
                o(a)
            }),
            m) {
                var t = a.jsPlumb.extend({}, c.renderParams || {});
                t.jsPlumbInstance = d,
                t.container = d.getContainer();
                var u = e.render(t);
                return u.ingest = function(a) {
                    n(a),
                    u.importNode(a, i(a))
                }
                ,
                u
            }
            return e
        }
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumbToolkit
      , c = b.Layouts = {
        Decorators: {}
    }
      , d = a.jsPlumbUtil
      , e = function(a) {
        var b = 1 / 0
          , c = 1 / 0
          , d = -(1 / 0)
          , e = -(1 / 0);
        for (var f in a)
            b = Math.min(b, a[f][0]),
            d = Math.max(d, a[f][0]),
            c = Math.min(c, a[f][1]),
            e = Math.max(e, a[f][1]);
        return [[b, c], [d, e], Math.abs(b - d), Math.abs(c - e)]
    }
      , f = function(a, b, e) {
        if (null == a)
            return [];
        for (var f = [], g = function(a) {
            var f = "string" == typeof a ? a : a[0]
              , g = c.Decorators[f]
              , h = "string" == typeof a ? {} : a[1];
            return g ? new g(h,b,e) : (d.log("Decorator [" + f + "] nor registered on jsPlumbToolkit.Layouts.Decorators. Not fatal."),
            null)
        }, h = 0; h < a.length; h++) {
            var i = g(a[h]);
            i && f.push(i)
        }
        return f
    };
    c.AbstractLayout = function(b) {
        function c() {
            var a, c, d, e, f = function(a) {
                return [a.data.left, a.data.top]
            }, g = function(a, c) {
                return (b.locationFunction || f)(a)
            }, h = o.getGroupCount();
            for (c = 0; c < h; c++)
                for (e = o.getGroupAt(c),
                a = e.getVertices(),
                d = 0; d < a.length; d++) {
                    var i = g(a[d]);
                    J(a[d].id, i[0], i[1])
                }
        }
        b = b || {};
        var d = this
          , g = function() {
            return {
                padding: [0, 0]
            }
        }
          , h = function() {
            var b = a.jsPlumb.extend(g(), d.defaultParameters || {});
            a.jsPlumb.extend(b, j || {}),
            j = b
        }
          , i = b.adapter
          , j = b.parameters || {}
          , k = b.getElementForNode
          , l = a.Farahey.getInstance({
            getPosition: function(a) {
                var b = p[a.id];
                return {
                    left: b[0],
                    top: b[1]
                }
            },
            getSize: function(a) {
                return x[a.id]
            },
            getId: function(a) {
                return a.id
            },
            setPosition: function(a, b) {
                J(a.id, b.left, b.top)
            },
            padding: j.padding,
            filter: function(a) {
                return (!v[a] || !v[a].group) && (!d.canMagnetize || d.canMagnetize(a))
            }
        })
          , m = b.magnetized !== !1 && (d.defaultMagnetized || b.magnetize === !0);
        this.decorators = f(b.decorators, b.adapter, b.container),
        this.adapter = b.adapter;
        var n = b.jsPlumb || a.jsPlumb
          , o = b.jsPlumbToolkit
          , p = {}
          , q = []
          , r = 1 / 0
          , s = 1 / 0
          , t = -(1 / 0)
          , u = -(1 / 0)
          , v = {}
          , w = {}
          , x = {}
          , y = b.container
          , z = n.getSize(y)
          , A = b.width || z[0]
          , B = b.height || z[1]
          , C = !1
          , D = function() {
            C = !1,
            r = 1 / 0,
            t = -(1 / 0),
            s = 1 / 0,
            u = -(1 / 0);
            for (var a = 0; a < d.decorators.length; a++)
                d.decorators[a].reset({
                    remove: n.remove
                });
            p = {},
            q.splice(0),
            x = {},
            l.reset(),
            d.reset && d.reset()
        };
        this.getMagnetizedElements = function() {
            return l.getElements()
        }
        ,
        this.magnetize = function(a) {
            a = a || {};
            var b = a.event ? "executeAtEvent" : a.origin ? "execute" : "executeAtCenter"
              , c = a.event ? [a.event, a.options] : a.origin ? [a.origin, a.options] : [a.options];
            l[b].apply(l, c),
            N(n.repaintEverything)
        }
        ,
        this.nodeAdded = function(a, b) {
            var c = b && b.position ? b.position : a.node.data && a.node.data.left && a.node.data.top ? a.node.data : d.adapter.getOffset(a.el);
            if (this._nodeAdded) {
                var e = this._nodeAdded(a, b);
                e && (c.left = e[0],
                c.top = e[1])
            }
            v[a.node.id] = a.node,
            J(a.node.id, c.left, c.top),
            E(a.node.id, a.el),
            l.addElement(a.node)
        }
        ,
        this.nodeRemoved = function(a) {
            delete p[a],
            delete x[a],
            delete v[a],
            this._nodeRemoved && this._nodeRemoved(a),
            l.removeElement(b.node)
        }
        ,
        this.groupAdded = function(a, b) {
            var c = b && b.position ? b.position : a.group.data && a.group.data.left && a.group.data.top ? a.group.data : d.adapter.getOffset(a.el);
            if (this._groupAdded) {
                var e = this._groupAdded(a, b);
                e && (c.left = e[0],
                c.top = e[1])
            }
            w[a.group.id] = a.group,
            J(a.group.id, c.left, c.top),
            E(a.group.id, a.el),
            l.addElement(a.group)
        }
        ,
        this.groupRemoved = function(a) {
            delete p[a],
            delete x[a],
            delete w[a],
            this._groupRemoved && this._groupRemoved(a),
            l.removeElement(b.group)
        }
        ;
        var E = function(a, b) {
            var c = x[a];
            return c || (b = b || k(a),
            null != b ? (c = n.getSize(b),
            x[a] = c) : c = [0, 0]),
            c
        }
          , F = function(a, b, c, d) {
            var e = p[a];
            if (!e) {
                if (null != b && null != c)
                    e = [b, c];
                else {
                    if (d)
                        return null;
                    e = [Math.floor(Math.random() * (A + 1)), Math.floor(Math.random() * (B + 1))]
                }
                J(a, e[0], e[1])
            }
            return e
        }
          , G = function(a) {
            r = Math.min(r, a[0]),
            s = Math.min(s, a[1]),
            t = Math.max(t, a[0]),
            u = Math.max(u, a[1])
        }
          , H = function(a, b, c) {
            var d = p[a];
            d ? (d[0] = parseFloat(b),
            d[1] = parseFloat(c)) : (d = p[a] = [parseFloat(b), parseFloat(c)],
            q.push([d, a])),
            G(d)
        }
          , I = function(a, b, c) {
            v[a] && d._nodeMoved ? d._nodeMoved(a, b, c) : w[a] && d._groupMoved && d._groupMoved(a, b, c)
        }
          , J = (this.setMagnetizedPosition = function(a, b, c, d) {
            H(a, b, c),
            this.magnetize({
                options: {
                    filter: function(b) {
                        return b === a
                    },
                    padding: [5, 5],
                    exclude: function(a, b) {
                        return null != b.group
                    },
                    excludeFocus: !0
                }
            });
            var e = this.getPosition(a);
            return d && I(a, e[0], e[1]),
            e
        }
        ,
        this.setPosition = function(a, b, c, d) {
            H(a, b, c),
            d && I(a, b, c)
        }
        )
          , K = function(a, b, c) {
            b = b || 10,
            c = c || 10;
            var d = p[a];
            return d || (d = p[a] = []),
            d[0] = Math.floor(Math.random() * b),
            d[1] = Math.floor(Math.random() * c),
            G(d),
            d
        }
          , L = function() {
            for (var a in p)
                console.log(a, p[a][0], p[a][1])
        }
          , M = function(a, b) {
            var c = k(a);
            if (null != c) {
                var e = p[a];
                return d.adapter.setPosition(c, e[0], e[1], b),
                Q[a] = [e[0], e[1]],
                e.concat(E(a))
            }
            return null
        }
        .bind(this)
          , N = this.draw = function(a) {
            for (var b in p) {
                var c = M(b);
                null != c && (r = Math.min(c[0], r),
                s = Math.min(c[1], s),
                t = Math.max(c[0] + c[2], t),
                u = Math.max(c[1] + c[3], u))
            }
            for (var e = 0; e < d.decorators.length; e++)
                d.decorators[e].decorate({
                    adapter: d.adapter,
                    layout: d,
                    append: function(a, b, c) {
                        d.adapter.append(a, b, c, !0)
                    },
                    setAbsolutePosition: d.adapter.setAbsolutePosition,
                    toolkit: o,
                    jsPlumb: n,
                    bounds: [r, s, t, u],
                    floatElement: d.adapter.floatElement,
                    fixElement: d.adapter.fixElement
                });
            a && a()
        }
          , O = function(a) {
            console.log(a);
            var b = e(p, E, k);
            L(),
            console.log(b[0], b[1], b[2], b[3])
        };
        this.bb = O;
        var P = this.getPositions = function() {
            return p
        }
          , Q = (this.getPosition = function(a) {
            return p[a]
        }
        ,
        {})
          , R = (this.getSize = function(a) {
            return x[a]
        }
        ,
        this.setSize = function(a, b) {
            x[a] = b
        }
        );
        this.begin = function(a, b) {}
        ,
        this.end = function(a, b) {}
        ;
        var S = function(a) {
            if (null != o) {
                h(),
                l.setElements(i.getNodes()).addElements(i.getGroups(), !0),
                this.begin && this.begin(o, j);
                for (var b = function() {
                    N(function() {
                        m && d.magnetize(),
                        d.end && d.end(o, j),
                        a && a()
                    })
                }; !C; )
                    this.step(o, j);
                b()
            }
        }
        .bind(this);
        return this.relayout = function(a, b) {
            D(),
            null != a && (j = a),
            S(b)
        }
        ,
        this.layout = function(a) {
            C = !1,
            S(a)
        }
        ,
        this.clear = function() {
            D()
        }
        ,
        {
            adapter: b.adapter,
            jsPlumb: n,
            toolkit: o,
            getPosition: F,
            setPosition: J,
            getRandomPosition: K,
            getSize: E,
            setSize: R,
            getPositions: P,
            setPositions: function(a) {
                p = a
            },
            width: A,
            height: B,
            reset: D,
            draw: N,
            setDone: function(a) {
                C = a,
                c()
            }
        }
    }
    ,
    c.EmptyLayout = function(a) {
        var b = {};
        this.refresh = this.relayout = this.layout = function() {
            this.clear();
            for (var c = a.getNodeCount(), d = 0; d < c; d++) {
                var e = a.getNodeAt(d);
                b[e.getFullId()] = [0, 0]
            }
            for (c = a.getGroupCount(),
            d = 0; d < c; d++)
                e = a.getGroupAt(d),
                b[e.id] = [0, 0]
        }
        ,
        this.nodeRemoved = this.groupRemoved = function(a) {
            delete b[a.id]
        }
        ,
        this.nodeAdded = this.groupAdded = function(a) {
            b[a.id] = !1
        }
        ,
        this.getPositions = function() {
            return b
        }
        ,
        this.getPosition = function(a) {
            return b[a]
        }
        ,
        this.setPosition = function(a, c, d) {
            b[a] = [c, d]
        }
        ,
        this.clear = function() {}
        ,
        this.getMagnetizedElements = function() {
            return []
        }
    }
    ,
    c.Mistletoe = function(b) {
        if (!b.parameters.layout)
            throw "No layout specified for MistletoeLayout";
        var e = {}
          , f = a.jsPlumb.extend({}, b);
        f.getElementForNode = function(a) {
            return e[a]
        }
        ;
        var g, h, i, j = c.AbstractLayout.apply(this, [f]), k = b.parameters.layout, l = function() {
            j.setPositions(k.getPositions()),
            j.draw(),
            this.fire("redraw")
        }
        .bind(this);
        d.EventGenerator.apply(this, arguments),
        this.map = function(a, b) {
            e[a] = b
        }
        ;
        var m = function() {
            e = {},
            g = k.layout,
            h = k.relayout,
            i = k.clear,
            k.layout = function() {
                g.apply(k, arguments),
                l()
            }
            ,
            k.relayout = function() {
                j.reset(),
                h.apply(k, arguments),
                l()
            }
            ,
            k.clear = function() {
                i.apply(k, arguments),
                j.reset()
            }
        };
        m(),
        this.setHostLayout = function(a) {
            k = a,
            m()
        }
    }
    ;
    var g = c.AbsoluteBackedLayout = function(a) {
        a = a || {};
        var b = c.AbstractLayout.apply(this, arguments)
          , d = function(a) {
            return [a.data.left, a.data.top]
        }
          , e = function(b, c) {
            return (a.locationFunction || d)(b)
        }
          , f = function(a, c, d, f) {
            for (var g = b.adapter[a](), h = 0; h < g; h++) {
                var i = b.adapter[c](h)
                  , j = i.getFullId()
                  , k = b.getPosition(j, null, null, !0);
                null == k && (k = e(i, f)),
                this.setPosition(j, k[0], k[1], !0)
            }
        }
        .bind(this);
        return this.begin = function(a, b) {
            f("getNodeCount", "getNodeAt", a, b),
            f("getGroupCount", "getGroupAt", a, b)
        }
        ,
        this._nodeAdded = function(b, c) {
            return e(b.node, a.parameters || {})
        }
        ,
        this._groupAdded = function(b, c) {
            return e(b.group, a.parameters || {})
        }
        ,
        this.getAbsolutePosition = function(a, b) {
            return e(a, b)
        }
        ,
        this.step = function() {
            b.setDone(!0)
        }
        ,
        b
    }
    ;
    d.extend(g, c.AbstractLayout),
    c.Absolute = function(a) {
        c.AbsoluteBackedLayout.apply(this, arguments)
    }
    ,
    d.extend(c.Absolute, c.AbsoluteBackedLayout);
    var h = c.AbstractHierarchicalLayout = function(a) {
        var b = this
          , d = c.AbstractLayout.apply(this, arguments);
        return b.begin = function(b, c) {
            c.ignoreLoops = !(a.ignoreLoops === !1),
            c.getRootNode = c.getRootNode || function(b) {
                return a.multipleRoots !== !1 ? b.filter(function(a) {
                    return "Node" === a.objectType && 0 == a.getTargetEdges().length && null == a.group || "Group" === a.objectType && 0 == a.getTargetEdges().length
                }).getAll() : d.adapter.getNodeCount() > 0 ? d.adapter.getNodeAt(0) : null
            }
            ,
            c.getChildEdges = c.getChildEdges || function(b, c) {
                return d.toolkit.getAllEdgesFor(b, function(c) {
                    return c.source === b || a.ignorePorts !== !0 && c.source.getNode && c.source.getNode() === b
                })
            }
            ,
            c.rootNode = c.getRootNode(b),
            c.rootNode || d.setDone(!0)
        }
        ,
        d
    }
    ;
    d.extend(h, c.AbstractLayout)
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumbToolkit
      , c = b.Layouts
      , d = a.Farahey;
    c.Circular = function(a) {
        function b(a) {
            for (var b = [], c = f ? 1 : 0, d = c; d < a.length; d++)
                a[d].group || b.push(a[d]);
            return b
        }
        a = a || {};
        var e = c.AbstractLayout.apply(this, arguments)
          , f = !!a.parameters && a.parameters.centerRootNode === !0;
        this.defaultParameters = {
            padding: 30,
            locationFunction: a.locationFunction
        },
        this.step = function(a, c) {
            var g = []
              , h = e.adapter.getNodes();
            if (0 === h.length)
                return void e.setDone(!0);
            Array.prototype.push.apply(g, b(h)),
            Array.prototype.push.apply(g, e.adapter.getGroups());
            var i, j, k = 0, l = 0, m = 10, n = 2 * Math.PI / g.length, o = -Math.PI / 2;
            if (f) {
                var p = e.getSize(h[0].id);
                m = Math.max(p[0], p[1]) + 80
            }
            for (i = 0; i < g.length; i++)
                if (j = g[i],
                e.setPosition(j.id, k + Math.sin(o) * m, l + Math.cos(o) * m, !0),
                o += n,
                i > 0) {
                    var q = g[i - 1]
                      , r = e.getSize(q.id)
                      , s = e.getPosition(q.id)
                      , t = {
                        x: s[0] - c.padding,
                        y: s[1] - c.padding,
                        w: r[0] + 2 * c.padding,
                        h: r[1] + 2 * c.padding
                    }
                      , u = g[i]
                      , v = e.getSize(u.id)
                      , w = e.getPosition(u.id)
                      , x = {
                        x: w[0] - c.padding,
                        y: w[1] - c.padding,
                        w: v[0] + 2 * c.padding,
                        h: v[1] + 2 * c.padding
                    }
                      , y = d.calculateSpacingAdjustment(t, x)
                      , z = [s[0] + r[0] / 2, s[1] + r[1] / 2]
                      , A = [w[0] + y.left + v[0] / 2, w[1] + y.top + +(v[1] / 2)]
                      , B = Math.sqrt(Math.pow(z[0] - A[0], 2) + Math.pow(z[1] - A[1], 2));
                    m = Math.max(m, B / 2 / Math.sin(n / 2))
                }
            for (i = 0; i < g.length; i++)
                j = g[i],
                e.setPosition(j.id, k + Math.sin(o) * m, l + Math.cos(o) * m, !0),
                o += n;
            e.setDone(!0)
        }
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumbToolkit
      , c = b.Layouts
      , d = a.jsPlumbUtil;
    c.Hierarchical = function(a) {
        var b, e, f, g, h, i, j, k = c.AbstractHierarchicalLayout.apply(this, arguments), l = [], m = null != a.parameters && a.parameters.compress, n = [], o = [], p = k.toolkit.getNodeId, q = function(a) {
            var b = n[a];
            return b || (b = {
                nodes: [],
                pointer: 0
            },
            n[a] = b),
            b
        }, r = function(a, b, c, d, e) {
            var g = q(c)
              , i = {
                node: a,
                parent: d,
                childGroup: e,
                loc: g.pointer,
                index: g.nodes.length,
                dimensions: b,
                size: b[f]
            }
              , j = b[0 == f ? 1 : 0];
            return null == l[c] ? l[c] = j : l[c] = Math.max(l[c], j),
            g.pointer += b[f] + h[f],
            g.nodes.push(i),
            i
        }, s = function(a, b) {
            var c = o[b];
            c || (c = [],
            o[b] = c),
            a.index = c.length,
            c.push(a)
        }, t = function(a) {
            if (a.size > 0) {
                var b = a.parent.loc + a.parent.size / 2 - (a.size - h[f]) / 2
                  , c = o[a.depth]
                  , d = -(1 / 0)
                  , e = 0;
                if (null != c && c.length > 0) {
                    var g = c[c.length - 1]
                      , i = g.nodes[g.nodes.length - 1];
                    d = i.loc + i.size + h[f]
                }
                b >= d ? a.loc = b : (e = d - b,
                a.loc = d);
                for (var j = a.loc, k = 0; k < a.nodes.length; k++)
                    a.nodes[k].loc = j,
                    j += a.nodes[k].size,
                    j += h[f];
                e > 0 && v(a),
                s(a, a.depth)
            }
        }, u = function(a) {
            var b = a.nodes[0].loc
              , c = a.nodes[a.nodes.length - 1].loc + a.nodes[a.nodes.length - 1].size
              , d = (b + c) / 2
              , e = d - a.parent.size / 2
              , f = e - a.parent.loc;
            if (a.parent.loc = e,
            !a.parent.root)
                for (var g = a.parent.childGroup, h = a.parent.childGroupIndex + 1; h < g.nodes.length; h++)
                    g.nodes[h].loc += f
        }, v = function(a) {
            for (var b = a; null != b; )
                u(b),
                b = b.parent.childGroup
        }, w = function(a, b) {
            return b.source === a || b.source.getNode && b.source.getNode() === a
        }, x = function(a, b) {
            if (!i[a.node.id]) {
                i[a.node.id] = !0;
                var c, d = j(a.node, k.toolkit), e = {
                    nodes: [],
                    loc: 0,
                    size: 0,
                    parent: a,
                    depth: b + 1
                }, g = [], l = {};
                for (c = 0; c < d.length; c++) {
                    var m = w(a.node, d[c]) ? d[c].target : d[c].source;
                    if (m.getNode && (m = m.getNode()),
                    m = k.toolkit.getNode(m),
                    null != m && m !== a.node && !l[m.id]) {
                        var n = k.getSize(p(m))
                          , o = r(m, n, b + 1, a, e);
                        o.childGroupIndex = e.nodes.length,
                        e.nodes.push(o),
                        e.size += n[f] + h[f],
                        g.push(o),
                        l[m.id] = !0
                    }
                }
                for (t(e),
                c = 0; c < g.length; c++)
                    x(g[c], b + 1)
            }
        };
        this.defaultParameters = {
            padding: [60, 60],
            orientation: "horizontal",
            border: 0,
            locationFunction: a.locationFunction
        };
        var y = this.begin;
        this.begin = function(a, c) {
            y.apply(this, arguments),
            b = c.orientation,
            e = "horizontal" === b,
            f = e ? 0 : 1,
            g = e ? "width" : "height",
            h = c.padding,
            n.length = 0,
            o.length = 0,
            i = {},
            j = c.getChildEdges
        }
        ,
        this.step = function(a, b) {
            for (var c, e, g, i = d.isArray(b.rootNode) ? b.rootNode : [b.rootNode], j = 0; j < i.length; j++) {
                c = i[j];
                var o = k.getSize(c.id)
                  , q = r(c, o, 0, null, null);
                q.root = !0,
                x(q, 0, null);
                var s, t, u = 0, v = function(a, b) {
                    var c = 0 == f ? 1 : 0;
                    return m && a.parent ? k.getPosition(p(a.parent.node))[c] + a.parent.dimensions[c] + h[c] : b
                };
                for (e = 0; e < n.length; e++) {
                    for (n[e].otherAxis = u,
                    g = 0; g < n[e].nodes.length; g++)
                        s = 0 == f ? n[e].nodes[g].loc : v(n[e].nodes[g], u),
                        n[e].nodes[g].parent && k.getPosition(p(n[e].nodes[g].parent.node)),
                        t = 1 == f ? n[e].nodes[g].loc : v(n[e].nodes[g], u),
                        k.setPosition(p(n[e].nodes[g].node), s, t, !0);
                    n[e].otherAxisSize = l[e] + h[0 == f ? 1 : 0],
                    u += n[e].otherAxisSize
                }
            }
            k.setDone(!0)
        }
        ,
        this.getHierarchy = function() {
            return n
        }
        ,
        this.getOrientation = function() {
            return b
        }
        ;
        var z = this.nodeRemoved;
        this.nodeRemoved = function() {
            n = [],
            z.apply(this, arguments)
        }
        ,
        this.getPadding = function() {
            return h
        }
    }
    ,
    d.extend(c.Hierarchical, c.AbstractHierarchicalLayout)
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    var a = this
      , b = a.jsPlumbToolkit;
    b.Layouts.Decorators.Hierarchy = function(a) {
        var b, c, d = [];
        this.reset = function(a) {
            for (var c = 0; c < d.length; c++)
                a.remove(d[c]);
            b && a.remove(b),
            d.length = 0
        }
        ,
        this.decorate = function(a) {
            if (a.bounds[0] != 1 / 0) {
                var b = a.layout.getHierarchy();
                c = (a.layout.getPadding() || [60, 60])["horizontal" === d ? 0 : 1];
                for (var d = a.layout.getOrientation(), e = "horizontal" === d ? ["width", "height", a.bounds[2] - a.bounds[0]] : ["height", "width", a.bounds[3] - a.bounds[1]], f = 0; f < b.length; f++) {
                    var g = document.createElement("div");
                    a.append(g),
                    g.className = "level " + (f % 2 ? "odd" : "even"),
                    g.style[e[0]] = e[2] + 2 * c + "px",
                    g.style[e[1]] = b[f].otherAxisSize + "px";
                    var h = "horizontal" === d ? [a.bounds[0] - c, b[f].otherAxis - c / 2] : [b[f].otherAxis - c / 2, a.bounds[1] - c];
                    a.setAbsolutePosition(g, h)
                }
            }
        }
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumbToolkit
      , c = b.Layouts
      , d = a.jsPlumbUtil;
    c.Spring = function(a) {
        this.defaultMagnetized = !0;
        var b = c.AbsoluteBackedLayout.apply(this, arguments);
        this.defaultParameters = {
            padding: [50, 50],
            iterations: 500,
            maxRepulsiveForceDistance: 6,
            k: 2,
            c: .01,
            maxVertexMovement: .5,
            locationFunction: a.locationFunction
        };
        var d, e = this.defaultParameters, f = {}, g = a.absoluteBacked !== !1, h = 0, i = 1 / 0, j = -(1 / 0), k = 1 / 0, l = -(1 / 0), m = 1, n = 1, o = 0, p = function(a) {
            a.getNode && (a = a.getNode());
            var c = f[a.id];
            if (!c) {
                var d = b.getRandomPosition(a.id, .5, .5);
                c = f[a.id] = {
                    id: a.id,
                    n: a,
                    sp: d,
                    p: [d[0], d[1]],
                    f: [0, 0]
                }
            }
            return c
        }, q = function(a, b, c) {
            i = Math.min(i, b),
            k = Math.min(k, c),
            j = Math.max(j, b),
            l = Math.max(l, c),
            a.p[0] = b,
            a.p[1] = c
        }, r = function(a, b) {
            if (!a.locked || !b.locked) {
                var c = b.p[0] - a.p[0]
                  , d = b.p[1] - a.p[1]
                  , f = c * c + d * d;
                f < .01 && (c = .1 * Math.random() + .1,
                d = .1 * Math.random() + .1,
                f = c * c + d * d);
                var g = Math.sqrt(f);
                if (g < e.maxRepulsiveForceDistance) {
                    o++;
                    var h = e.k * e.k / g
                      , i = h * c / g
                      , j = h * d / g;
                    b.f[0] += b.locked ? 0 : (a.locked ? 2 : 1) * i,
                    b.f[1] += b.locked ? 0 : (a.locked ? 2 : 1) * j,
                    a.f[0] -= a.locked ? 0 : (b.locked ? 2 : 1) * i,
                    a.f[1] -= a.locked ? 0 : (b.locked ? 2 : 1) * j
                }
            }
        }, s = function(a, b) {
            var c = p(b.target);
            if (!a.locked || !c.locked) {
                o++;
                var d = c.p[0] - a.p[0]
                  , f = c.p[1] - a.p[1]
                  , g = d * d + f * f;
                g < .01 && (d = .1 * Math.random() + .1,
                f = .1 * Math.random() + .1,
                g = d * d + f * f);
                var h = Math.sqrt(g);
                h > e.maxRepulsiveForceDistance && (h = e.maxRepulsiveForceDistance,
                g = h * h);
                var i = (g - e.k * e.k) / e.k;
                (void 0 == b.weight || b.weight < 1) && (b.weight = 1),
                i *= .5 * Math.log(b.weight) + 1;
                var j = i * d / h
                  , k = i * f / h;
                c.f[0] -= c.locked ? 0 : (a.locked ? 2 : 1) * j,
                c.f[1] -= c.locked ? 0 : (a.locked ? 2 : 1) * k,
                a.f[0] += a.locked ? 0 : (c.locked ? 2 : 1) * j,
                a.f[1] += a.locked ? 0 : (c.locked ? 2 : 1) * k
            }
        }, t = function() {
            m = b.width / (j - i) * .62,
            n = b.height / (l - k) * .62;
            for (var a in f) {
                var c = f[a];
                c.locked || (c.sp = v(c.p),
                b.setPosition(c.id, c.sp[0], c.sp[1], !0))
            }
        }, u = function(a) {
            return [i + (a[0] - .19 * b.width) / m, k + (a[1] - .19 * b.height) / n]
        }, v = function(a) {
            return [.19 * b.width + (a[0] - i) * m, .19 * b.height + (a[1] - k) * n]
        };
        this._nodeMoved = this._groupMoved = function(a, b, c) {
            var d = f[a];
            d && (d.sp = [b, c],
            d.p = u(d.sp))
        }
        ,
        this.canMagnetize = function(a) {
            return f[a] && f[a].locked !== !0
        }
        ,
        this.reset = function() {
            f = {},
            h = 0,
            i = k = 1 / 0,
            j = l = -(1 / 0)
        }
        ,
        this._nodeRemoved = this._groupRemoved = function(a) {
            delete f[a]
        }
        ,
        this._nodeAdded = this._groupAdded = function(a, c) {
            if (c && c.position) {
                var d = p(a.node || a.group);
                d && (d.locked = !0,
                b.setPosition(d.id, c.position.left, c.position.top, !0))
            }
        }
        ,
        this.begin = function(a, c) {
            h = 0,
            d = [],
            Array.prototype.push.apply(d, b.adapter.getNodes()),
            Array.prototype.push.apply(d, b.adapter.getGroups())
        }
        ,
        this.step = function(a, c) {
            var f, i = [], j = function(a) {
                return i[a] ? i[a] : function() {
                    return i[a] = p(d[a]),
                    i[a]
                }()
            };
            for (o = 0,
            f = 0; f < d.length; f++) {
                var k = j(f);
                if (!k.group) {
                    if (g && !k.locked) {
                        var l = this.getAbsolutePosition(k.n, c);
                        if (null != l && 2 == l.length && !isNaN(l[0]) && !isNaN(l[1])) {
                            q(k, l[0], l[1]),
                            k.sp = k.p,
                            b.setPosition(k.id, l[0], l[1], !0),
                            k.locked = !0;
                            continue
                        }
                    }
                    for (var m = f + 1; m < d.length; m++) {
                        var n = j(m);
                        r(k, n)
                    }
                    for (var u = b.toolkit.getAllEdgesFor(k.n), v = 0; v < u.length; v++)
                        s(k, u[v])
                }
            }
            if (0 != o)
                for (f = 0; f < d.length; f++) {
                    var w = j(f);
                    if (!w.group) {
                        var x = e.c * w.f[0]
                          , y = e.c * w.f[1]
                          , z = e.maxVertexMovement;
                        x > z && (x = z),
                        x < -z && (x = -z),
                        y > z && (y = z),
                        y < -z && (y = -z),
                        q(w, w.p[0] + x, w.p[1] + y),
                        w.f[0] = 0,
                        w.f[1] = 0
                    }
                }
            h++,
            (0 == o || h >= e.iterations) && (t(),
            b.setDone(!0))
        }
        ,
        this.end = function() {
            for (var a in f)
                f[a].locked = !0
        }
    }
    ,
    d.extend(c.Spring, c.AbsoluteBackedLayout)
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = (a.jsPlumb,
    a.jsPlumbToolkit);
    b.UI = b.UI || {};
    var c = b.UI;
    c.ActiveDragFilter = function(a, b, c) {
        var d = {};
        b.bind("connectionDrag", function(b) {
            function e(b, e) {
                f = c.beforeConnect(b, e),
                j = e.getFullId(),
                f === !1 && null == d[j] && (d[j] = a.setTargetEnabled(e, !1))
            }
            var f, g, h, i, j, k = b.source.jtk.port, l = k ? k.getNode() : b.source.jtk.node, m = c.getNodeCount();
            if (k)
                for (e(k, l),
                g = l.getPorts(),
                h = 0; h < g.length; h++)
                    e(k, g[h]);
            for (h = 0; h < m; h++) {
                var n = c.getNodeAt(h);
                for (e(k, n),
                g = n.getPorts(),
                i = 0; i < g.length; i++)
                    e(k, g[i])
            }
        }),
        b.bind("connectionDragStop", function() {
            function b(b) {
                d[b.getFullId()] === !0 && a.setTargetEnabled(b, !0)
            }
            for (var e = c.getNodeCount(), f = 0; f < e; f++) {
                var g = c.getNodeAt(f);
                b(g);
                for (var h = g.getPorts(), i = 0; i < h.length; i++)
                    b(h[i])
            }
            d = {}
        })
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumbToolkit.Renderers
      , c = a.jsPlumbToolkit
      , d = a.jsPlumbToolkitUtil
      , e = a.jsPlumbUtil
      , f = a.jsPlumb
      , g = a.Rotors;
    c.UIState = function(a, b, c) {
        for (var d in b)
            if (b.hasOwnProperty(d)) {
                var e = "*" === d ? "e-state-" + a : "e-state-" + a + "-" + d
                  , f = "*" === d ? "c-state-" + a : "c-state-" + a + "-" + d;
                c.registerEndpointType(e, b[d]),
                c.registerConnectionType(f, b[d])
            }
        this.activate = function(d, e, f) {
            d.eachEdge(function(c, d) {
                var h = e.getRenderedConnection(d.getId())
                  , i = f.getEdgeType(d.data)
                  , j = i ? "c-state-" + a + "-" + i : null;
                j && h.addType(j, d.data),
                b["*"] && h.addType("c-state-" + a, d.data),
                g(d, h, d.source, 0, "addType", f),
                g(d, h, d.target, 1, "addType", f)
            }),
            d.eachNode(function(a, d) {
                var g = f.getNodeType(d.data)
                  , h = g ? b[g] : null
                  , i = e.getRenderedNode(d.id);
                h && h.cssClass && c.addClass(i, h.cssClass),
                b["*"] && c.addClass(i, b["*"].cssClass)
            })
        }
        ;
        var g = function(b, c, d, e, f, g) {
            var h = c.endpoints[e]
              , i = g.getPortType(d.data);
            h[f]("e-state-" + a + "-" + i),
            h[f]("e-state-" + a)
        };
        this.deactivate = function(d, e, f) {
            d.eachEdge(function(c, d) {
                var h = e.getRenderedConnection(d.getId())
                  , i = f.getEdgeType(d.data)
                  , j = i ? "c-state-" + a + "-" + i : null;
                j && h.removeType(j, d.data),
                b["*"] && h.removeType("c-state-" + a),
                g(d, h, d.source, 0, "removeType", f),
                g(d, h, d.target, 1, "removeType", f)
            }),
            d.eachNode(function(a, d) {
                var g = f.getNodeType(d.data)
                  , h = g ? b[g] : null
                  , i = e.getRenderedNode(d.id);
                h && h.cssClass && c.removeClass(i, h.cssClass),
                b["*"] && c.removeClass(i, b["*"].cssClass)
            })
        }
    }
    ;
    var h = b.atts = {
        NODE: "data-jtk-node-id",
        PORT: "data-jtk-port-id",
        GROUP: "data-jtk-group-id"
    }
      , i = b.els = {
        SOURCE: "JTK-SOURCE",
        PORT: "JTK-PORT",
        TARGET: "JTK-TARGET"
    }
      , j = c.Classes
      , k = c.Constants
      , l = c.Events;
    b.mouseEvents = ["click", "dblclick", "contextmenu", "mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "mouseover"],
    b.createElement = function(a, b) {
        var c = {
            width: a.width,
            height: a.height,
            position: a.position || k.absolute
        }
          , d = {};
        a.display && (c.display = a.display),
        a.id && (d.id = a.id),
        a.top && (c.top = a.top + "px"),
        a.left && (c.left = a.left + "px"),
        a.right && (c.right = a.right + "px"),
        a.bottom && (c.bottom = a.bottom + "px");
        var e = f.createElement(a.type || k.div, c, a.clazz, d);
        return null != b && f.appendElement(e, b),
        e
    }
    ;
    var m = b.DOMElementAdapter = function(a) {
        var b = this.getJsPlumb()
          , c = b.getElement(a.container);
        this.getWidth = function() {
            return b.getSize(c)[0]
        }
        ,
        this.getHeight = function() {
            return b.getSize(c)[1]
        }
        ,
        this.append = function(a) {
            var d = b.getElement(a);
            b.appendElement(d, c)
        }
        ,
        this.remove = function(a) {
            var c = b.getElement(a);
            b.removeElement(c)
        }
        ,
        this.setAbsolutePosition = f.setAbsolutePosition,
        this.getOffset = function(a, c) {
            return b.getOffset(a, c)
        }
    }
      , n = b.AbstractRenderer = function(a) {
        function b(a) {
            Q = !0;
            try {
                a()
            } catch (a) {
                jsPlumbUtil.log("An error occurred while ignoring Toolkit events", a)
            } finally {
                Q = !1
            }
        }
        function m(a, b, c) {
            if (null == a.value("jtk-processed")) {
                a.setValue("jtk-processed", !0);
                var d = ya(a, b, c)
                  , e = J.addEndpoint(a.element, d);
                xa[b.id + "." + d.portId] = e;
                var f = a.port || b.addPort({
                    id: d.portId
                });
                e.graph = {
                    node: b,
                    port: f
                },
                t.onUpdate(a.element, function() {})
            }
        }
        function n(a, b, c) {
            if (null == a.value("jtk-processed")) {
                a.setValue("jtk-processed", !0);
                var d = ya(a, b, c);
                null != d.portId && (T[b.id + "." + d.portId] = a.element,
                a.element.jtk = a.element.jtk || {},
                a.element.jtk.port = v.addPort(b, {
                    id: d.portId,
                    type: d.portType || "default"
                }, !0));
                var e = a.value("filter");
                if (e) {
                    var g = a.value("filter-exclude")
                      , h = "true" === g;
                    d.filter = e,
                    d.filterExclude = h
                }
                "true" === a.value("is-source") && (d.isSource = !0),
                delete d.uniqueEndpoint,
                d.extract = {},
                a.findDataValues(d.extract);
                var i, j = a.element._katavorioDrop ? a.element._katavorioDrop.length : 0;
                J.makeSource(a.element, d);
                var k = a.element._katavorioDrop ? a.element._katavorioDrop.length : 0;
                k > j && (i = a.element._katavorioDrop[a.element._katavorioDrop.length - 1]),
                t.onUpdate(a.element, function(a, c) {
                    var d = f.getSelector(a, "jtk-source");
                    if (1 === d.length) {
                        var e = ya(d[0], b);
                        e.scope && (J.setSourceScope(a, e.scope, e.edgeType),
                        i && i.k.setDropScope(i, e.scope))
                    }
                })
            }
        }
        function o(a, b, c) {
            if (null == a.value("jtk-processed")) {
                a.setValue("jtk-processed", !0);
                var d = ya(a, b, c);
                null != d.portId && (T[b.id + "." + d.portId] = a.element,
                a.element.jtk = a.element.jtk || {},
                a.element.jtk.port = v.addPort(b, {
                    id: d.portId,
                    type: d.portType || "default"
                }, !0)),
                "true" === a.value("is-target") && (d.isTarget = !0),
                J.makeTarget(a.element, d);
                var e = a.element._katavorioDrop[a.element._katavorioDrop.length - 1];
                t.onUpdate(a.element, function(a, c) {
                    var d = f.getSelector(a, "jtk-target");
                    if (1 === d.length) {
                        var g = ya(d[0], b);
                        g.scope && (e.targetDef.def.scope = g.scope,
                        e.k.setDropScope(e, g.scope))
                    }
                })
            }
        }
        a = a || {};
        var p = function(a, b) {
            var c = f.createElement("div", {
                border: "1px solid #456",
                position: "absolute"
            }, j.NODE);
            return c.innerHTML = a.name || a.id,
            c
        }
          , q = '<div data-jtk-node-id="${id}" class="' + j.NODE + '"></div>'
          , r = {
            rotors: {
                render: function(a, b) {
                    return t.template(a, b).childNodes[0]
                }
            }
        }
          , s = "rotors"
          , t = g.newInstance({
            defaultTemplate: q,
            templateResolver: a.templateResolver,
            templates: a.templates
        })
          , u = this
          , v = a.toolkit
          , w = new c.Layouts.EmptyLayout(u)
          , x = f.getElement(a.container)
          , y = !(a.elementsDraggable === !1)
          , z = a.elementsDroppable === !0
          , A = !1
          , B = a.refreshAutomatically !== !1
          , C = a.templateRenderer ? e.isString(a.templateRenderer) ? r[a.templateRenderer] : {
            render: a.templateRenderer
        } : r[s]
          , D = a.enhancedView !== !1
          , E = a.assignPosse || function() {
            return null
        }
          , F = a.modelLeftAttribute || "left"
          , G = a.modelTopAttribute || "top"
          , H = a.storePositionsInModel !== !1
          , I = e.merge(a.jsPlumb || {})
          , J = a.jsPlumbInstance || f.getInstance(I, a.overrideFns)
          , K = J.getId(x);
        J.bind("beforeDrop", function(a) {
            var b = a.connection
              , c = b.endpoints[0].graph || b.source.jtk
              , d = b.endpoints[1].graph || b.target.jtk
              , e = c.port || c.node || c.group
              , f = d.port || d.node || d.group
              , g = a.connection.edge;
            return null == g ? v.beforeConnect(e, f, a.connection.getData()) : v.beforeMoveConnection(e, f, g)
        }),
        J.bind("beforeDrag", function(a) {
            var b = a.endpoint.graph || a.source.jtk
              , c = b.port || b.node
              , d = a.endpoint.connectionType
              , e = v.beforeStartConnect(c, d);
            return e === !1 && a.endpoint.isTemporarySource && a.endpoint._deleteOnDetach && J.deleteEndpoint(a.endpoint),
            e
        }),
        J.bind("beforeDetach", function(a, b) {
            var c = a.endpoints[0].graph || a.source.jtk
              , d = a.endpoints[1].graph || a.target.jtk
              , e = c.port || c.node
              , f = d.port || d.node
              , g = a.edge;
            return v.beforeDetach(e, f, g, b)
        }),
        J.bind("beforeStartDetach", function(a) {
            var b = a.endpoint.graph || a.source.jtk
              , c = b.port || b.node
              , d = a.connection.edge;
            return v.beforeStartDetach(c, d)
        }),
        J.bind("connectionEdit", function(a) {
            a.edge && (a.edge.geometry = a.getConnector().getGeometry())
        }),
        e.EventGenerator.apply(this, arguments),
        a.activeFiltering && new c.UI.ActiveDragFilter(u,J,v),
        this.getJsPlumb = function() {
            return J
        }
        ,
        this.getToolkit = function() {
            return v
        }
        ;
        var L = [l.canvasClick, l.canvasDblClick, l.nodeAdded, l.nodeDropped, l.nodeRemoved, l.nodeRendered, l.groupAdded, l.groupRemoved, l.groupMoveEnd, l.groupMemberAdded, l.groupMemberRemoved, l.groupCollapse, l.groupExpand, l.nodeMoveStart, l.nodeMoveEnd, l.portAdded, l.portRemoved, l.edgeAdded, l.edgeRemoved, l.edgeTypeChanged, l.nodeTypeChanged, l.portTypeChanged, l.dataLoadEnd, l.anchorChanged, l.objectRepainted, l.modeChanged, l.lassoEnd, l.pan, l.zoom, l.relayout, l.click, l.tap, l.stateRestored, l.startOverlayAnimation, l.endOverlayAnimation]
          , M = u.bind
          , N = J.bind;
        if (this.setHoverSuspended = J.setHoverSuspended,
        this.isHoverSuspended = J.isHoverSuspended,
        this.setJsPlumbDefaults = function(a) {
            delete a.Container,
            J.restoreDefaults(),
            J.importDefaults(a)
        }
        ,
        this.bind = function(a, b) {
            L.indexOf(a) == -1 ? N(a, b) : M(a, b)
        }
        ,
        a.events)
            for (var O in a.events)
                this.bind(O, a.events[O]);
        if (a.interceptors)
            for (var P in a.interceptors)
                this.bind(P, a.interceptors[P]);
        var Q = !1;
        N(l.connection, function(a) {
            if (null == a.connection.edge) {
                Q = !0,
                a.sourceEndpoint.getParameter("nodeId") || a.sourceEndpoint.setParameter("nodeId", S[a.sourceEndpoint.elementId].id),
                a.targetEndpoint.getParameter("nodeId") || a.targetEndpoint.setParameter("nodeId", S[a.targetEndpoint.elementId].id);
                var b = a.sourceEndpoint.getParameter("portType")
                  , c = oa.getPortDefinition(b)
                  , d = null != c && c.edgeType ? c.edgeType : a.sourceEndpoint.getParameter("edgeType") || "default"
                  , e = a.sourceEndpoint.getParameter("nodeId")
                  , f = a.sourceEndpoint.getParameter("portId")
                  , g = a.targetEndpoint.getParameter("nodeId")
                  , h = a.targetEndpoint.getParameter("portId")
                  , i = e + (f ? "." + f : "")
                  , j = g + (h ? "." + h : "")
                  , k = {
                    sourceNodeId: e,
                    sourcePortId: f,
                    targetNodeId: g,
                    targetPortId: h,
                    type: d,
                    source: v.getNode(i),
                    target: v.getNode(j),
                    sourceId: i,
                    targetId: j
                }
                  , m = v.getEdgeFactory()(d, a.connection.getData() || {}, function(b) {
                    k.edge = v.addEdge({
                        source: i,
                        target: j,
                        cost: a.connection.getCost(),
                        directed: a.connection.isDirected(),
                        data: b,
                        addedByMouse: !0
                    }, u),
                    Z[k.edge.getId()] = a.connection,
                    a.connection.edge = k.edge,
                    ba(d, k.edge, a.connection),
                    k.addedByMouse = !0,
                    u.fire(l.edgeAdded, k)
                });
                m === !1 && J.detach(a.connection),
                Q = !1
            }
        }),
        N(l.connectionMoved, function(a) {
            var c = 0 === a.index ? a.newSourceEndpoint : a.newTargetEndpoint
              , d = c.graph || c.element.jtk;
            b(function() {
                v.edgeMoved(a.connection.edge, d.port || d.node || d.group, a.index)
            })
        }),
        N(l.connectionDetached, function(a) {
            b(function() {
                v.removeEdge(a.connection.edge)
            });
            var c = a.sourceEndpoint.getParameters()
              , d = a.targetEndpoint.getParameters()
              , e = c.nodeId + (c.portId ? "." + c.portId : "")
              , f = d.nodeId + (d.portId ? "." + d.portId : "");
            u.fire(l.edgeRemoved, {
                sourceNodeId: c.nodeId,
                targetNodeId: d.nodeId,
                sourcePortId: c.portId,
                targetPortId: d.portId,
                sourceId: e,
                targetId: f,
                source: v.getNode(e),
                target: v.getNode(f),
                edge: a.connection.edge
            })
        }),
        N(l.groupDragStop, function(a) {
            u.getLayout().setPosition(a.group.id, a.pos[0], a.pos[1], !0),
            a.uigroup = a.group,
            u.fire(l.groupMoveEnd, f.extend(a, {
                group: v.getGroup(a.uigroup.id)
            }))
        }),
        N(l.groupMemberAdded, function(a) {
            if (!A && a.el.jtk.node) {
                var b = v.addToGroup(a.el.jtk.node, a.group.id);
                b && u.fire(l.groupMemberAdded, {
                    node: a.el.jtk.node,
                    group: b,
                    uigroup: a.group
                }),
                ja()
            }
        }),
        N(l.groupMemberRemoved, function(a) {
            if (!A && a.el.jtk.node) {
                var b = v.removeFromGroup(a.el.jtk.node);
                b && (u.nodeRemovedFromGroup(a.el),
                u.fire(l.groupMemberRemoved, {
                    node: a.el.jtk.node,
                    ugroup: b,
                    igroup: a.group
                })),
                ja()
            }
        }),
        N(l.groupCollapse, function(a) {
            var b = v.getGroup(a.group.id);
            b && u.fire(l.groupCollapse, {
                group: b,
                uigroup: a.group
            })
        }),
        N(l.groupExpand, function(a) {
            var b = v.getGroup(a.group.id);
            b && u.fire(l.groupExpand, {
                group: b,
                uigroup: a.group
            })
        });
        var R = {}
          , S = {}
          , T = {}
          , U = {}
          , V = []
          , W = {}
          , X = []
          , Y = function(a) {
            var b = X.indexOf(a);
            b !== -1 && X.splice(b, 1)
        };
        this.getNodeCount = function() {
            return X.length
        }
        ,
        this.getNodeAt = function(a) {
            return X[a]
        }
        ,
        this.getNodes = function() {
            return X
        }
        ,
        this.getNode = function(a) {
            return R[a]
        }
        ,
        this.getGroupCount = function() {
            return V.length
        }
        ,
        this.getGroupAt = function(a) {
            return V[a]
        }
        ,
        this.getGroups = function() {
            return V
        }
        ;
        var Z = {}
          , $ = function(a) {
            return Z[a.getId()]
        }
          , _ = function(a) {
            for (var b = [], c = 0; c < a.length; c++)
                b.push(Z[a[c].getId()]);
            return b
        }
          , aa = function(a, b, c, d) {
            d.bind(a, function(a, e) {
                b.apply(b, [{
                    edge: c,
                    e: e,
                    connection: d,
                    toolkit: v,
                    renderer: u
                }])
            })
        }
          , ba = function(a, b, c) {
            if (!c.getParameter("edge")) {
                var d = oa.getEdgeDefinition(a);
                if (d && d.events)
                    for (var e in d.events)
                        aa(e, d.events[e], b, c)
            }
        }
          , ca = function(a, b) {
            var c = a.endpoints[0].getParameters()
              , d = a.endpoints[1].getParameters()
              , e = c.nodeId + (c.portId ? "." + c.portId : "")
              , f = d.nodeId + (d.portId ? "." + d.portId : "");
            u.fire(l.edgeRemoved, {
                sourceNodeId: c.nodeId,
                targetNodeId: d.nodeId,
                sourcePortId: c.portId,
                targetPortId: d.portId,
                sourceId: e,
                targetId: f,
                source: v.getNode(e),
                target: v.getNode(f),
                edge: b
            })
        };
        this.setSuspendRendering = function(a, b) {
            A = a,
            J.setSuspendDrawing(a),
            b && this.refresh()
        }
        ,
        this.batch = function(a) {
            this.setSuspendEvents(!0),
            v.batch(a),
            this.setSuspendEvents(!1)
        }
        ;
        var da = function(a, b) {
            if (A)
                fa.push([a, b]);
            else {
                var c = E(b);
                if (null != c) {
                    var d = e.isArray(c) ? c : [c];
                    d.unshift(a),
                    J.addToPosse.apply(J, d)
                }
            }
        }
          , ea = function() {
            for (var a = 0; a < fa.length; a++)
                da.apply(this, fa[a])
        }
          , fa = [];
        if (this.bindToolkitEvents !== !1) {
            var ga = function() {
                fa.length = 0,
                J.setSuspendDrawing(!0),
                this.setSuspendRendering(!0)
            }
            .bind(this);
            v.bind(l.dataLoadStart, ga),
            v.bind(l.dataAppendStart, ga),
            v.bind(l.dataLoadEnd, function() {
                this.setSuspendRendering(!1),
                ea(),
                J.getGroupManager().refreshAllGroups(),
                ma(),
                u.relayout(),
                J.setSuspendDrawing(!1, !0),
                w && u.fire(l.dataLoadEnd)
            }
            .bind(this)),
            v.bind(l.dataAppendEnd, function() {
                this.setSuspendRendering(!1),
                ea(),
                u.refresh(),
                J.setSuspendDrawing(!1, !0),
                w && u.fire(l.dataAppendEnd)
            }
            .bind(this));
            var ha = function(a, b, c) {
                var d = U[c.id];
                if (d) {
                    var e = d.querySelector("[jtk-group-content]") || d;
                    e.appendChild(a),
                    J.addToGroup(c.id, a, !0),
                    u.nodeAppendedToGroup(a, d, c)
                }
            }
              , ia = function(a, b) {
                var c = R[a.id];
                if (null == c) {
                    var d = oa.getNodeDefinition(v.getNodeType(a.data));
                    if (d.ignore === !0)
                        return !1;
                    if (c = ta(a, a.data, a),
                    !c)
                        throw new Error("Cannot render node");
                    var e = J.getId(c);
                    R[a.id] = c,
                    S[e] = a,
                    X.push(a),
                    c.jtk = {
                        node: a
                    },
                    null == a.group ? u.append(c, e, b ? b.position : null) : ha(c, a, a.group),
                    da(c, a),
                    Ba(c, a);
                    var f = {
                        node: a,
                        el: c,
                        id: a.id
                    };
                    u.getLayout().nodeAdded(f, b),
                    u.fire(l.nodeAdded, f)
                }
                return c
            };
            v.bind(l.nodeAdded, function(a) {
                var b, c = a.node, d = ia(c, a.eventInfo);
                if (null != d) {
                    var e = J.getSelector(d, "[data-port-id]");
                    for (b = 0; b < e.length; b++) {
                        var f = e[b].getAttribute("data-port-id");
                        T[c.id + "." + f] = e[b],
                        e[b].jtk = e[b].jtk || {
                            node: c,
                            port: c.getPort(f)
                        }
                    }
                    u.refresh(!0)
                }
            }),
            v.bind(l.nodeRemoved, function(a) {
                u.getLayout().nodeRemoved(a.nodeId);
                var b = R[a.nodeId];
                u.fire(l.nodeRemoved, {
                    node: a.nodeId,
                    el: b
                });
                var c = J.getId(b);
                t.remove(b),
                J.remove(b),
                delete R[a.nodeId],
                delete S[c],
                Y(a.node),
                delete b.jtk,
                u.refresh(!0)
            });
            var ja = function() {
                a.relayoutOnGroupUpdate && u.relayout()
            };
            v.bind("group:addMember", ja),
            v.bind("group:removeMember", ja);
            var ka = function(b, c) {
                var d = U[b.id];
                if (null == d) {
                    var g = oa.getGroupDefinition(v.getNodeType(b.data));
                    if (g.ignore === !0)
                        return !1;
                    if (d = va(b, b.data, b),
                    !d)
                        throw new Error("Cannot render Group");
                    var h = J.getId(d);
                    U[b.id] = d,
                    V.push(b),
                    W[h] = b,
                    d.jtk = {
                        group: b
                    },
                    u.append(d, h, c ? c.position : null),
                    da(d, b),
                    Ba(d, b);
                    var i = {
                        node: b,
                        el: d
                    }
                      , j = {
                        el: d,
                        id: b.id
                    };
                    f.extend(j, {
                        dragOptions: a.dragOptions || {}
                    }),
                    j.dragOptions[f.dragEvents[k.stop]] = e.wrap(j.dragOptions[f.dragEvents[k.stop]], function(a) {
                        a.el.jtk && a.el.jtk.group && (j.dragOptions.magnetize ? a.pos = u.getLayout().setMagnetizedPosition(a.el.jtk.group.id, a.pos[0], a.pos[1], !0) : u.getLayout().setPosition(a.el.jtk.group.id, a.pos[0], a.pos[1], !0),
                        H !== !1 && (u.storePositionInModel({
                            id: a.el.jtk.group.id,
                            group: !0,
                            leftAttribute: F,
                            topAttribute: G
                        }),
                        v.fire(l.groupUpdated, {
                            group: a.el.jtk.group
                        }, null)),
                        u.fire(l.groupMoveEnd, {
                            el: a.el,
                            group: a.el.jtk.group,
                            pos: a.pos,
                            e: a.e,
                            eventPosition: a.pos
                        }))
                    }),
                    J.addGroup(f.extend(j, g)),
                    u.getLayout().groupAdded({
                        group: b,
                        el: d,
                        id: b.id
                    }, c),
                    u.fire(l.groupAdded, i)
                }
                return d
            };
            v.bind(l.groupAdded, function(a) {
                var b = a.group
                  , c = ka(b, a.eventInfo);
                null != c && u.refresh(!0)
            }),
            v.bind(l.groupRemoved, function(a) {
                var b = a.group;
                u.getLayout().groupRemoved(b.id);
                var c = U[b.id]
                  , d = J.getId(c);
                J.removeGroup(b.id, a.removeChildNodes, !0, !1),
                delete U[b.id],
                delete W[d],
                delete c.jtk,
                u.refresh(!0)
            }),
            this.expandGroup = function(a) {
                J.expandGroup("string " == typeof a ? a : a.id)
            }
            ,
            this.collapseGroup = function(a) {
                J.collapseGroup("string " == typeof a ? a : a.id)
            }
            ,
            this.toggleGroup = function(a) {
                J.toggleGroup("string " == typeof a ? a : a.id)
            }
            ;
            var la = function(a, b) {
                for (var c, d, e = a.getNodes(), f = 0, g = 0, h = u.getLayout(), i = J.getGroup(a.id), j = i.getDragArea(), k = 0; k < e.length; k++)
                    c = h.getPosition(e[k].id),
                    isNaN(c[0]) || isNaN(c[1]) || (d = h.getSize(e[k].id),
                    f = Math.max(f, c[0] + d[0]),
                    g = Math.max(g, c[1] + d[1]));
                f = b.maxSize ? Math.min(b.maxSize[0], f) : f,
                g = b.maxSize ? Math.min(b.maxSize[1], g) : g,
                j.style.width = f + "px",
                j.style.height = g + "px",
                h.setSize(a.id, [f, g])
            }
              , ma = function() {
                for (var a in U) {
                    var b = v.getGroup(a);
                    if (b) {
                        var c = oa.getGroupDefinition(v.getNodeType(b.data));
                        c.autoSize && la(b, c)
                    }
                }
            };
            u.autoSizeGroups = ma;
            var na = function(a, b) {
                return function() {
                    var c = ra(a);
                    c.doNotFireConnectionEvent = !0,
                    b && (c.geometry = b),
                    v.isDebugEnabled() && console.log("Renderer", "adding edge with params", c);
                    var d = J.connect(c);
                    d.edge = a,
                    Z[a.getId()] = d,
                    ba(c.type, a, d),
                    u.fire(l.edgeAdded, {
                        source: a.source,
                        target: a.target,
                        connection: d,
                        edge: a,
                        geometry: b
                    }),
                    u.refresh(!0)
                }
            };
            v.bind(l.edgeAdded, function(b) {
                if (!Q && b.source !== u) {
                    var c = b.edge
                      , d = oa.getEdgeDefinition(v.getEdgeType(c.data || {}));
                    if (d && d.ignore === !0)
                        return;
                    var e = na(c, b.geometry);
                    a.connectionHandler ? a.connectionHandler(c, e) : e()
                }
            }),
            v.bind(l.edgeRemoved, function(a) {
                if (!Q && a.source !== u) {
                    var b = a.edge
                      , c = Z[b.getId()];
                    c && (v.isDebugEnabled() && console.log("Renderer", "removing edge", b),
                    ca(c, b),
                    J.deleteConnection(Z[b.getId()], {
                        fireEvent: !1
                    }),
                    delete Z[b.getId()])
                }
            }),
            v.bind(l.edgeTypeChanged, function(a) {
                if (!Q && a.source !== u) {
                    var b = a.obj
                      , c = Z[b.getId()];
                    if (c) {
                        var d = oa.getEdgeDefinition(a.newType);
                        if (d && d.ignore === !0)
                            return;
                        c.setType(a.newType),
                        d.connector && c.setConnector(d.connector)
                    }
                }
            }),
            v.bind(l.edgeTarget, function(a) {
                if (!Q) {
                    var b = a.edge
                      , c = Z[b.getId()]
                      , d = R[b.target.getFullId()];
                    c ? J.silently(function() {
                        null != d ? (v.isDebugEnabled() && console.log("target change", c),
                        J.setTarget(c, d)) : (delete Z[b.getId()],
                        J.detach({
                            connection: c,
                            forceDetach: !0,
                            fireEvent: !1
                        }))
                    }) : null != d && v.isDebugEnabled() && e.log("Target for Edge " + b.getId() + " changed to Node " + d.id + "; we have no valid connection.")
                }
            }),
            v.bind(l.edgeSource, function(a) {
                if (!Q) {
                    var b = a.edge
                      , c = Z[b.getId()]
                      , d = R[b.source.getFullId()];
                    c ? J.silently(function() {
                        null != d ? J.setSource(c, d) : (delete Z[b.getId()],
                        J.detach({
                            connection: c,
                            forceDetach: !0,
                            fireEvent: !1
                        }))
                    }) : null != d && v.isDebugEnabled() && e.log("Source for Edge " + b.getId() + " changed to Node " + d.id + "; we have no valid connection.")
                }
            }),
            v.bind("graphClearStart", function() {
                for (var a in U)
                    "undefined" != typeof U[a]._rotors && t.remove(U[a]),
                    J.silently(function() {
                        J.getGroupManager().removeGroup(a)
                    }),
                    delete U[a].jtk;
                for (var b in R)
                    "undefined" != typeof R[b]._rotors && t.remove(R[b]),
                    J.remove(R[b], !0),
                    delete R[b].jtk;
                w && w.clear(),
                J.setSuspendEvents(!0),
                J.batch(J.deleteEveryEndpoint, !0),
                J.setSuspendEvents(!1),
                X.length = 0,
                V.length = 0,
                Z = {},
                R = {},
                U = {},
                S = {},
                W = {},
                T = {},
                xa = {}
            }),
            v.bind(l.portAdded, function(a) {
                var b = R[a.node.id] || U[a.node.id]
                  , c = oa.getPortDefinition(v.getPortType(a.data));
                if (c.isEndpoint)
                    m(new Aa(a.data,b,a.port), a.node);
                else {
                    var d = ua(a.port, a.data, a.node);
                    T[a.node.id + v.getGraph().getPortSeparator() + a.port.id] = d,
                    Ba(J.getElement(d), a.node),
                    u.fire(l.portAdded, {
                        node: a.node,
                        nodeEl: b,
                        port: a.port,
                        portEl: d
                    })
                }
                J.recalculateOffsets(b),
                u.refresh(!0)
            }),
            v.bind(l.portRemoved, function(a) {
                var b = R[a.node.id] || U[a.node.id]
                  , c = a.node.id + "." + a.port.id
                  , d = T[c];
                J.setSuspendEvents(!0),
                J.remove(d),
                J.setSuspendEvents(!1),
                delete T[c],
                u.fire(l.portRemoved, {
                    node: a.node,
                    port: a.port,
                    portEl: d,
                    nodeEl: b
                }),
                J.recalculateOffsets(b),
                u.refresh(!0)
            }),
            v.bind(l.edgeUpdated, function(a) {
                var b = Z[a.edge.getId()];
                if (b) {
                    var c = ra(a.edge);
                    b.setType(c.type, c.data)
                }
            }),
            v.bind(l.portUpdated, function(a) {
                var b = T[a.port.getFullId()];
                b && (t.update(b, a.port.data),
                u.repaint(R[a.node.id]))
            }),
            v.bind(l.nodeUpdated, function(a) {
                var b = R[a.node.getFullId()];
                if (b) {
                    t.update(b, a.node.data),
                    Ba(b, a.node);
                    var c = E(a.node);
                    if (null != c) {
                        var d = e.isArray(c) ? c : [c];
                        d.unshift(b),
                        J.setPosse.apply(J, d)
                    } else
                        J.removeFromAllPosses(b);
                    u.repaint(b)
                }
            })
        }
        var oa;
        this.setView = function(a) {
            var b = e.merge(v.getModel(), a || {});
            oa = new c.Model(b,J)
        }
        ,
        this.setView(a.view),
        this.getView = function() {
            return oa
        }
        ;
        var pa = []
          , qa = function(a) {
            return null == a ? v : "string" == typeof a ? v.select(a, !0) : a.jtk ? v.select(a.jtk.port || a.jtk.node, !0) : a
        };
        this.activateState = function(a, b) {
            var c = oa.getState(a);
            c && (b = qa(b),
            c.activate(b, u, v),
            pa.push(c))
        }
        ,
        this.deactivateState = function(a, b) {
            var c = oa.getState(a);
            c && (b = qa(b),
            c.deactivate(b, u, v),
            e.removeWithFunction(pa, function(a) {
                return a == c
            }))
        }
        ,
        this.resetState = function() {
            for (var a = 0; a < pa.length; a++)
                pa[a].deactivate(v, u, v);
            pa.length = 0
        }
        ;
        var ra = function(a) {
            var b = v.getEdgeType(a.data)
              , c = {
                type: b,
                connectionType: b,
                data: a.data,
                cost: a.getCost(),
                directed: a.isDirected()
            }
              , d = oa.getEdgeDefinition(b);
            !function(a) {
                if (d)
                    for (var b = 0; b < a.length; b++)
                        d[a[b]] && (c[a[b]] = d[a[b]])
            }(["connector", "endpoints", "endpoint", "endpointStyles", "endpointStyle"]),
            c.anchor && !c.anchors && (c.anchors = [c.anchor, c.anchor],
            delete c.anchor),
            c.endpoint && !c.endpoints && (c.endpoints = [c.endpoint, c.endpoint],
            delete c.endpoint);
            var e = function(a, b, c, d, e) {
                if (d && d[c]) {
                    var f = a[b] || [d[c], d[c]];
                    f[e] = d[c],
                    a[b] = f
                }
            }
              , f = function(b, d) {
                if (a[b].getNode) {
                    var f = a[b].getNode()
                      , g = a[b].getFullId()
                      , h = xa[g] || T[g];
                    null != h ? c[b] = h : c[b] = T[g],
                    null == c[b] && (c[b] = R[v.getNodeId(f.data)]);
                    var i = oa.getPortDefinition(a[b].getType());
                    e(c, "anchors", "anchor", i, d),
                    e(c, "endpoints", "endpoint", i, d)
                } else {
                    var j = v.getNodeId(a[b].data);
                    c[b] = R[j] || U[j]
                }
            };
            return f("source", 0),
            f("target", 1),
            c
        }
          , sa = function(a, b, c, d, e, g, h, i) {
            return function(j, k, l) {
                var m, n = b(k), o = null, p = c(k), q = oa[d](p), r = k;
                if (D) {
                    r = f.extend({}, q ? q.parameters || {} : {}),
                    f.extend(r, k);
                    var s = {};
                    for (m in r)
                        r.hasOwnProperty(m) && null != r[m] && (r[m].constructor == Function ? s[m] = r[m](k) : s[m] = r[m]);
                    r = s
                }
                if (q) {
                    var t = q.template || "jtk-template-" + p;
                    o = q.templateRenderer ? q.templateRenderer(t, r, v, a) : C.render(t, r, v, a)
                } else
                    o = e(r, n);
                o = J.getElement(o),
                o.setAttribute(i, n),
                f.addClass(o, h),
                o.jtk = o.jtk || {},
                o.jtk[a] = j,
                o.jtk.node = l,
                g && y && Ea.makeDraggable && Ea.makeDraggable(o, q.dragOptions),
                z && Ea.makeDroppable && Ea.makeDroppable(o, q.dropOptions);
                var w = function(a) {
                    J.on(o, a, function(b) {
                        q.events[a]({
                            node: l,
                            el: o,
                            e: b,
                            toolkit: v,
                            renderer: u
                        })
                    })
                };
                if (q && q.events)
                    for (m in q.events)
                        w(m);
                return o
            }
        }
          , ta = sa("node", v.getNodeId, v.getNodeType, "getNodeDefinition", p, !0, j.NODE, h.NODE)
          , ua = sa("port", v.getPortId, v.getPortType, "getPortDefinition", p, !1, j.PORT, h.PORT)
          , va = sa("group", v.getNodeId, v.getNodeType, "getGroupDefinition", p, !1, j.GROUP, h.GROUP);
        this.initialize = function() {
            var b, c, d, e, f;
            if (v.setSuspendGraph(!0),
            J.setSuspendDrawing(!0),
            a.jsPlumbInstance) {
                var g = a.jsPlumbInstance.select();
                g.each(function(a) {
                    Z[a.edge.getId()] = a
                }),
                c = a.jsPlumbInstance.getManagedElements();
                for (var h in c) {
                    var i = c[h].el;
                    R[i.jtk.node.id] = i,
                    S[a.jsPlumbInstance.getId(i)] = i.jtk.node
                }
                Ea.doImport && Ea.doImport(R, Z)
            } else {
                for (b = 0,
                d = v.getGroupCount(); b < d; b++)
                    e = v.getGroupAt(b),
                    ka(e);
                for (b = 0,
                d = v.getNodeCount(); b < d; b++)
                    c = v.getNodeAt(b),
                    ia(c);
                for (b = 0,
                d = v.getNodeCount(); b < d; b++)
                    if (c = v.getNodeAt(b),
                    R[c.id]) {
                        var j = v.getAllEdgesFor(c);
                        for (f = 0; f < j.length; f++)
                            if (j[f].source == c || j[f].source.getNode && j[f].source.getNode() == c) {
                                var k = oa.getEdgeDefinition(v.getNodeType(j[f].data));
                                if (k && k.ignore === !0)
                                    continue;
                                var l = ra(j[f]);
                                l.doNotFireConnectionEvent = !0;
                                var m = J.connect(l);
                                null != m && (m.edge = j[f],
                                Z[j[f].getId()] = m,
                                ba(l.type, j[f], m))
                            }
                    }
            }
            ma(),
            this.relayout(),
            J.setSuspendDrawing(!1, !0),
            v.setSuspendGraph(!1)
        }
        ,
        this.getContainer = function() {
            return x
        }
        ,
        this.getContainerId = function() {
            return K
        }
        ,
        this.getRenderedElement = function(a) {
            if (null == a)
                return null;
            var b = a.getFullId();
            return "Port" === a.objectType ? T[b] : "Group" === a.objectType ? U[b] : R[b]
        }
        ,
        this.getRenderedNode = function(a) {
            return R[a]
        }
        ,
        this.getRenderedGroup = function(a) {
            return U[a]
        }
        ,
        this.getRenderedPort = function(a) {
            return T[a]
        }
        ,
        this.getRenderedConnection = function(a) {
            return Z[a]
        }
        ,
        this.getRenderedEndpoint = function(a) {
            var b = Da(a)
              , c = null;
            return b && b.obj && "Port" === b.obj.objectType && J.selectEndpoints({
                element: b.el
            }).each(function(a) {
                a.graph && a.graph.port && a.graph.port === b.obj && (c = a)
            }),
            c
        }
        ;
        var wa = function(a) {
            var b = J.extend({
                container: x,
                getElementForNode: function(a) {
                    return R[a] || U[a]
                }
            }, a);
            if (b.jsPlumbToolkit = v,
            b.adapter = u,
            !c.Layouts[b.type])
                throw "no such layout [" + b.type + "]";
            return b.locationFunction || (b.locationFunction = function(a) {
                return [g.data(a.data, F), g.data(a.data, G)]
            }
            ),
            new c.Layouts[b.type](b)
        };
        this.adHocLayout = function(a) {
            if (a) {
                var b = w;
                this.setLayout(a),
                w = b
            }
        }
        ,
        this.setLayout = function(a, b) {
            if (a) {
                var c = f.extend({
                    jsPlumb: this.getJsPlumb()
                }, a);
                w = wa(c),
                b || u.refresh()
            }
        }
        ,
        this.getLayout = function() {
            return w
        }
        ,
        this.getMagnetizedElements = function() {
            return null != w ? w.getMagnetizedElements() : []
        }
        ,
        this.magnetize = function(a) {
            null != w && w.magnetize(a)
        }
        ,
        this.refresh = function(a) {
            A || a && !B || (w ? w.layout(function() {
                "undefined" != typeof window ? window.setTimeout(J.repaintEverything, 0) : J.repaintEverything()
            }) : J.repaintEverything())
        }
        ,
        this.setRefreshAutomatically = function(a) {
            B = a
        }
        ,
        this.relayout = function(a) {
            A || (w ? w.relayout(a, function() {
                J.repaintEverything(),
                this.fire("relayout", this.getBoundsInfo())
            }
            .bind(this)) : J.repaintEverything())
        }
        ,
        this.getPath = function(a) {
            var b = v.getPath(a);
            return b && (b.setVisible = function(a) {
                u.setVisible(b, a)
            }
            ,
            b.addNodeClass = function(a) {
                b.eachNode(function(b, c) {
                    J.addClass(R[c.id], a)
                })
            }
            ,
            b.removeNodeClass = function(a) {
                b.eachNode(function(b, c) {
                    J.removeClass(R[c.id], a)
                })
            }
            ,
            b.addEdgeClass = function(a) {
                b.eachEdge(function(b, c) {
                    Z[c.getId()].addClass(a)
                })
            }
            ,
            b.removeEdgeClass = function(a) {
                b.eachEdge(function(b, c) {
                    Z[c.getId()].removeClass(a)
                })
            }
            ,
            b.addClass = function(a) {
                this.addNodeClass(a),
                this.addEdgeClass(a)
            }
            ,
            b.removeClass = function(a) {
                this.removeNodeClass(a),
                this.removeEdgeClass(a)
            }
            ),
            b
        }
        ,
        this.getPosition = function(a) {
            var b = this.getLayout();
            if (b) {
                var c = Da(a).id;
                return b.getPosition(c)
            }
        }
        ,
        this.getSize = function(a) {
            return J.getSize(Da(a).el)
        }
        ,
        this.getCoordinates = function(a) {
            var b = this.getLayout();
            if (b) {
                var c = Da(a)
                  , d = b.getPosition(c.id)
                  , e = J.getSize(c.el);
                return {
                    x: d[0],
                    y: d[1],
                    w: e[0],
                    h: e[1]
                }
            }
        }
        ;
        var xa = {}
          , ya = function(a, b, c) {
            var g = a.value("port-id")
              , h = a.value("port-type") || "default"
              , i = a.value("scope") || J.getDefaultScope()
              , j = v.getNodeType(b)
              , k = oa.getNodeDefinition(j)
              , l = oa.getPortDefinition(g, k)
              , m = oa.getPortDefinition(h, k)
              , n = e.merge(m, l)
              , o = null == n ? {} : d.populate(n, b.data)
              , p = function(a) {
                return function(c) {
                    var d = b.getPort(g)
                      , e = [{
                        portId: g,
                        nodeId: b.id,
                        port: d,
                        node: b,
                        portType: h,
                        endpoint: c.endpoint,
                        anchor: c.anchor
                    }];
                    a.apply(a, e)
                }
            }
              , q = function(a) {
                return function(b) {
                    var c = [{
                        connection: b.connection || b,
                        source: Da(b.source),
                        target: Da(b.target),
                        scope: b.scope
                    }];
                    return a.apply(a, c)
                }
            }
              , r = o.edgeType || a.value("edge-type") || "default"
              , s = {
                paintStyle: "connectorStyle",
                hoverPaintStyle: "connectorHoverStyle",
                overlays: "connectorOverlays",
                endpointStyle: "paintStyle"
            }
              , t = oa.getEdgeDefinition(r);
            if (t)
                for (var w in t) {
                    var x = s[w] || w;
                    null == o[x] && (o[x] = t[w])
                }
            if (o.connectionType = r,
            o.portId = g,
            o.portType = h,
            o.scope = i,
            o.parameters = o.parameters || {},
            o.parameters.portId = g,
            o.parameters.portType = h,
            o.parameters.edgeType = r,
            o.parameters.scope = i,
            o.parameters.nodeId = b.id,
            o.events = {},
            n.events)
                for (w in n.events)
                    o.events[w] = p(n.events[w]);
            if (n.interceptors)
                for (w in n.interceptors)
                    o[w] = q(n.interceptors[w]);
            var y = a.value("anchor-x")
              , z = a.value("anchor-y")
              , A = a.value("orientation-x")
              , B = a.value("orientation-y")
              , C = a.value("offset-x")
              , D = a.value("offset-y");
            return null != y && null != z && (o.anchor = [parseFloat(y), parseFloat(z), parseInt(A || "0", 10), parseInt(B || "0", 10), parseFloat(C || "0"), parseFloat(D || "0")]),
            f.extend(o, c || {}),
            o.events.anchorChanged = function(a) {
                u.fire("anchorChanged", {
                    portId: g,
                    nodeId: b.id,
                    portType: h,
                    node: b,
                    port: b.getPort(g),
                    endpoint: a.endpoint,
                    anchor: a.anchor
                })
            }
            ,
            o
        }
          , za = function(a) {
            this.element = a.parentNode,
            this.value = function(b, c) {
                var d = a.getAttribute(b);
                return null == d ? c : d
            }
            ,
            this.setValue = function(b, c) {
                a.setAttribute(b, c)
            }
            ,
            this.findDataValues = function(b) {
                for (var c = 0; c < a.attributes.length; c++) {
                    var d = a.attributes[c];
                    0 === d.name.indexOf("data-") && (b[d.value] = d.name.split("-")[1])
                }
            }
        }
          , Aa = function(a, b, c) {
            this.element = b,
            this.port = c,
            this.value = function(b, c) {
                var d = a[b.replace(/(\-\w)/g, function(a) {
                    return a[1].toUpperCase()
                })];
                return null == d ? c : d
            }
            ,
            this.findDataValues = function(b) {
                for (var c in a)
                    0 === c.indexOf("data-") && (b[a[c]] = c.split("-")[1])
            }
            ,
            this.setValue = function(a, c) {
                b.setAttribute(a, c)
            }
        }
          , Ba = function(a, b) {
            var c, d, e = f.getSelector(a, i.PORT), g = f.getSelector(a, i.SOURCE), h = f.getSelector(a, i.TARGET);
            for (c = 0; c < g.length; c++)
                d = new za(g[c]),
                n(d, b);
            for (c = 0; c < h.length; c++)
                d = new za(h[c]),
                o(d, b);
            for (c = 0; c < e.length; c++)
                d = new za(e[c]),
                m(d, b)
        };
        this.setLayout(a.layout, !0),
        this.storePositionsInModel = function(a) {
            a = a || {};
            var b = a.leftAttribute || "left"
              , c = a.topAttribute || "top"
              , d = w.getPositions();
            for (var e in d) {
                var f = v.getNode(e) || v.getGroup(e);
                f && (g.data(f.data, b, d[e][0]),
                g.data(f.data, c, d[e][1]))
            }
        }
        ,
        this.storePositionInModel = function(a) {
            var b = "string" == typeof a ? a : a.id
              , c = "string" == typeof a ? "left" : a.leftAttribute || "left"
              , d = "string" == typeof a ? "top" : a.topAttribute || "top"
              , e = w.getPosition(b)
              , f = v[a.group ? "getGroup" : "getNode"](b);
            return f && (g.data(f.data, c, e[0]),
            g.data(f.data, d, e[1])),
            e
        }
        ;
        var Ca = function(a, b, c, d, e, f, g) {
            return a = a || Da(b),
            a && (w.setPosition(a.id, c, d),
            e || (J.setAbsolutePosition(a.el, [c, d], f, g),
            J.revalidate(a.el))),
            a
        };
        this.setPosition = function(a, b, c, d) {
            return Ca(null, a, b, c, d)
        }
        ,
        this.animateToPosition = function(a, b, c, d) {
            var e = Da(a);
            if (e) {
                var f = w.getPosition(e.id);
                Ca(e, a, b, c, !1, [f[0], f[1]], d)
            }
        }
        ,
        this.setVisible = function(a, b, c) {
            function d(a) {
                return a.endpoints[0].element._jtkVisible !== !1 && a.endpoints[1].element._jtkVisible !== !1
            }
            function e(a, b, c) {
                if (1 === b.connections.length)
                    b.setVisible(c, !0);
                else if (c)
                    b.setVisible(!0, !0);
                else {
                    for (var d = 0; d < b.connections.length; d++)
                        if (b.connections[d] !== a && b.connections[d].isVisible())
                            return;
                    b.setVisible(!1, !0)
                }
            }
            if (null != a) {
                var f = function(a) {
                    var f = $(a);
                    if (f) {
                        var g = !b || d(f);
                        g && (f.setVisible(b),
                        c || (e(f, f.endpoints[0], b),
                        e(f, f.endpoints[1], b)))
                    }
                }
                  , g = function(a, d) {
                    if (d && (d.style.display = b ? "block" : "none",
                    d._jtkVisible = b,
                    !c))
                        for (var e = v.getAllEdgesFor(a), g = 0; g < e.length; g++)
                            f(e[g])
                }
                  , h = function(a) {
                    var c = a.getFullId()
                      , d = xa[c];
                    d.setVisible(b)
                }
                  , i = function(a) {
                    var b = Da(a);
                    switch (b.type) {
                    case "Edge":
                        f(b.obj);
                        break;
                    case "Node":
                        g(b.obj, b.el);
                        break;
                    case "Port":
                        h(b.obj)
                    }
                };
                if (a.eachNode && a.eachEdge)
                    a.eachNode(function(a, b) {
                        i(b)
                    }),
                    a.eachEdge(function(a, b) {
                        i(b)
                    });
                else if (a.length && "string" != typeof a)
                    for (var j = 0; j < a.length; j++)
                        i(a[j]);
                else
                    i(a)
            }
        }
        ;
        var Da = function(a) {
            return a instanceof J.getDefaultConnectionType() && (a = a.edge),
            v.getObjectInfo(a, function(a) {
                return a.getNode ? T[a.getFullId()] || R[a.getNode().id] : R[a.id] || U[a.id]
            })
        };
        this.addToPosse = function(a, b, c) {
            d.each(a, function(a) {
                var d = Da(a);
                d.el && J.addToPosse(d.el, {
                    id: b,
                    active: c !== !1
                })
            })
        }
        ,
        this.setPosse = function(a, b) {
            d.each(a, function(a) {
                var c = Da(a);
                c.el && J.setPosse(c.el, b)
            })
        }
        ,
        this.removeFromPosse = function(a, b) {
            d.each(a, function(a) {
                var c = Da(a);
                c.el && J.removeFromPosse(c.el, b)
            })
        }
        ,
        this.removeFromAllPosses = function(a) {
            d.each(a, function(a) {
                var b = Da(a);
                b.el && J.removeFromAllPosses(b.el)
            })
        }
        ,
        this.setPosseState = function(a, b, c) {
            d.each(a, function(a) {
                var d = Da(a);
                d.el && J.setPosseState(d.el, b, c)
            })
        }
        ;
        var Ea = {
            jsPlumb: J,
            toolkit: v,
            container: x,
            containerId: K,
            getConnectionsForEdges: _,
            getConnectionForEdge: $,
            getElement: function(a) {
                return R[a] || U[a]
            },
            getNodeForElementId: function(a) {
                return S[a]
            },
            getGroupForElementId: function(a) {
                return W[a]
            },
            getObjectInfo: Da,
            nodeMap: function() {
                return R
            },
            portMap: function() {
                return T
            },
            groupMap: function() {
                return U
            },
            reverseNodeMap: function() {
                return S
            }
        };
        return Ea
    }
    ;
    b.DOM = function(a) {
        n.apply(this, arguments),
        m.apply(this, arguments)
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = {
        webkit: {
            mac: function(a) {
                return a.deltaY / 120
            },
            win: function(a) {
                return a.deltaY / 100
            }
        },
        safari: function(a) {
            return a.wheelDeltaY / 120
        },
        firefox: {
            mac: function(a) {
                return -1 * (a.deltaY * (1 == a.deltaMode ? 25 : 1)) / 120
            },
            win: function(a) {
                return -1 * a.deltaY / 3
            }
        },
        ie: function(a) {
            return a.wheelDelta / 120
        },
        default: function(a) {
            return a.deltaY || a.wheelDelta;
        }
    }
      , c = /Mac/.test(navigator.userAgent) ? "mac" : "win"
      , d = navigator.userAgent.indexOf("Firefox") != -1 ? "firefox" : /Chrome/.test(navigator.userAgent) ? "webkit" : /Safari/.test(navigator.userAgent) ? "safari" : /WebKit/.test(navigator.userAgent) ? "webkit" : /Trident/.test(navigator.userAgent) ? "ie" : "default"
      , e = "function" == typeof b[d] ? b[d] : b[d][c]
      , f = function(a) {
        return e(a || event)
    }
      , g = function(a, b, c) {
        return function(d) {
            b && null != d.mozInputSource && 1 !== d.mozInputSource || (d.normalizedWheelDelta = f(d),
            (!c || d.metaKey || d.ctrlKey) && a(d))
        }
    }
      , h = "onwheel"in document.createElement("div") ? "wheel" : void 0 !== document.onmousewheel ? "mousewheel" : "DOMMouseScroll";
    a.addWheelListener = function(a, b, c, d) {
        var e = g(b, c, d);
        a.addEventListener ? a.addEventListener(h, e, !1) : a.attachEvent && a.attachEvent("onmousewheel", e)
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    var a = this;
    a.PinchListener = function(a) {
        var b = "onpointerdown"in document.documentElement
          , c = "ontouchstart"in document.documentElement
          , d = [0, 0]
          , e = 0
          , f = 0
          , g = function(b) {
            a[b](d, f, e, e / f)
        }
          , h = function() {
            a.onPinchEnd()
        }
          , i = "onPinchStart"
          , j = "onPinch"
          , k = "pointerdown"
          , l = "pointermove"
          , m = "pointerup"
          , n = "touchstart"
          , o = "touchmove"
          , p = "touchend"
          , q = function(a, b, c, d) {
            return Math.sqrt(Math.pow(c - a, 2) + Math.pow(d - b, 2))
        }
          , r = {
            pointer: function() {
                var b = {}
                  , c = []
                  , n = 0
                  , o = !1
                  , p = function() {
                    2 == n && (d = [(c[1].p[0] + c[0].p[0]) / 2, (c[1].p[1] + c[0].p[1]) / 2],
                    e = q(c[1].p[0], c[1].p[1], c[0].p[0], c[0].p[1]))
                }
                  , r = function(a) {
                    n >= 2 || o || (c[n] = {
                        e: a,
                        p: [a.pageX, a.pageY]
                    },
                    b["" + a.pointerId] = n,
                    n++,
                    p(),
                    2 == n && (f = e,
                    g(i)))
                }
                  , s = function(a) {
                    var c = b["" + a.pointerId];
                    null != c && (delete b["" + a.pointerId],
                    n--,
                    o = 0 !== n,
                    h())
                }
                  , t = function(a) {
                    if (!o && 2 == n) {
                        var d = b[a.pointerId];
                        null != d && (c[d].p = [a.pageX, a.pageY],
                        p(),
                        g(j))
                    }
                };
                a.bind(a.el, k, r),
                a.bind(document, m, s),
                a.bind(document, l, t)
            },
            touch: function(a) {
                var b = function(a) {
                    return a.touches || []
                }
                  , c = function(a, b) {
                    return a.item ? a.item(b) : a[b]
                }
                  , k = function(a) {
                    var b = c(a, 0)
                      , d = c(a, 1);
                    return q(b.pageX, b.pageY, d.pageX, d.pageY)
                }
                  , l = function(a) {
                    var b = c(a, 0)
                      , d = c(a, 1);
                    return [(b.pageX + d.pageX) / 2, (b.pageY + d.pageY) / 2]
                }
                  , m = !1
                  , r = function(c) {
                    var h = b(c);
                    2 == h.length && a.enableWheelZoom !== !1 && (d = l(h),
                    e = f = k(h),
                    m = !0,
                    a.bind(document, o, t),
                    a.bind(document, p, s),
                    g(i))
                }
                  , s = function(b) {
                    m = !1,
                    a.unbind(document, o, t),
                    a.unbind(document, p, s),
                    h()
                }
                  , t = function(a) {
                    if (m) {
                        var c = b(a);
                        2 == c.length && (e = k(c),
                        d = l(c),
                        g(j))
                    }
                };
                a.bind(a.el, n, r)
            }
        };
        b ? r.pointer(a) : c && r.touch(a)
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumb;
    this.ZoomWidget = function(a) {
        function d(b, c) {
            if (g())
                return {
                    w: 0,
                    h: 0,
                    x: 0,
                    y: 0,
                    vw: a.width(u),
                    vh: a.height(u),
                    padding: b,
                    z: 1,
                    zoom: 1
                };
            b = b || 0,
            c = c || .9;
            var d = Math.abs(ma.maxx[0][0][0] + ma.maxx[0][1] - ma.minx[0][0][0])
              , e = Math.abs(ma.maxy[0][0][1] + ma.maxy[0][2] - ma.miny[0][0][1])
              , f = a.width(u)
              , h = a.height(u)
              , i = f / ((d + 2 * b) / c)
              , j = h / ((e + 2 * b) / c)
              , k = Math.min(i, j);
            return {
                w: d,
                h: e,
                x: ma.minx[0][0][0],
                y: ma.miny[0][0][1],
                vw: f,
                vh: h,
                padding: b,
                z: k,
                zoom: ca
            }
        }
        function g() {
            for (var a in na)
                return !1;
            return !0
        }
        function h(a) {
            for (var b in ma)
                if (ma.hasOwnProperty(b)) {
                    for (var c = -1, d = 0; d < ma[b].length; d++)
                        if (ma[b][d][3] === a) {
                            c = d;
                            break
                        }
                    c != -1 && ma[b].splice(c, 1)
                }
        }
        a.events = a.events || {};
        var i, j, k, l, m, n, o = this, p = function() {}, q = a.canvas, r = a.domElement || function(a) {
            return a
        }
        , s = r(q), t = a.viewport, u = r(t), v = a.events.zoom || p, w = (a.events.maybeZoom || function() {
            return !0
        }
        ,
        a.events.pan || p), x = a.events.mousedown || p, y = a.events.mouseup || p, z = a.events.mousemove || p, A = a.events.transformOrigin || p, B = !(a.clamp === !1), C = a.clampZoom !== !1, D = a.panDistance || 50, E = a.enablePan !== !1, F = a.enableWheelZoom !== !1, G = a.enableAnimation !== !1, H = a.wheelFilter || function() {
            return !0
        }
        , I = a.wheelZoomMetaKey === !0, J = a.wheelReverse === !0 ? -1 : 1, K = J * (a.wheelSensitivity || 10), L = a.enablePanButtons !== !1, M = a.padding || [0, 0], N = a.consumeRightClick !== !1, O = a.smartMinimumZoom, P = !1, Q = "mousedown", R = "mouseup", S = "mousemove", T = ["webkit", "Moz", "ms"], U = a.bind, V = a.unbind, W = !(a.enabled === !1), X = a.clampToBackground, Y = a.clampToBackgroundExtents, Z = a.filter || function(a) {
            return !1
        }
        , $ = a.width, _ = a.height, aa = 0, ba = 0, ca = a.zoom || 1, da = [0, 0], ea = !1, fa = !1, ga = !1, ha = !1, ia = a.zoomRange || [.05, 3], ja = 150, ka = -1, la = -1, ma = {
            minx: [],
            maxx: [],
            miny: [],
            maxy: []
        }, na = {}, oa = {}, pa = {}, qa = !1, ra = function() {
            ma.minx.sort(function(a, b) {
                return a[0][0] < b[0][0] ? -1 : 1
            }),
            ma.miny.sort(function(a, b) {
                return a[0][1] < b[0][1] ? -1 : 1
            }),
            ma.maxx.sort(function(a, b) {
                return a[0][0] + a[1] > b[0][0] + b[1] ? -1 : 1
            }),
            ma.maxy.sort(function(a, b) {
                return a[0][1] + a[2] > b[0][1] + b[2] ? -1 : 1
            })
        }, sa = function(a, b, c, d) {
            null == na[a] && (na[a] = [],
            ma.minx.push(na[a]),
            ma.miny.push(na[a]),
            ma.maxx.push(na[a]),
            ma.maxy.push(na[a])),
            na[a][0] = b,
            na[a][1] = c,
            na[a][2] = d,
            na[a][3] = a,
            P ? qa = !0 : ra()
        };
        this.setBoundsFor = sa,
        this.setSuspendRendering = function(a) {
            P = a,
            !a && qa && ra(),
            qa = !1
        }
        ;
        var ta = function(a, b) {
            return function(c) {
                Ua(s, a * D, b * D, null, !0, function(a) {
                    w(a[0], a[1], ca, ca, c),
                    i && i.pan(),
                    db.pan()
                })
            }
        }
          , ua = 150
          , va = 60
          , wa = 10
          , xa = null
          , ya = null
          , za = null
          , Aa = function(b, c, d) {
            return function() {
                za = d,
                a.addClass(za, "jtk-surface-pan-active"),
                a.bind(document, "mouseup", Ba),
                xa = window.setTimeout(function() {
                    a.bind(document, R, Da),
                    ya = window.setInterval(Ca(b, c), va)
                }, ua)
            }
        }
          , Ba = function() {
            window.clearTimeout(xa),
            za && a.removeClass(za, "jtk-surface-pan-active"),
            za = null
        }
          , Ca = function(a, b) {
            return function(c) {
                var d = Ua(s, a * wa, b * wa, null);
                w(d[0], d[1], ca, ca, c),
                i && i.pan(),
                db.pan()
            }
        }
          , Da = function() {
            window.clearTimeout(ya)
        }
          , Ea = function(b, c, d, e, f) {
            var g = document.createElement("div");
            g.innerHTML = f || "",
            g.style.position = "absolute";
            for (var h in c)
                g.style[h] = c[h];
            return g.className = "jtk-surface-pan jtk-surface-pan-" + b,
            u.appendChild(g),
            a.bind(g, "click", ta(d, e)),
            a.bind(g, "mousedown", Aa(d, e, g)),
            g
        };
        L && (Ea("top", {
            left: "0px",
            top: "0px"
        }, 0, -1, "&#8593;"),
        Ea("bottom", {
            left: "0px",
            bottom: "0px"
        }, 0, 1, "&#8595;"),
        Ea("left", {
            left: "0px",
            top: "0px"
        }, -1, 0, "&#8592;"),
        Ea("right", {
            right: "0px",
            top: "0px"
        }, 1, 0, "&#8594;"));
        var Fa = function(a, b, c) {
            c = c || s;
            for (var d = 0; d < T.length; d++) {
                var e = a.replace(/([a-z]){1}/, function(a) {
                    return T[d] + a.toUpperCase()
                });
                c.style[e] = b
            }
            c.style[a] = b
        }
          , Ga = function(a) {
            Fa("transformOrigin", da[0] + "% " + da[1] + "%", a)
        }
          , Ha = function(b, c) {
            var d = Va()
              , e = a.offset(u, !0)
              , f = Ta(s)
              , g = a.width(q)
              , h = a.height(q)
              , i = [(b - (e.left + f[0]) - d[0]) / ca, (c - (e.top + f[1]) - d[1]) / ca];
            return {
                w: g,
                h: h,
                xy: i,
                xScale: i[0] / g,
                yScale: i[1] / h,
                o: [i[0] / g * 100, i[1] / h * 100]
            }
        }
          , Ia = function(a, b, c, d) {
            var e, f, g, h, i = da[0] / 100 * b, j = da[1] / 100 * c;
            e = -(i * (1 - ca)),
            f = -(j * (1 - ca)),
            da = a,
            Ga(),
            i = da[0] / 100 * b,
            j = da[1] / 100 * c,
            g = -(i * (1 - ca)),
            h = -(j * (1 - ca));
            var k = Ua(s, g - e, h - f, d);
            A && A(da, k)
        }
          , Ja = function(a, b, c) {
            var d = Ha(a, b);
            Ia(d.o, d.w, d.h, c)
        }
          , Ka = function(a) {
            var b = Ma(a);
            Ja(b[0], b[1], a)
        }
          , La = function(b, c) {
            var d = a.width(q)
              , e = a.height(q);
            Ia([b / d * 100, c / e * 100], d, e)
        }
          , Ma = this.pageLocation = function(a) {
            if (null != a.pageX)
                return [a.pageX, a.pageY];
            var b = Na(Oa(a), 0);
            return b ? [b.pageX, b.pageY] : [0, 0]
        }
          , Na = function(a, b) {
            return a.item ? a.item(b) : a[b]
        }
          , Oa = function(a) {
            return a.touches || []
        }
          , Pa = function(a, b, c, e, f) {
            if (!(null == a || isNaN(a) || a < 0)) {
                var g = ia[0];
                if (O) {
                    g = .5;
                    var h = d().z
                      , j = a / h;
                    j < g && (a = h * g)
                } else
                    a < g && (a = g);
                if (a > ia[1] && (a = ia[1]),
                e) {
                    var k = a > ca ? .05 : -.05
                      , l = ca
                      , m = a < ca
                      , n = window.setInterval(function() {
                        l = Pa(l + k),
                        m && l <= a && window.clearInterval(n),
                        !m && l >= a && window.clearInterval(n)
                    });
                    return ca
                }
                Fa("transform", "scale(" + a + ")");
                var o = ca;
                if (ca = a,
                f || v(aa, ba, ca, o, b, c),
                null != i && i.setZoom(a),
                db && db.pan(),
                C) {
                    var p = Ta(s)
                      , q = Sa(p[0], p[1]);
                    q[0] == p[0] && q[1] == p[1] || Ta(s, q[0], q[1], null, !e)
                }
                return ca
            }
        }
          , Qa = function(a, b, c, d) {
            b < -ja && (b = -ja),
            b > ja && (b = ja),
            Ra(k, b, -ja, ja, c, d)
        }
          , Ra = function(a, b, c, d, e, f) {
            var g = b / (b >= 0 ? d : c)
              , h = b >= 0 ? 1 : 0
              , i = a + g * (ia[h] - a);
            Pa(i, e, f)
        }
          , Sa = function(b, c, e) {
            if (B || X || Y) {
                var f = Va()
                  , g = b
                  , h = c
                  , j = B ? d() : {
                    x: 0,
                    y: 0,
                    w: 0,
                    h: 0,
                    vw: a.width(u),
                    vh: a.height(u),
                    padding: e,
                    z: 1
                };
                if (e = (e || 20) * ca,
                (X || Y) && null != i) {
                    var k = i.getWidth()
                      , l = i.getHeight()
                      , m = Math.max(j.x + j.w, k)
                      , n = Math.max(j.y + j.h, l);
                    j.w = m - j.w,
                    j.h = n - j.h;
                    var o = j.vw / j.w
                      , p = j.vh / j.h;
                    j.z = Math.min(o, p),
                    Y && (e = Math.max(j.vw, j.vh))
                }
                var q = [j.x + j.w, j.y + j.h];
                i && (q[0] = Math.max(q[0], i.getWidth()),
                q[1] = Math.max(q[1], i.getHeight()));
                var r = b + f[0] + q[0] * ca - e
                  , s = c + f[1] + q[1] * ca - e
                  , t = b + f[0] + j.x * ca + e
                  , v = c + f[1] + j.y * ca + e;
                return r < 0 && (g -= r),
                t > j.vw && (g -= t - j.vw),
                s < 0 && (h -= s),
                v > j.vh && (h -= v - j.vh),
                [g, h]
            }
            return [b, c]
        }
          , Ta = function(b, c, d, e, f, g, h) {
            if (1 == arguments.length)
                return [parseInt(b.style.left, 10) || 0, parseInt(b.style.top, 10) || 0];
            var i = Sa(c, d);
            return G && !f && a.animate ? a.animate(b, {
                left: i[0],
                top: i[1]
            }, {
                step: h,
                complete: function() {
                    g && g(i)
                }
            }) : (b.style.left = i[0] + "px",
            b.style.top = i[1] + "px",
            g && g(i)),
            i
        };
        s.style.left = "0px",
        s.style.top = "0px";
        var Ua = function(a, b, c, d, e, f) {
            var g = Ta(a);
            return Ta(a, g[0] + b, g[1] + c, d, !e, f)
        }
          , Va = function() {
            var b = a.width(q)
              , c = a.height(q)
              , d = da[0] / 100 * b
              , e = da[1] / 100 * c;
            return [d * (1 - ca), e * (1 - ca)]
        }
          , Wa = {
            start: function(b, c) {
                if (!fa) {
                    var d = b.srcElement || b.target;
                    W && (d == s || d == u || d._jtkDecoration || i && i.owns(d) || Z(d, b) === !0) && (ha = !1,
                    ka = -1,
                    la = -1,
                    3 !== b.which || a.enableWheelZoom === !1 || null != b.mozInputSource && 1 !== b.mozInputSource ? c.length <= 1 && (ea = !0,
                    j = Ma(b),
                    n = Ta(s)) : (ga = !0,
                    j = Ma(b),
                    Ka(b),
                    n = Ta(s),
                    k = ca)),
                    x(b, o)
                }
            },
            move: function(a, b) {
                var c, d, e;
                if (ha = !1,
                !fa) {
                    if (ga)
                        e = Ma(a),
                        c = e[0] - j[0],
                        d = e[1] - j[1],
                        Qa(c, d, a);
                    else if (ea && E && null != j) {
                        e = Ma(a),
                        c = e[0] - j[0],
                        d = e[1] - j[1];
                        var f = Ta(s, n[0] + c, n[1] + d, a, !0);
                        w(f[0], f[1], ca, ca, a),
                        i && i.pan(),
                        db && db.pan()
                    }
                    z(a, o)
                }
            },
            end: function(a, b) {
                fa || (ga = !1,
                j = null,
                ea = !1,
                ha = !1,
                V(document, S, Ya),
                V(document, R, Za),
                U(document, S, $a),
                y(a, o))
            },
            contextmenu: function(a) {}
        }
          , Xa = function(a, b) {
            "contextmenu" == a && N && b.preventDefault && b.preventDefault();
            var c = Oa(b);
            Wa[a](b, c)
        }
          , Ya = function(a) {
            Xa("move", a)
        }
          , Za = function(a) {
            Xa("end", a)
        }
          , $a = function(a) {
            ha = !1
        };
        U(document, S, $a);
        var _a = this.start = function(a) {
            W && null != a && (V(document, S, $a),
            U(document, S, Ya),
            U(document, R, Za),
            Wa.start(a, Oa(a)))
        }
        ;
        if (U(t, Q, _a),
        U(t, "contextmenu", function(a) {
            Xa("contextmenu", a)
        }),
        F) {
            var ab = function(a) {
                H(a) && (a.preventDefault && a.preventDefault(),
                a.stopPropagation && a.stopPropagation(),
                k = ca,
                ha || (Ka(a),
                ha = !0),
                Qa(0, a.normalizedWheelDelta * K, a, !0))
            };
            addWheelListener(u, ab, !0, I)
        }
        new PinchListener({
            el: t,
            bind: U,
            unbind: V,
            enableWheelZoom: a.enableWheelZoom,
            onPinch: function(a, b, c, d) {
                Pa(d * k);
                var e = a[0] - j[0]
                  , f = a[1] - j[1];
                Ta(s, n[0] + e, n[1] + f, null, !0)
            },
            onPinchStart: function(a, b) {
                fa = !0,
                j = a,
                l = m = b,
                k = ca,
                Ja(j[0], j[1]),
                n = Ta(s)
            },
            onPinchEnd: function() {
                fa = !1,
                j = null
            }
        }),
        Pa(ca, null, !1, !1, !0),
        Ga(),
        this.positionChanged = function(b, c, d) {
            d = d || a.id(b);
            var e = c || Ta(b)
              , f = a.width(b)
              , g = a.height(b);
            oa[d] = b,
            sa(d, e, f, g)
        }
        ,
        this.add = function(a, b, c, d) {
            this.positionChanged(a, c, b),
            d && (U(a, Q, _a),
            a._jtkDecoration = !0)
        }
        ,
        this.suspend = function(b) {
            var c = "string" == typeof b ? b : a.id(b);
            pa[c] = !0,
            h(c)
        }
        ,
        this.isSuspended = function(b) {
            var c = "string" == typeof b ? b : a.id(b);
            return pa[c] === !0
        }
        ,
        this.restore = function(b) {
            var c = "string" == typeof b ? b : a.id(b);
            delete pa[c],
            this.positionChanged(b, null, c)
        }
        ,
        this.remove = function(b) {
            b = r(b);
            var c = a.id(b);
            delete na[c],
            delete oa[c],
            delete pa[c],
            h(c)
        }
        ,
        this.reset = function() {
            ma.minx.length = 0,
            ma.miny.length = 0,
            ma.maxx.length = 0,
            ma.maxy.length = 0,
            na = {},
            oa = {},
            pa = {},
            Ta(s, 0, 0, null, !0)
        }
        ,
        this.getBoundsInfo = d,
        this.zoomToFit = function(a) {
            a = a || {};
            var b = d(a.padding, a.fill);
            a.doNotZoomIfVisible && b.z > ca || Pa(b.z),
            o.centerContent({
                bounds: b,
                doNotAnimate: a.doNotAnimate !== !1,
                onComplete: a.onComplete,
                onStep: a.onStep,
                doNotFirePanEvent: a.doNotFirePanEvent
            })
        }
        ,
        this.zoomToFitIfNecessary = function(a) {
            var c = b.extend(a || {});
            c.doNotZoomIfVisible = !0,
            this.zoomToFit(c)
        }
        ,
        this.zoomToElements = function(b) {
            for (var c = {
                x: 1 / 0,
                y: 1 / 0,
                xMax: -(1 / 0),
                yMax: -(1 / 0),
                z: 1,
                vw: a.width(u),
                vh: a.height(u)
            }, d = 0; d < b.elements.length; d++) {
                var e = b.elements[d]
                  , f = a.offset(e)
                  , g = a.width(e)
                  , h = a.height(e);
                c.x = Math.min(c.x, f.left),
                c.y = Math.min(c.y, f.top),
                c.xMax = Math.max(c.xMax, f.left + g),
                c.yMax = Math.max(c.yMax, f.top + h)
            }
            var i = a.fill || .9;
            c.w = i * (c.xMax - c.x),
            c.h = i * (c.yMax - c.y),
            c.z = Math.min(c.vw / c.w, c.vh / c.h),
            b.doNotZoomIfVisible && c.z > ca || Pa(c.z),
            o.centerContent({
                bounds: c,
                doNotAnimate: b.doNotAnimate !== !1,
                onComplete: b.onComplete,
                onStep: b.onStep,
                doNotFirePanEvent: b.doNotFirePanEvent
            })
        }
        ,
        this.zoomToBackground = function(a) {
            if (a = a || {},
            null != i) {
                var b = i.getWidth()
                  , c = i.getHeight()
                  , d = $(u)
                  , e = _(u)
                  , f = d / b
                  , g = e / c
                  , h = Math.min(f, g)
                  , j = {
                    w: b,
                    h: c,
                    x: 0,
                    y: 0,
                    vw: d,
                    vh: e,
                    padding: 0,
                    z: h
                };
                Pa(j.z),
                o.centerContent({
                    bounds: j,
                    doNotAnimate: a.doNotAnimate,
                    onComplete: a.onComplete,
                    onStep: a.onStep
                })
            }
        }
        ,
        this.setFilter = function(a) {
            Z = a || function(a) {
                return !1
            }
        }
        ,
        this.centerBackground = function() {
            if (null != i) {
                var c = b.extend({}, d());
                c.x = i.getWidth() / 2,
                c.y = i.getHeight() / 2,
                c.w = 1,
                c.h = 1,
                o.centerContent({
                    bounds: c,
                    doNotAnimate: a.doNotAnimate,
                    onComplete: a.onComplete,
                    onStep: a.onStep,
                    vertical: !0,
                    horizontal: !0
                })
            }
        }
        ,
        this.alignBackground = function(a) {
            if (null != i) {
                var b = a.split(" ")
                  , c = b[0] || "left"
                  , e = b[1] || "top"
                  , f = d()
                  , g = "left" === c ? 0 : f.vw - i.getWidth() * ca
                  , h = "top" === e ? 0 : f.vh - i.getHeight() * ca
                  , j = Va();
                Ta(s, g - j[0], h - j[1]),
                i.pan(),
                db && db.pan()
            }
        }
        ,
        this.positionElementAt = function(b, c, d, e, f, g) {
            e = e || 0,
            f = f || 0;
            var h = Va()
              , i = Ta(s)
              , j = r(b)
              , k = j.parentNode
              , l = a.offset(k)
              , m = a.offset(t)
              , n = m.left - l.left + (i[0] + h[0]) + c * ca + e
              , o = m.top - l.top + (i[1] + h[1]) + d * ca + f;
            g && n < 0 && (n = 0),
            g && o < 0 && (o = 0),
            j.style.left = n + "px",
            j.style.top = o + "px"
        }
        ,
        this.positionElementAtPageLocation = function(a, b, c, d, e) {
            var f = this.mapLocation(b, c);
            this.positionElementAt(a, f.left, f.top, d, e)
        }
        ,
        this.positionElementAtEventLocation = function(a, b, c, d) {
            var e = this.mapEventLocation(b);
            this.positionElementAt(a, e.left, e.top, c, d)
        }
        ,
        this.zoomToEvent = function(a, b) {
            Ka(a),
            Pa(ca + b, a)
        }
        ,
        this.relayout = function(b, c) {
            if (a.enablePan === !1) {
                Ta(s, -b.x + M[0], -b.y + M[1], null, c);
                var d = b.w + (b.x < 0 ? b.x : 0) + M[0]
                  , e = b.h + (b.y < 0 ? b.y : 0) + M[1];
                s.style.width = d + "px",
                s.style.height = e + "px";
                var f = 0 == d ? 0 : (b.x - M[0]) / d * 100
                  , g = 0 == e ? 0 : (b.y - M[1]) / e * 100;
                this.setTransformOrigin(f, g)
            }
        }
        ,
        this.nudgeZoom = function(b, c) {
            var d = a.offset(u, !0)
              , e = d.left + a.width(u) / 2
              , f = d.top + a.height(u) / 2;
            return Ja(e, f),
            Pa(ca + b, c)
        }
        ,
        this.nudgeWheelZoom = function(a, b) {
            k = ca,
            Qa(0, a, b, !0)
        }
        ,
        this.centerContent = function(a) {
            a = a || {};
            var b = a.bounds || d()
              , c = Va()
              , e = b.x * ca + b.w * ca / 2
              , f = b.y * ca + b.h * ca / 2
              , g = b.vw / 2 - e
              , h = b.vh / 2 - f
              , j = Ta(s);
            Ta(s, a.horizontal !== !1 ? g - c[0] : j[0], a.vertical !== !1 ? h - c[1] : j[1], null, a.doNotAnimate, function() {
                a.doNotFirePanEvent || w(a.horizontal !== !1 ? g - j[0] : 0, a.vertical !== !1 ? h - j[1] : 0, ca, ca),
                i && i.pan(),
                db && db.pan(),
                a.onComplete && a.onComplete()
            }, a.onStep)
        }
        ,
        this.centerContentHorizontally = function(a) {
            this.centerContent(b.extend({
                horizontal: !0,
                vertical: !1
            }, a))
        }
        ,
        this.centerContentVertically = function(a) {
            this.centerContent(b.extend({
                vertical: !0,
                horizontal: !1
            }, a))
        }
        ,
        this.centerOn = function(a, c) {
            c = c || {};
            var e = b.extend({}, d())
              , f = Ta(a)
              , g = $(a)
              , h = _(a);
            e.x = f[0],
            e.y = f[1],
            e.w = g,
            e.h = h;
            var i = function() {
                La(f[0] + g / 2, f[1] + h / 2),
                c.onComplete && c.onComplete()
            };
            this.centerContent({
                bounds: e,
                doNotAnimate: c.doNotAnimate,
                onComplete: i,
                onStep: c.onStep,
                vertical: c.vertical !== !1,
                horizontal: c.horizontal !== !1
            })
        }
        ,
        this.centerOnHorizontally = function(a) {
            this.centerOn(a, {
                vertical: !1
            })
        }
        ,
        this.centerOnVertically = function(a) {
            this.centerOn(a, {
                horizontal: !1
            })
        }
        ,
        this.centerOnAndZoom = function(a, b) {
            b = b || .6;
            var c = {
                w: $(a),
                h: _(a)
            }
              , e = Ta(a)
              , f = d()
              , g = f.vw < f.vh ? [f.vw, "w"] : [f.vh, "h"]
              , h = b * g[0]
              , i = h / c[g[1]];
            i < ia[0] && (i = ia[0]),
            i > ia[1] && (i = ia[1]);
            var j = ca
              , k = i - ca;
            La(e[0] + c.w / 2, e[1] + c.h / 2),
            this.centerOn(a, {
                onStep: function(a, b) {
                    Pa(j + a / b * k)
                },
                onComplete: function() {
                    Pa(i)
                }
            })
        }
        ,
        this.getViewportCenter = function() {
            var a = b.extend({}, d())
              , c = Va()
              , e = Ta(s)
              , f = [a.vw / 2, a.vh / 2];
            return [(f[0] - (e[0] + c[0])) / ca, (f[1] - (e[1] + c[1])) / ca]
        }
        ,
        this.setViewportCenter = function(a) {
            var c = b.extend({}, d())
              , e = Va()
              , f = [c.vw / 2, c.vh / 2]
              , g = [e[0] + (ca * a[0] + f[0]), e[1] + (ca * a[1] + f[1])];
            Ta(s, g[0], g[1])
        }
        ,
        this.setClamping = function(a) {
            B = a
        }
        ,
        this.setZoom = function(a, b, c) {
            return Pa(a, null, null, b, c)
        }
        ,
        this.setZoomRange = function(a, b) {
            return null != a && 2 == a.length && a[0] < a[1] && null != a[0] && null != a[1] && a[0] > 0 && a[1] > 0 && (ia = a,
            b || (ca < ia[0] || ca > ia[1]) && Pa(ca)),
            this
        }
        ,
        this.getZoomRange = function() {
            return ia
        }
        ,
        this.getZoom = function() {
            return ca
        }
        ,
        this.getPan = function() {
            return Ta(s)
        }
        ,
        this.pan = function(a, b, c) {
            Ua(s, a, b, null, c, function(a) {
                w(a[0], a[1], ca, ca),
                i && i.pan(),
                db && db.pan()
            })
        }
        ,
        this.setPan = function(a, b, c, d, e) {
            return Ta(s, a, b, null, !c, d, e)
        }
        ,
        this.setTransformOrigin = function(a, b) {
            da = [a, b],
            Ga()
        }
        ,
        this.mapLocation = function(b, c, d) {
            var e = Va()
              , f = Ta(s)
              , g = u.scrollLeft
              , h = u.scrollTop
              , i = d ? {
                left: 0,
                top: 0
            } : a.offset(u);
            return {
                left: (b - (f[0] + e[0]) - i.left + g) / ca,
                top: (c - (f[1] + e[1]) - i.top + h) / ca
            }
        }
        ,
        this.mapEventLocation = function(a, b) {
            var c = Ma(a);
            return this.mapLocation(c[0], c[1], b)
        }
        ,
        this.setEnabled = function(a) {
            W = a
        }
        ,
        this.showElementAt = function(b, c, d) {
            var e = r(b)
              , f = e.parentNode
              , g = a.offset(f)
              , h = a.offset(t)
              , i = Va()
              , j = g.left - h.left + i[0] + c
              , k = g.top - h.top + i[1] + d;
            a.offset(b, {
                left: j,
                top: k
            })
        }
        ,
        this.getApparentCanvasLocation = function() {
            var a = Va()
              , b = Ta(s);
            return [b[0] + a[0], b[1] + a[1]]
        }
        ,
        this.setApparentCanvasLocation = function(a, b) {
            var c = Va()
              , d = Ta(s, a - c[0], b - c[1], null, !0);
            return i && i.pan(),
            db && db.pan(),
            d
        }
        ,
        this.applyZoomToElement = function(a, b) {
            b = b || ca,
            Fa("transform", "scale(" + b + ")", a)
        }
        ,
        this.setTransformOriginForElement = function(a, b) {
            Fa("transformOrigin", b[0] + " " + b[1], a)
        }
        ,
        this.getTransformOrigin = function() {
            return da
        }
        ,
        this.floatElement = function(a, b) {
            null != a && (a.style.position = "absolute",
            a.style.left = b[0] + "px",
            a.style.top = b[1] + "px",
            u.appendChild(a))
        }
        ;
        var bb = {}
          , cb = function(a) {
            var b = o.getApparentCanvasLocation();
            for (var c in bb)
                if (bb.hasOwnProperty(c)) {
                    if (null != a && a != c)
                        continue;
                    var d = bb[c]
                      , e = function(a, c) {
                        d[a] && (b[c] / ca + d.pos[c] < 0 ? d.el.style[a] = -(b[c] / ca) + "px" : d.el.style[a] = d.pos[c] + "px")
                    };
                    e("left", 0),
                    e("top", 1)
                }
        }
          , db = {
            pan: cb
        };
        this.fixElement = function(b, c, d) {
            if (null != b) {
                c = c || {};
                var e = a.id(b);
                bb[e] = {
                    el: b,
                    left: c.left,
                    top: c.top,
                    pos: d
                },
                b.style.position = "absolute",
                b.style.left = d[0] + "px",
                b.style.top = d[1] + "px",
                s.appendChild(b),
                cb(e)
            }
        }
        ,
        this.findIntersectingNodes = function(b, c, d, e) {
            var f = this.getApparentCanvasLocation()
              , g = a.offset(u)
              , h = u.scrollLeft
              , i = u.scrollTop
              , j = []
              , k = {
                x: b[0],
                y: b[1],
                w: c[0],
                h: c[1]
            }
              , l = d ? Biltong.encloses : Biltong.intersects
              , m = [g.left + f[0] - h, g.top + f[1] - i];
            for (var n in na)
                if (!pa[n]) {
                    var o = na[n]
                      , p = {
                        x: m[0] + o[0][0] * ca,
                        y: m[1] + o[0][1] * ca,
                        w: o[1] * ca,
                        h: o[2] * ca
                    };
                    l(k, p) && (null == e || e(n, oa[n], p)) && j.push({
                        id: n,
                        el: oa[n],
                        r: p
                    })
                }
            return j
        }
        ,
        this.findNearbyNodes = function(a, b, c, d) {
            var e = [];
            if (!c || this.isInViewport(a[0], a[1])) {
                e = this.findIntersectingNodes([a[0] - b, a[1] - b], [2 * b, 2 * b], !1, d);
                var f = this.mapLocation(a[0], a[1]);
                e.sort(function(a, b) {
                    var c = [a.x + a.w / 2, a.y + a.h / 2]
                      , d = [b.x + b.w / 2, b.y + b.h / 2]
                      , e = Biltong.lineLength(f, c)
                      , g = Biltong.lineLength(f, d);
                    return e < g ? -1 : e > g ? 1 : 0
                })
            }
            return e
        }
        ,
        this.isInViewport = function(b, c) {
            var d = a.offset(u)
              , e = a.width(u)
              , f = a.height(u);
            return d.left <= b && b <= d.left + e && d.top <= c && c <= d.top + f
        }
        ,
        this.getElementPositions = function() {
            return na
        }
        ,
        this.setFilter = function(a) {
            Z = a || function(a) {
                return !1
            }
        }
        ,
        this.setWheelFilter = function(a) {
            H = a || function(a) {
                return !0
            }
        }
        ,
        this.setBackground = function(a) {
            var b = a.type || "simple"
              , d = {
                simple: c,
                tiled: "absolute" == a.tiling ? f : e
            };
            i = new d[b]({
                canvas: s,
                viewport: u,
                getWidth: $,
                getHeight: _,
                url: a.url,
                zoomWidget: o,
                onBackgroundReady: a.onBackgroundReady,
                options: a,
                img: a.img,
                resolver: a.resolver
            })
        }
        ,
        a.background && this.setBackground(a.background),
        this.getBackground = function() {
            return i
        }
    }
    ;
    var c = function(a) {
        var b = a.canvas
          , c = a.onBackgroundReady || function() {}
          , d = new Image;
        d.onload = function() {
            b.style.backgroundImage = "url('" + d.src + "')",
            b.style.backgroundRepeat = "no-repeat",
            b.style.width = d.width + "px",
            b.style.height = d.height + "px",
            c(this)
        }
        ,
        d.src = a.img ? a.img.src : a.url,
        this.owns = function(a) {
            return a == b
        }
        ,
        this.getWidth = function() {
            return d.width || 0
        }
        ,
        this.getHeight = function() {
            return d.height || 0
        }
        ,
        this.setZoom = this.pan = function(a) {}
    }
      , d = function(a) {
        var b = this
          , c = a.canvas
          , d = a.viewport;
        if (null == a.options.maxZoom)
            throw new TypeError("Parameter `maxZoom` not set; cannot initialize TiledBackground");
        if (!a.options.tileSize)
            throw new TypeError("Parameter `tileSize not set; cannot initialize TiledBackground. It should be an array of [x,y] values.");
        if (!a.options.width || !a.options.height)
            throw new TypeError("Parameters `width` and `height` must be set");
        for (var e = function(c) {
            var d = document.createElement("div");
            d.style.position = "relative",
            d.style.height = "100%",
            d.style.width = "100%",
            d.style.display = "none",
            a.canvas.appendChild(d),
            this.zoom = c;
            var e = b.getTileSpecs(c)
              , f = []
              , g = function(b, c, d) {
                return a.url.replace("{z}", b).replace("{x}", c).replace("{y}", d)
            }
              , h = function(b, c, d) {
                return null == a.resolver ? g(b, c, d) : a.resolver(b, c, d)
            };
            this.apparentZoom = Math.min(e[2], e[3]),
            this.setActive = function(a) {
                d.style.display = a ? "block" : "none"
            }
            ,
            this.xTiles = e[0],
            this.yTiles = e[1];
            for (var i = 0; i < this.xTiles; i++) {
                f[i] = f[i] || [];
                for (var j = 0; j < this.yTiles; j++) {
                    var k = document.createElement("img");
                    k._tiledBg = !0,
                    k.className = "jtk-surface-tile",
                    k.ondragstart = function() {
                        return !1
                    }
                    ,
                    d.appendChild(k),
                    k.style.position = "absolute",
                    k.style.opacity = 0,
                    f[i][j] = [k, new Image, !1]
                }
            }
            var l = Math.pow(2, a.options.maxZoom - c) * a.options.tileSize[0]
              , m = Math.pow(2, a.options.maxZoom - c) * a.options.tileSize[1];
            this.scaledImageSize = l,
            this.scaledImageSizeH = m;
            var n = function(a, b, d, e) {
                a.style.left = d * l + "px",
                a.style.top = e * m + "px",
                a.style.width = l + "px",
                a.style.height = m + "px",
                b.onload = function() {
                    a.setAttribute("src", b.src),
                    a.style.opacity = 1
                }
                ,
                b.src = h(c, d, e)
            };
            this.ensureLoaded = function(a, b, c, d) {
                for (var e = a; e <= c; e++)
                    for (var g = b; g <= d; g++)
                        null != f[e] && null != f[e][g] && (f[e][g][2] || (n(f[e][g][0], f[e][g][1], e, g),
                        f[e][g][2] = !0))
            }
        }
        .bind(this), f = [], g = null, h = 0; h <= a.options.maxZoom; h++)
            f.push(new e(h));
        c.style.width = a.options.width + "px",
        c.style.height = a.options.height + "px";
        var i, j = function() {
            if (i <= f[0].apparentZoom)
                return 0;
            if (i >= f[f.length - 1].apparentZoom)
                return f.length - 1;
            for (var a = f.length - 1; a > 0; a--)
                if (f[a].apparentZoom >= i && i >= f[a - 1].apparentZoom)
                    return a
        }, k = function(a) {
            var b = f[a];
            null != g && g != b && g.setActive(!1),
            b.setActive(!0),
            g = b
        }, l = function() {
            var b = a.zoomWidget.getApparentCanvasLocation()
              , c = a.getWidth(d)
              , e = a.getHeight(d)
              , f = g.scaledImageSize * i
              , h = g.scaledImageSizeH * i
              , j = b[0] < 0 ? Math.floor(-b[0] / f) : b[0] < c ? 0 : null
              , k = b[1] < 0 ? Math.floor(-b[1] / h) : b[1] < e ? 0 : null
              , l = Math.min(g.xTiles, Math.floor((c - b[0]) / f))
              , m = Math.min(g.yTiles, Math.floor((e - b[1]) / h));
            null != j && null != k && g.ensureLoaded(j, k, l, m)
        };
        this.getCurrentLayer = function() {
            return g
        }
        ,
        this.getWidth = function() {
            return a.options.width
        }
        ,
        this.getHeight = function() {
            return a.options.height
        }
        ;
        var m = a.options.panDebounceTimeout || 50
          , n = a.options.zoomDebounceTimeout || 120
          , o = function(a, b) {
            b = b || 150;
            var c = null;
            return function() {
                window.clearTimeout(c),
                c = window.setTimeout(a, b)
            }
        }
          , p = function() {
            k(j()),
            l()
        }
          , q = o(p, n)
          , r = o(l, m);
        this.setZoom = function(a, b) {
            i = a,
            b ? p() : q()
        }
        ,
        this.pan = r,
        this.owns = function(a) {
            return a == c || 1 == a._tiledBg
        }
        ,
        this.setZoom(a.zoomWidget.getZoom(), !0),
        null != a.onBackgroundReady && setTimeout(a.onBackgroundReady, 0)
    }
      , e = function(a) {
        var b = a.options.width
          , c = a.options.height
          , e = a.options.tileSize;
        this.getTileSpecs = function(a) {
            var d = b > c ? 1 : b / c
              , f = c > b ? 1 : c / b
              , g = Math.pow(2, a + 1) * e[0] * d
              , h = Math.pow(2, a + 1) * e[1] * f
              , i = Math.ceil(g / e[0])
              , j = Math.ceil(h / e[1]);
            return [i, j, g / b, h / c]
        }
        ,
        d.apply(this, arguments)
    }
      , f = function(a) {
        var b = a.options.maxZoom
          , c = a.options.width
          , e = a.options.height
          , f = a.options.tileSize;
        this.getTileSpecs = function(a) {
            var d = Math.pow(2, b - a)
              , g = Math.ceil(c / d / f[0])
              , h = Math.ceil(e / d / f[1]);
            return [g, h, g * f[0] / c, h * f[1] / e]
        }
        ,
        d.apply(this, arguments)
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumbToolkit
      , c = b.Renderers
      , d = a.jsPlumb
      , e = a.jsPlumbUtil
      , f = d.getSelector
      , g = b.Classes
      , h = b.Constants
      , i = b.Events;
    c.Surface = function(a) {
        function j(a) {
            return null == a ? null : "string" == typeof a ? this.getRenderedConnection(a) : a.constructor == d.Connection ? a : l.getRenderedConnection(a.getId())
        }
        function k() {
            if (!m.jsPlumb.startEditing)
                throw new TypeError("Connection editors not available.")
        }
        var l = this;
        c.Surface.SELECT = h.select,
        c.Surface.PAN = h.pan,
        c.Surface.DISABLED = h.disabled;
        var m = c.AbstractRenderer.apply(this, arguments);
        c.DOMElementAdapter.apply(this, arguments),
        this.getObjectInfo = m.getObjectInfo,
        a = a || {};
        var n, o = d.getElement(a.container), p = c.createElement({
            position: h.relative,
            width: h.nominalSize,
            height: h.nominalSize,
            left: 0,
            top: 0,
            clazz: g.SURFACE_CANVAS
        }, o), q = !(a.elementsDraggable === !1), r = a.elementsDroppable === !0, s = a.dragOptions || {}, t = a.dropOptions || {}, u = a.stateHandle, v = a.storePositionsInModel !== !1, w = a.modelLeftAttribute, x = a.modelTopAttribute, y = new ZoomWidget({
            viewport: o,
            canvas: p,
            domElement: m.jsPlumb.getElement,
            addClass: m.jsPlumb.addClass,
            removeClass: m.jsPlumb.removeClass,
            offset: this.getOffset,
            consumeRightClick: a.consumeRightClick,
            bind: function() {
                m.jsPlumb.on.apply(m.jsPlumb, arguments)
            },
            unbind: function() {
                m.jsPlumb.off.apply(m.jsPlumb, arguments)
            },
            width: function(a) {
                return m.jsPlumb.getWidth(m.jsPlumb.getElement(a))
            },
            height: function(a) {
                return m.jsPlumb.getHeight(m.jsPlumb.getElement(a))
            },
            id: m.jsPlumb.getId,
            animate: function() {
                m.jsPlumb.animate.apply(m.jsPlumb, arguments)
            },
            dragEvents: {
                stop: d.dragEvents[h.stop],
                start: d.dragEvents[h.start],
                drag: d.dragEvents[h.drag]
            },
            background: a.background,
            padding: a.padding,
            panDistance: a.panDistance,
            enablePan: a.enablePan,
            enableWheelZoom: a.enableWheelZoom,
            wheelSensitivity: a.wheelSensitivity,
            wheelReverse: a.wheelReverse,
            wheelZoomMetaKey: a.wheelZoomMetaKey,
            enablePanButtons: a.enablePanButtons,
            enableAnimation: a.enableAnimation,
            clamp: a.clamp,
            clampZoom: a.clampZoom,
            clampToBackground: a.clampToBackground,
            clampToBackgroundExtents: a.clampToBackgroundExtents,
            zoom: a.zoom,
            zoomRange: a.zoomRange,
            extend: m.jsPlumb.extend,
            events: {
                pan: function(a, b, c, d, e) {
                    l.fire(i.pan, {
                        x: a,
                        y: b,
                        zoom: c,
                        oldZoom: d,
                        event: e
                    })
                },
                zoom: function(a, b, c, d, e) {
                    m.jsPlumb.setZoom(c),
                    l.fire(i.zoom, {
                        x: a,
                        y: b,
                        zoom: c,
                        oldZoom: d,
                        event: e
                    })
                },
                mousedown: function() {
                    d.addClass(o, g.SURFACE_PANNING),
                    d.addClass(document.body, g.SELECT_DEFEAT)
                },
                mouseup: function() {
                    d.removeClass(o, g.SURFACE_PANNING),
                    d.removeClass(document.body, g.SELECT_DEFEAT)
                }
            }
        }), z = [], A = a.lassoSelectionFilter, B = a.autoExitSelectMode !== !1, C = new b.Widgets.Lasso({
            on: function() {
                m.jsPlumb.on.apply(m.jsPlumb, arguments)
            },
            off: function() {
                m.jsPlumb.off.apply(m.jsPlumb, arguments)
            },
            invert: a.lassoInvert,
            pageLocation: y.pageLocation,
            canvas: o,
            onStart: function() {
                l.setHoverSuspended(!0),
                z.length = 0
            },
            onSelect: function(a, b, c, d) {
                function e(a) {
                    return a.el.jtk.node || a.el.jtk.group
                }
                var f = []
                  , g = y.findIntersectingNodes(a, b, !c[0]);
                m.jsPlumb.clearDragSelection && m.jsPlumb.clearDragSelection(),
                m.toolkit.clearSelection(),
                d && z.length > 0 && m.toolkit.removeFromSelection(z);
                for (var h = 0; h < g.length; h++)
                    null != A && A(e(g[h])) === !1 || (f.push(e(g[h])),
                    m.jsPlumb.addToDragSelection && m.jsPlumb.addToDragSelection(g[h].el));
                z = f,
                m.toolkit.addToSelection(f, d)
            },
            onEnd: function() {
                l.setHoverSuspended(!1),
                B && l.setMode(h.pan),
                l.fire("lasso:end")
            },
            filter: a.lassoFilter
        }), D = {
            pan: function() {
                C.setEnabled(!1),
                y.setEnabled(!0)
            },
            select: function() {
                m.jsPlumb.clearDragSelection && m.jsPlumb.clearDragSelection(),
                C.setEnabled(!0),
                y.setEnabled(!1)
            },
            disabled: function() {
                m.jsPlumb.clearDragSelection && m.jsPlumb.clearDragSelection(),
                C.setEnabled(!0),
                y.setEnabled(!1)
            }
        }, E = a.mode || h.pan;
        l.bind(i.relayout, function(a) {
            y.relayout(a, !0)
        }),
        l.bind(i.nodeRemoved, function(a) {
            y.remove(a.el)
        }),
        m.toolkit.bind(i.graphClearStart, function() {
            y.reset()
        }),
        m.toolkit.bind(i.dataLoadStart, function() {
            y.setSuspendRendering(!0)
        }),
        m.toolkit.bind(i.dataLoadEnd, function() {
            y.setSuspendRendering(!1),
            n && n.setVisible(!0),
            a.zoomToFit && l.zoomToFit()
        }),
        m.toolkit.bind(i.groupMemberAdded, function(a) {
            var b = m.nodeMap()[a.node.id];
            if (b) {
                var c = l.getJsPlumb().getGroup(a.group.id)
                  , d = l.getSize(c.getDragArea())
                  , e = l.getSize(b);
                y.suspend(b),
                l.fire(i.groupMemberAdded, a),
                m.jsPlumb.addToGroup(a.group.id, b, !0);
                var f = null == a.node.data.left ? (d[0] - e[0]) / 2 : a.node.data.left
                  , g = null == a.node.data.top ? (d[1] - e[1]) / 2 : a.node.data.top;
                l.setPosition(a.node.id, f, g)
            }
        }),
        m.toolkit.bind(i.groupMemberRemoved, function(a) {
            var b = m.nodeMap()[a.node.id];
            if (b) {
                y.restore(b),
                l.fire(i.groupMemberRemoved, a),
                m.jsPlumb.removeFromGroup(a.group.id, b, !0);
                var c = m.jsPlumb.getOffset(b);
                l.getLayout().setPosition(a.node.id, c.left, c.top)
            }
        }),
        m.jsPlumb.setContainer(p),
        d.addClass(o, g.SURFACE),
        a.enablePan === !1 && d.addClass(o, g.SURFACE_NO_PAN);
        var F = function(a, b) {
            var c = function(a) {
                var c = a.srcElement || a.target;
                c != o && c != p || l.fire(b, a)
            };
            m.jsPlumb.on(p, a, c),
            m.jsPlumb.on(o, a, c)
        };
        F(i.tap, i.canvasClick),
        F(i.dblclick, i.canvasDblClick);
        var G = null;
        m.makeDraggable = function(a, b) {
            if (q) {
                var c = d.getElement(a)
                  , f = m.jsPlumb.getId(c)
                  , j = m.jsPlumb.extend({}, s)
                  , k = d.dragEvents[h.stop]
                  , n = d.dragEvents[h.start]
                  , p = function(a) {
                    var b = d.getDragObject(a)
                      , c = d.getElement(b);
                    return {
                        node: c.jtk.node,
                        el: b
                    }
                };
                null != b && m.jsPlumb.extend(j, b),
                j[n] = e.wrap(j[n], function() {
                    G = y.getBoundsInfo();
                    var a = p(arguments);
                    a.elementId = f,
                    a.pos = d.getAbsolutePosition(c),
                    a.domEl = c,
                    d.addClass(o, g.SURFACE_ELEMENT_DRAGGING),
                    l.fire(i.nodeMoveStart, a)
                }),
                j[k] = e.wrap(j[k], function(a) {
                    for (var b = function(b) {
                        d.removeClass(o, g.SURFACE_ELEMENT_DRAGGING);
                        var c = {
                            el: b[0],
                            node: b[0].jtk.node || b[0].jtk.group,
                            pos: [b[1].left, b[1].top],
                            e: a.e,
                            eventPosition: a.pos
                        };
                        j.magnetize && !c.node.group ? c.pos = l.getLayout().setMagnetizedPosition(c.node.id, c.pos[0], c.pos[1], !0) : l.getLayout().setPosition(c.node.id, c.pos[0], c.pos[1], !0),
                        y.positionChanged(b[0]),
                        v !== !1 && (l.storePositionInModel({
                            id: c.node.id,
                            leftAttribute: w,
                            topAttribute: x
                        }),
                        m.toolkit.fire(i.nodeUpdated, {
                            node: c.node
                        }, null)),
                        l.fire(i.nodeMoveEnd, c)
                    }, c = 0; c < a.selection.length; c++)
                        b(a.selection[c])
                }),
                j.canDrag = function() {
                    return !C.isActive()
                }
                ,
                j.force = !0,
                m.jsPlumb.draggable(c, j, !1, m.jsPlumb)
            }
        }
        ,
        m.makeDroppable = function(a, b) {
            if (r) {
                var c = d.getElement(a)
                  , f = m.jsPlumb.extend({}, t);
                null != b && m.jsPlumb.extend(f, b),
                f[h.drop] = e.wrap(f[h.drop], function(a) {
                    var b = {
                        source: a.drag.el.jtk.node,
                        sourceElement: a.drag.el,
                        target: a.drop.el.jtk.node,
                        targetElement: a.drop.el,
                        e: a.e
                    };
                    l.fire(i.nodeDropped, b)
                }),
                m.jsPlumb.droppable(c, f)
            }
        }
        ,
        m.doImport = function(b) {
            a.jsPlumbInstance.setContainer(p);
            var c = a.jsPlumbInstance.getManagedElements();
            for (var d in c) {
                var e = c[d].el;
                H(e, d)
            }
        }
        ;
        var H = this.importNode = function(b, c) {
            var e = a.jsPlumbInstance.getOffset(b)
              , f = a.jsPlumbInstance.getId(b);
            b.style.left = e.left + h.px,
            b.style.top = e.top + h.px,
            d.addClass(b, g.NODE),
            y.add(b, f, [e.left, e.top], !1),
            this.getLayout().setPosition(c, e.left, e.top),
            d.isAlreadyDraggable(b) && m.makeDraggable(b),
            m.nodeMap()[c] = b,
            m.reverseNodeMap()[f] = b.jtk.node,
            null != n && n.registerNode({
                el: b,
                node: b.jtk.node,
                pos: d.getAbsolutePosition(b)
            })
        }
        .bind(this);
        this.zoomToFit = y.zoomToFit,
        this.zoomToFitIfNecessary = y.zoomToFitIfNecessary,
        this.zoomToSelection = function(a) {
            a = a || {};
            var b = a.selection || m.toolkit.getSelection()
              , c = [];
            b.eachNode(function(a, b) {
                c.push(m.getElement(b.id))
            }),
            c.length > 0 && y.zoomToElements({
                elements: c,
                fill: a.fill
            })
        }
        ,
        this.zoomToBackground = y.zoomToBackground,
        this.centerOn = function(a, b) {
            var c = this.getObjectInfo(a);
            c && c.el && y.centerOn(c.el, b)
        }
        ,
        this.centerOnHorizontally = function(a) {
            this.centerOn(a, {
                vertical: !1
            })
        }
        ,
        this.centerOnVertically = function(a) {
            this.centerOn(a, {
                horizontal: !1
            })
        }
        ,
        this.centerOnAndZoom = function(a, b) {
            var c = this.getObjectInfo(a);
            c && c.el && y.centerOnAndZoom(c.el, b)
        }
        ,
        this.centerContent = y.centerContent,
        this.centerContentHorizontally = y.centerContentHorizontally,
        this.centerContentVertically = y.centerContentVertically,
        this.getViewportCenter = y.getViewportCenter,
        this.setViewportCenter = y.setViewportCenter,
        this.setStateHandle = function(a) {
            u = a
        }
        ,
        this.getStateHandle = function() {
            return u
        }
        ,
        this.setLassoSelectionFilter = function(a) {
            A = a
        }
        ,
        this.getApparentCanvasLocation = y.getApparentCanvasLocation,
        this.setApparentCanvasLocation = y.setApparentCanvasLocation,
        this.getBoundsInfo = y.getBoundsInfo,
        this.setZoom = y.setZoom,
        this.setZoomRange = y.setZoomRange,
        this.getZoomRange = y.getZoomRange,
        this.getZoom = y.getZoom,
        this.nudgeZoom = y.nudgeZoom,
        this.nudgeWheelZoom = y.nudgeWheelZoom,
        this.pageLocation = y.pageLocation,
        this.getPan = y.getPan,
        this.pan = y.pan,
        this.setPan = y.setPan,
        this.startEditing = function(a, b) {
            k();
            var c = j(a);
            null != c && m.jsPlumb.startEditing(c, b)
        }
        ,
        this.stopEditing = function(a) {
            k();
            var b = j(a);
            null != b && m.jsPlumb.stopEditing(b)
        }
        ,
        this.clearEdits = function(a) {
            k();
            var b = j(a);
            null != b && m.jsPlumb.clearEdits(b)
        }
        ,
        this.setPanAndZoom = function(a, b, c, d) {
            this.setPan(a, b, !d),
            this.setZoom(c, !d)
        }
        ,
        this.setPanFilter = function(a) {
            y.setFilter(a ? function(b, c) {
                return "function" == typeof a ? a.apply(a, [c]) : e.matchesSelector(b, a)
            }
            : null)
        }
        ,
        this.setWheelFilter = function(a) {
            y.setWheelFilter(function(b) {
                if (a) {
                    var c = b.srcElement || b.target;
                    return !e.matchesSelector(c, a)
                }
                return !0
            })
        }
        ,
        this.setWheelFilter(a.wheelFilter),
        this.setPanFilter(a.panFilter),
        this.mapLocation = y.mapLocation,
        this.mapEventLocation = y.mapEventLocation,
        this.findNearbyNodes = y.findNearbyNodes,
        this.findIntersectingNodes = y.findIntersectingNodes,
        this.isInViewport = y.isInViewport,
        this.getViewportCenter = y.getViewportCenter,
        this.positionElementAt = y.positionElementAt,
        this.positionElementAtEventLocation = y.positionElementAtEventLocation,
        this.positionElementAtPageLocation = y.positionElementAtPageLocation,
        this.setFilter = y.setFilter,
        this.floatElement = y.floatElement,
        this.fixElement = y.fixElement;
        var I = this.setPosition
          , J = this.animateToPosition
          , K = function(a, b, c) {
            a && (y.positionChanged(a.el, [b, c]),
            l.fire(i.nodeMoveEnd, {
                el: a.el,
                id: a.id,
                pos: [b, c],
                node: a.obj || (a.el.jtk ? a.el.jtk.node || a.el.jtk.group : {}),
                bounds: y.getBoundsInfo()
            }))
        };
        this.setPosition = function(a, b, c, d) {
            var e = I.apply(this, arguments);
            K(e, b, c)
        }
        ,
        this.animateToPosition = function(a, b, c, d) {
            var e = J.apply(this, arguments);
            K(e, b, c)
        }
        ,
        this.tracePath = function(a) {
            var b = a.path || function() {
                var b = m.getObjectInfo(a.source)
                  , c = m.getObjectInfo(a.target);
                return m.toolkit.getPath({
                    source: b,
                    target: c
                })
            }();
            if (b.exists()) {
                for (var c = function(b, c) {
                    this.fire(b, {
                        edge: c.edge,
                        connection: c,
                        options: a.options
                    })
                }
                .bind(this), e = [], f = null, g = null, h = b.path.path.length, i = 1; i < h; i++) {
                    var j = b.path.path[i].vertex.id
                      , k = b.path.previous[j]
                      , l = !0
                      , n = b.path.path[i].edge;
                    null != k && (l = k === n.source),
                    f = m.getConnectionForEdge(n),
                    g = f.animateOverlay(a.overlay, d.extend(a.options || {}, {
                        previous: g,
                        isFinal: i === h - 1,
                        forwards: l
                    })),
                    e.push({
                        handler: g,
                        connection: f
                    })
                }
                return e.length > 0 && (e[0].handler.bind(jsPlumbToolkit.Events.startOverlayAnimation, function() {
                    c(jsPlumbToolkit.Events.startOverlayAnimation, e[0].connection)
                }),
                e[e.length - 1].handler.bind(jsPlumbToolkit.Events.endOverlayAnimation, function() {
                    c(jsPlumbToolkit.Events.endOverlayAnimation, e[e.length - 1].connection)
                })),
                !0
            }
            return m.toolkit.isDebugEnabled() && jsPlumbUtil.log("Cannot trace non existent path"),
            !1
        }
        ,
        this.getNodePositions = function() {
            var a = {}
              , b = y.getElementPositions();
            for (var c in b) {
                var d = m.getNodeForElementId(c) || m.getGroupForElementId(c);
                d && (a[d.id] = [b[c][0][0], b[c][0][1]])
            }
            return a
        }
        ,
        this.append = function(a, b, c, d) {
            p.appendChild(a),
            c && (c = [c.left, c.top]),
            y.add(a, b, c, d)
        }
        ,
        this.nodeAppendedToGroup = function(a, b, c) {
            y.suspend(a)
        }
        ,
        this.nodeRemovedFromGroup = function(a) {
            y.restore(a)
        }
        ;
        var L = this.setLayout;
        this.setLayout = function(a, b) {
            L.apply(this, [a, b]),
            n && n.setHostLayout(this.getLayout())
        }
        ;
        for (var M = function(a) {
            m.jsPlumb.on(p, a, ".jtk-node, .jtk-node *", function(b) {
                var c = b.srcElement || b.target;
                if (null == c && (b = d.getOriginalEvent(b),
                c = b.srcElement || b.target),
                null != c && c.jtk) {
                    var e = d.extend({
                        e: b,
                        el: c
                    }, c.jtk);
                    l.fire(a, e, b)
                }
            })
        }, N = 0; N < c.mouseEvents.length; N++)
            M(c.mouseEvents[N]);
        m.toolkit.bind(h.select, function(a) {
            if (a.obj.objectType == h.nodeType || a.obj.objectType == h.groupType) {
                var b = m.getElement(a.obj.id);
                b && (d.addClass(b, g.SURFACE_SELECTED_ELEMENT),
                m.jsPlumb.addToDragSelection && m.jsPlumb.addToDragSelection(b))
            } else if (a.obj.objectType == h.edgeType) {
                var c = m.getConnectionForEdge(a.obj);
                c && c.addClass(g.SURFACE_SELECTED_CONNECTION)
            }
        }),
        m.toolkit.bind(i.selectionCleared, function() {
            m.jsPlumb.clearDragSelection && m.jsPlumb.clearDragSelection(),
            d.removeClass(f("." + g.SURFACE_SELECTED_CONNECTION), g.SURFACE_SELECTED_CONNECTION),
            d.removeClass(f("." + g.SURFACE_SELECTED_ELEMENT), g.SURFACE_SELECTED_ELEMENT)
        }),
        m.toolkit.bind(i.deselect, function(a) {
            if (a.obj.objectType == h.nodeType || a.obj.objectType == h.groupType) {
                var b = m.getElement(a.obj.id);
                b && (d.removeClass(b, g.SURFACE_SELECTED_ELEMENT),
                m.jsPlumb.removeFromDragSelection && m.jsPlumb.removeFromDragSelection(b))
            } else if (a.obj.objectType == h.edgeType) {
                var c = m.getConnectionForEdge(a.obj);
                c && c.removeClass(g.SURFACE_SELECTED_CONNECTION)
            }
        });
        var O = this.setOffset;
        this.setOffset = function(a, b) {
            O.apply(this, arguments),
            y.positionChanged(a, [b.left, b.top])
        }
        ,
        this.setMode = function(a, b, c) {
            if (!D[a])
                throw new TypeError("Surface: unknown mode '" + a + "'");
            E = a,
            D[a](),
            a !== h.select || b || m.toolkit.clearSelection(),
            c && a === h.select && c.lassoSelectionFilter && (A = c.lassoSelectionFilter),
            l.fire(i.modeChanged, a)
        }
        ;
        var P = function(a, b) {
            var c = d.extend({}, a);
            c.source = m.getObjectInfo(a.source).obj,
            c.target = m.getObjectInfo(a.target).obj,
            c.element = m.getObjectInfo(a.element).obj;
            var e = m.toolkit[b](c)
              , f = m.getConnectionsForEdges(e);
            return m.jsPlumb.select({
                connections: f
            })
        };
        this.selectEdges = function(a) {
            return P(a, "getEdges")
        }
        ,
        this.selectAllEdges = function(a) {
            return P(a, "getAllEdges")
        }
        ,
        this.repaint = function(a) {
            var b = m.getObjectInfo(a);
            b.el && (m.jsPlumb.recalculateOffsets(b.el),
            m.jsPlumb.revalidate(m.jsPlumb.getId(b.el)),
            l.fire(i.objectRepainted, b))
        }
        ,
        this.repaintEverything = m.jsPlumb.repaintEverything,
        this.setElementsDraggable = function(a) {
            q = a !== !1
        }
        ;
        var Q = function(a) {
            function b(a) {
                m.jsPlumb.hasClass(a, g.SURFACE_DROPPABLE_NODE) || (m.jsPlumb.addClass(a, g.SURFACE_DROPPABLE_NODE),
                m.jsPlumb.initDraggable(a, p, h.surfaceNodeDragScope, m.jsPlumb))
            }
            if (!(a && (a.droppables || a.source && a.selector || a.allowNative === !0)))
                throw new TypeError("Cannot configure droppables: you must specify either `droppables`, `source` + `selector` or `allowNative:true`");
            var c, f = a.dataGenerator || function() {
                return {}
            }
            , j = a.typeExtractor, k = a.locationSetter || function(a, b, c) {
                c.left = a,
                c.top = b
            }
            , n = a.droppables ? a.droppables : a.source ? a.source.querySelectorAll(a.selector) : [], p = a.dragOptions || {}, q = a.dropOptions || {}, r = "scope_" + (new Date).getTime(), s = function(b, c, d) {
                var e = !0;
                if (a.drop && (e = a.drop.apply(this, arguments) !== !1),
                e) {
                    var g = l.getJsPlumb()
                      , h = m.jsPlumb.getDragObject(arguments)
                      , i = g.getOffset(d ? C : h, !0)
                      , n = y.mapLocation(i.left, i.top)
                      , o = j ? j(h, b, d, n) : null
                      , p = f ? f(o, h, b, n) : {}
                      , q = "true" === h.getAttribute("jtk-group");
                    p = p || {};
                    var r = l.getObjectInfo(b.e.srcElement || b.e.target);
                    if (null != o && (p.type = o),
                    null != r && !q && "Group" === r.type) {
                        var s = g.getGroup(r.id)
                          , t = l.getOffset(s ? s.getDragArea() : r.el);
                        n.left -= t.left,
                        n.top -= t.top
                    }
                    k(n.left, n.top, p),
                    q ? m.toolkit.getGroupFactory()(o, p, function(c) {
                        var d = m.toolkit.addGroup(c, {
                            position: n
                        });
                        a.onDrop && a.onDrop(d, b, n)
                    }, b, d) : m.toolkit.getNodeFactory()(o, p, function(c) {
                        var d = m.toolkit.addNode(c, {
                            position: n
                        });
                        null != r.obj && "Group" === r.type && (m.toolkit.addToGroup(d, r.obj),
                        l.setPosition(m.nodeMap()[d.id], n.left, n.top),
                        g.getDragManager().updateOffsets(r.el)),
                        a.onDrop && a.onDrop(d, b, n)
                    }, b, d)
                }
            }, t = d.dragEvents[h.start], u = d.dragEvents[h.drag], v = d.dragEvents[h.stop], w = d.dragEvents[h.drop], x = function() {}, z = a.nativeFilter || [], A = a.allowNative, B = {};
            if (p[t] = e.wrap(p[t], a.start || x),
            p[u] = e.wrap(p[u], a.drag || x),
            p[v] = e.wrap(p[v], a.stop || x),
            q.scope = r,
            q[w] = e.wrap(q[w], s),
            A) {
                var C = document.createElement(h.div);
                for (C.style.position = h.absolute,
                c = 0; c < z.length; c++)
                    B[z[c]] = !0;
                var D = function(a) {
                    return null != a.dataTransfer && 1 === a.dataTransfer.items.length && (0 == z.length || B[a.dataTransfer.items[0].type])
                };
                document.addEventListener(i.dragover, function(a) {
                    a.stopPropagation(),
                    a.preventDefault(),
                    D(a) && (d.setAbsolutePosition(C, [a.pageX, a.pageY]),
                    p[u].apply(null, [a, {
                        helper: C,
                        offset: {
                            left: a.pageX,
                            top: a.pageY
                        }
                    }, !0]))
                }, !1),
                document.addEventListener(i.drop, function(a) {
                    a.stopPropagation(),
                    a.preventDefault(),
                    D(a) && (q[w].apply(null, [a, {
                        helper: C,
                        offset: {
                            left: a.pageX,
                            top: a.pageY
                        }
                    }, !0]),
                    p[v].apply(null))
                }, !1),
                document.addEventListener(i.dragend, function(a) {})
            }
            for (m.jsPlumb.initDroppable(o, q, h.surfaceNodeDragScope),
            p.scope = r,
            p.ignoreZoom = !0,
            p.doNotRemoveHelper = !0,
            c = 0; c < n.length; c++) {
                var E = m.jsPlumb.getElement(n[c]);
                b(E)
            }
            return {
                refresh: function() {
                    if (!a.source || !a.selector)
                        throw new TypeError("Cannot refresh droppables; `source` and `selector` required in constructor.");
                    for (var c = a.source.querySelectorAll(a.selector), d = 0; d < c.length; d++)
                        b(c[d])
                }
            }
        };
        this.registerDroppableNodes = function(a) {
            return new Q(a)
        }
        ,
        this.createMiniview = function(a) {
            if (null != n) {
                var c = m.jsPlumb.getId(m.jsPlumb.getElement(a.container));
                if (n.getContainerId() == c)
                    return !1
            }
            var e = d.extend({
                surface: l,
                toolkit: m.toolkit,
                surfaceContainerElement: o,
                bounds: y.getBoundsInfo(),
                visible: a.initiallyVisible !== !1 || m.toolkit.getNodeCount() > 0,
                layout: {
                    type: h.mistletoeLayoutType,
                    parameters: {
                        layout: l.getLayout()
                    }
                },
                typeFunction: a.typeFunction
            }, a);
            n = new b.Renderers.Miniview(e);
            var f = m.nodeMap();
            for (var g in f) {
                var i = f[g];
                n.registerNode({
                    el: i,
                    node: i.jtk.node,
                    pos: d.getAbsolutePosition(i)
                })
            }
            var j = m.groupMap();
            for (var g in j) {
                var i = j[g];
                n.registerNode({
                    el: i,
                    node: i.jtk.group,
                    pos: d.getAbsolutePosition(i)
                })
            }
            return n
        }
        ,
        a.miniview && this.createMiniview(a.miniview),
        this.getMiniview = function() {
            return n
        }
        ;
        var R = function(a, b, c) {
            var d = m.getObjectInfo(b)
              , e = null;
            if (d.el && ("Port" === !d.obj.objectType || !function() {
                var a = l.getRenderedEndpoint(d.obj);
                if (a)
                    return e = a.setEnabled(c),
                    !0
            }())) {
                var f = "set" + a + "Enabled";
                e = m.jsPlumb[f](d.el, c)
            }
            return e
        };
        this.setTargetEnabled = R.bind(this, "Target"),
        this.setSourceEnabled = R.bind(this, "Source"),
        this.setEnabled = function(a, b) {
            this.setTargetEnabled(a, b),
            this.setSourceEnabled(a, b)
        }
        ,
        this.State = {
            save: function(a, c) {
                if (a = 2 == arguments.length ? arguments[0] : 1 == arguments.length && "string" == typeof arguments[0] ? arguments[0] : u,
                c = 2 == arguments.length ? arguments[1] : 1 == arguments.length && "function" == typeof arguments[0] ? arguments[0] : function(a, b) {
                    return b(a)
                }
                ,
                a)
                    try {
                        c(l.State.serialize(), function(c) {
                            b.util.Storage.set(h.jtkStatePrefix + a, c)
                        })
                    } catch (a) {
                        e.log(g.msgCannotSaveState, a)
                    }
            },
            serialize: function() {
                var a = y.getPan();
                a.push(y.getZoom()),
                a.push.apply(a, y.getTransformOrigin());
                var b = a.join(",")
                  , c = l.getLayout().getPositions()
                  , d = [];
                for (var e in c)
                    d.push(e + " " + c[e][0] + " " + c[e][1]);
                return b += "," + d.join("|")
            },
            restore: function(a, c) {
                if (a = 2 == arguments.length ? arguments[0] : 1 == arguments.length && "string" == typeof arguments[0] ? arguments[0] : u,
                c = 2 == arguments.length ? arguments[1] : 1 == arguments.length && "function" == typeof arguments[0] ? arguments[0] : function(a, b) {
                    return b(a)
                }
                ,
                a)
                    try {
                        var d = b.util.Storage.get(h.jtkStatePrefix + a);
                        d && c(d, l.State.deserialize)
                    } catch (a) {
                        e.log(g.msgCannotRestoreState, a)
                    }
            },
            deserialize: function(a) {
                for (var b = a.split(","), c = b[5].split("|"), d = l.getLayout(), e = 0; e < c.length; e++) {
                    var f = c[e].split(" ");
                    try {
                        l.setPosition(f[0], parseFloat(f[1]), parseFloat(f[2]))
                    } catch (a) {}
                }
                d.draw()
            },
            clear: function(a) {
                a = a || u,
                a && b.util.Storage.clear(h.jtkStatePrefix + a)
            },
            clearAll: function() {
                b.util.Storage.clearAll()
            }
        },
        l.saveState = l.State.save,
        l.store = b.util.Storage.set,
        l.retrieve = b.util.Storage.get,
        l.storeJSON = b.util.Storage.setJSON,
        l.retrieveJSON = b.util.Storage.getJSON,
        l.restoreState = function(a) {
            l.State.restore(a),
            l.getJsPlumb().repaintEverything(),
            l.fire(i.stateRestored)
        }
        ,
        l.clearState = function(a) {
            l.state.clear(a)
        }
        ,
        l.initialize(),
        a.zoomToFitIfNecessary ? l.zoomToFitIfNecessary() : a.zoomToFit && l.zoomToFit()
    }
    ,
    b.DefaultRendererType = h.surfaceType,
    "undefined" != typeof exports && (exports.Surface = c.Surface)
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumbToolkit
      , c = b.Renderers
      , d = a.jsPlumbUtil
      , e = a.jsPlumb
      , f = b.Classes
      , g = b.Constants
      , h = b.Events
      , i = b.Attributes
      , j = b.Methods;
    c.Miniview = function(a) {
        function b(a) {
            if (o && z && !t) {
                s = o.getBoundsInfo();
                var b = o.getApparentCanvasLocation()
                  , c = z.getApparentCanvasLocation()
                  , d = z.getZoom()
                  , f = d / s.zoom;
                r.style.width = s.vw + g.px,
                r.style.height = s.vh + g.px,
                z.applyZoomToElement(r, f);
                var h = [b[0] * f, b[1] * f];
                n = [c[0] - h[0], c[1] - h[1]],
                e.setAbsolutePosition(r, n)
            }
        }
        function k(a) {
            if (null != z) {
                s = o.getBoundsInfo(),
                a = a || e.getAbsolutePosition(r);
                var b = z.getApparentCanvasLocation()
                  , c = z.getZoom()
                  , d = c / s.zoom
                  , f = (b[0] - a[0]) / d
                  , g = (b[1] - a[1]) / d
                  , h = o.setApparentCanvasLocation(f, g);
                return [b[0] - h[0] * d, b[1] - h[1] * d]
            }
        }
        this.bindToolkitEvents = !1;
        var l = c.AbstractRenderer.apply(this, arguments)
          , m = this;
        c.DOMElementAdapter.apply(this, arguments);
        var n, o = a.surface, p = e.getElement(a.container), q = c.createElement({
            position: g.relative,
            width: g.nominalSize,
            height: g.nominalSize,
            left: 0,
            top: 0,
            clazz: f.MINIVIEW_CANVAS
        }, p), r = c.createElement({
            position: g.absolute,
            width: g.nominalSize,
            height: g.nominalSize,
            left: 0,
            top: 0,
            clazz: f.MINIVIEW_PANNER
        }, p), s = a.bounds, t = a.suspended === !0, u = a.collapsible !== !1, v = a.typeFunction, w = null, x = !1, y = a.wheelSensitivity || 10, z = new ZoomWidget({
            viewport: p,
            canvas: q,
            domElement: e.getElement,
            offset: this.getOffset,
            bind: function() {
                l.jsPlumb.on.apply(l.jsPlumb, arguments)
            },
            unbind: function() {
                l.jsPlumb.off.apply(l.jsPlumb, arguments)
            },
            enableWheelZoom: !1,
            enablePanButtons: !1,
            enablePan: !1,
            enableAnimation: !1,
            width: function(a) {
                return l.jsPlumb.getWidth(l.jsPlumb.getElement(a))
            },
            height: function(a) {
                return l.jsPlumb.getHeight(l.jsPlumb.getElement(a))
            },
            id: l.jsPlumb.getId,
            animate: l.jsPlumb.animate,
            dragEvents: {
                stop: e.dragEvents[g.stop],
                start: e.dragEvents[g.start],
                drag: e.dragEvents[g.drag]
            },
            extend: e.extend,
            events: {
                pan: function() {
                    k()
                },
                mousedown: function() {
                    e.addClass(r, f.MINIVIEW_PANNING)
                },
                mouseup: function() {
                    e.removeClass(r, f.MINIVIEW_PANNING)
                }
            },
            zoomRange: [-(1 / 0), 1 / 0]
        }), A = !1, B = null, C = null, D = !1, E = a.elementFilter || function() {
            return !0
        }
        , F = function(a) {
            A = !0,
            B = z.pageLocation(a),
            C = e.getAbsolutePosition(r),
            e.on(document, h.mouseup, H),
            e.on(document, h.mousemove, G),
            d.consume(a)
        }, G = function(a) {
            if (D = !1,
            A) {
                var b = z.pageLocation(a)
                  , c = b[0] - B[0]
                  , d = b[1] - B[1]
                  , f = [C[0] + c, C[1] + d];
                k(f);
                e.setAbsolutePosition(r, f)
            }
        }, H = function(a) {
            A = !1,
            B = null,
            e.off(document, h.mouseup, H),
            e.off(document, h.mousemove, G)
        }, I = !0, J = function(a) {
            d.consume(a),
            o.nudgeWheelZoom(a.normalizedWheelDelta * y, a)
        };
        e.on(window, h.resize, jsPlumbToolkitUtil.debounce(function() {
            b()
        }, 100)),
        a.enableWheelZoom !== !1 && addWheelListener(p, J),
        z.setTransformOriginForElement(r, [0, 0]),
        e.addClass(p, f.MINIVIEW),
        e.on(r, h.mousedown, F),
        u && (w = e.createElement("div"),
        w.className = f.MINIVIEW_COLLAPSE,
        p.appendChild(w),
        e.on(w, g.click, function(a) {
            x = !x,
            e[x ? j.addClass : j.removeClass](p, f.MINIVIEW_COLLAPSED),
            K(!0)
        }));
        var K = function(a) {
            z.zoomToFit({
                onComplete: b,
                onStep: b,
                doNotFirePanEvent: a
            })
        };
        a.toolkit.bind(h.dataLoadEnd, K);
        var L = function(a) {
            var b = a.node || a.group;
            if (!b || E(b) !== !1) {
                s = a.bounds;
                var c = l.nodeMap()[(a.node || a.group).id] || a.el;
                z.positionChanged(c, a.pos),
                e.setAbsolutePosition(c, a.pos),
                K(!0),
                this.fire(h.nodeMoveEnd, a)
            }
        }
        .bind(this)
          , M = function(a, b) {
            for (var c = a.getNodes(), d = 0; d < c.length; d++) {
                var e = l.nodeMap()[c[d].id];
                e && b.appendChild(e)
            }
        }
          , N = function(a, d) {
            if (!a.node || E(a.node) !== !1) {
                var h = e.getSize(a.el)
                  , j = c.createElement({
                    position: g.absolute,
                    width: h[0] + g.px,
                    height: h[1] + g.px,
                    left: 0,
                    top: 0,
                    clazz: f.MINIVIEW_ELEMENT + (d ? " " + d : "")
                });
                if (v && j.setAttribute("jtk-miniview-type", v(a.node)),
                j.relatedElement = a.el,
                j.jtk = a.node,
                s = o.getBoundsInfo(),
                j.setAttribute(i.jtkNodeId, a.node.id),
                j.setAttribute(i.relatedNodeId, a.el.getAttribute(g.id)),
                q.appendChild(j),
                z.add(j),
                l.nodeMap()[(a.node || a.group).id] = j,
                a.group)
                    M(a.group, j);
                else if (a.node.group) {
                    var k = l.nodeMap()[a.node.group.id];
                    k && (k.appendChild(j),
                    z.suspend(a.el))
                }
                m.getLayout().map(a.node.id, j),
                b()
            }
        };
        this.registerNode = function(a) {
            N(a, "Group" === a.node.objectType ? f.MINIVIEW_GROUP_ELEMENT : ""),
            L(a)
        }
        ;
        var O = this.setOffset;
        this.setOffset = function(a, b) {
            O.apply(this, arguments),
            z.positionChanged(a, [b.left, b.top])
        }
        ;
        var P = this.setAbsolutePosition;
        this.setAbsolutePosition = function(a, b) {
            P.call(this, a, b),
            z.positionChanged(a, b)
        }
        ,
        this.setVisible = function(a) {
            I = a,
            p.style.display = a ? g.block : g.none
        }
        ,
        this.setVisible(a.visible !== !1),
        this.getPan = z.getPan;
        var Q = function(a, b) {
            for (var c = a.getNodes(), d = 0; d < c.length; d++)
                l.nodeMap()[c[d].id].style.display = b ? "block" : "none"
        }
          , R = function(a) {
            var c = l.nodeMap()[a.id];
            if (c) {
                var d = e.getSize(c.relatedElement);
                c.style.width = d[0] + g.px,
                c.style.height = d[1] + g.px,
                b(),
                v && c.setAttribute("jtk-miniview-type", v(a.obj))
            }
        };
        this.invalidate = function(a) {
            if (a)
                R({
                    id: a
                });
            else {
                var b = l.nodeMap();
                for (var c in b)
                    R({
                        id: c
                    })
            }
        }
        ,
        this.setSuspended = function(a, b) {
            t = a,
            b && this.update()
        }
        ,
        this.update = b;
        var S = function(a) {
            var c = a.node
              , d = l.nodeMap()[c];
            d && (z.remove(d),
            delete l.nodeMap()[c],
            l.jsPlumb.removeElement(d)),
            a.dontUpdatePanner || b()
        }
          , T = function() {
            var a = l.nodeMap();
            for (var c in a)
                S({
                    node: c,
                    dontUpdatePanner: !0
                });
            b()
        };
        o.bind(h.pan, b),
        o.bind(h.zoom, b),
        o.bind(h.nodeMoveEnd, L),
        o.bind(h.nodeRemoved, S),
        o.bind(h.nodeAdded, N),
        o.bind(h.nodeRendered, N),
        o.bind(h.groupMoveEnd, L),
        o.bind(h.groupAdded, function(a) {
            N(a, f.MINIVIEW_GROUP_ELEMENT)
        }),
        o.bind(h.groupMoveEnd, L),
        o.bind(h.groupMemberAdded, function(a) {
            var b = l.nodeMap()[a.group.id]
              , c = l.nodeMap()[a.node.id];
            b && c && b.appendChild(c)
        }),
        o.bind(h.groupMemberRemoved, function(a) {
            var b = l.nodeMap()[a.node.id];
            b && q.appendChild(b)
        }),
        o.bind(h.groupCollapse, function(a) {
            Q(a.group, !1),
            R({
                id: a.group.id
            })
        }),
        o.bind(h.groupExpand, function(a) {
            Q(a.group, !0),
            R({
                id: a.group.id
            })
        }),
        o.bind(h.relayout, b),
        o.bind(h.objectRepainted, R),
        o.bind(h.stateRestored, b),
        a.toolkit.bind(h.graphClearStart, T);
        var U = function() {
            K(!0)
        };
        m.getLayout().bind(h.redraw, U),
        this.setHostLayout = function(a) {
            var b = m.getLayout();
            b && b.setHostLayout(a)
        }
        ,
        this.setZoom = z.setZoom,
        this.getZoom = z.getZoom,
        this.getTransformOrigin = z.getTransformOrigin
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this
      , b = a.jsPlumbToolkit
      , c = b.Widgets
      , d = a.jsPlumbUtil
      , e = "ontouchstart"in document.documentElement
      , f = e ? "touchstart" : "mousedown"
      , g = e ? "touchend" : "mouseup"
      , h = e ? "touchmove" : "mousemove"
      , i = function(a, b) {
        a.style.width = b[0] + "px",
        a.style.height = b[1] + "px"
    }
      , j = {
        SELECT_DEFEAT: "jtk-lasso-select-defeat",
        LASSO: "jtk-lasso",
        LASSO_MASK: "jtk-lasso-mask",
        LASSO_MASK_LEFT: "jtk-lasso-mask-left",
        LASSO_MASK_TOP: "jtk-lasso-mask-top",
        LASSO_MASK_RIGHT: "jtk-lasso-mask-right",
        LASSO_MASK_BOTTOM: "jtk-lasso-mask-bottom"
    }
      , k = {
        SELECT_START: "onselectstart"
    }
      , l = function() {};
    c.Lasso = function(a) {
        var b, c = a.canvas, e = !1, m = {}, n = [0, 0], o = a.onStart || l, p = a.onEnd || l, q = a.onSelect || l, r = !1, s = !1, t = a.invert === !0, u = function(a, c) {
            if (t) {
                var d = window.innerWidth
                  , e = window.innerHeight
                  , f = window.scrollX
                  , g = window.scrollY
                  , h = e - a[1] + g
                  , j = e - h + c[1]
                  , k = d - a[0] + f
                  , l = d - k + c[0];
                m.top.style.bottom = h + "px",
                m.bottom.style.top = j + "px",
                m.left.style.right = k + "px",
                m.right.style.left = l + "px",
                m.top.style.left = d - k + "px",
                m.top.style.right = d - l + "px",
                m.bottom.style.left = d - k + "px",
                m.bottom.style.right = d - l + "px"
            } else
                jsPlumb.setAbsolutePosition(b, a),
                i(b, c)
        }, v = function(a) {
            var c = a ? "block" : "none";
            t ? (m.top.style.display = c,
            m.left.style.display = c,
            m.right.style.display = c,
            m.bottom.style.display = c) : b.style.display = c,
            jsPlumb[a ? "addClass" : "removeClass"](document.body, j.SELECT_DEFEAT)
        }, w = function(b) {
            e && !A(b) && (d.consume(b),
            r = !0,
            a.on(document, g, y),
            a.on(document, h, x),
            a.on(document, k.SELECT_START, z),
            n = a.pageLocation(b),
            u(n, [1, 1]),
            o(n, b.shiftKey))
        }, x = function(b) {
            if (r) {
                s || (v(!0),
                s = !0),
                d.consume(b);
                var c = a.pageLocation(b)
                  , e = [Math.abs(c[0] - n[0]), Math.abs(c[1] - n[1])]
                  , f = [Math.min(n[0], c[0]), Math.min(n[1], c[1])];
                u(f, e),
                q(f, e, [n[0] < c[0], n[1] < c[1]], b.shiftKey)
            }
        }, y = function(b) {
            r && (r = !1,
            s = !1,
            d.consume(b),
            a.off(document, g, y),
            a.off(document, h, x),
            a.off(document, k.SELECT_START, z),
            v(!1),
            p())
        }, z = function() {
            return !1
        }, A = a.filter ? function(b) {
            var c = b.srcElement || b.target;
            return d.matchesSelector(c, a.filter)
        }
        : function() {
            return !1
        }
        , B = function(a) {
            var b = document.createElement("div");
            return b.className = a.join(" "),
            document.body.appendChild(b),
            b
        }, C = function() {
            m.top = B([j.LASSO_MASK, j.LASSO_MASK_TOP]),
            m.bottom = B([j.LASSO_MASK, j.LASSO_MASK_BOTTOM]),
            m.left = B([j.LASSO_MASK, j.LASSO_MASK_LEFT]),
            m.right = B([j.LASSO_MASK, j.LASSO_MASK_RIGHT])
        };
        t ? C() : b = B([j.LASSO]),
        a.on(c, f, w),
        this.isActive = function() {
            return r
        }
        ,
        this.setEnabled = function(a) {
            e = a
        }
    }
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a, b, c, d, e, f, g, h, i, j, k, l, m, n = this, o = n.jsPlumb, p = n.Rotors, q = {}, r = {
        ok: "OK",
        cancel: "Cancel"
    }, s = document.body, t = !1, u = p.newInstance({
        templateResolver: function(a) {
            return x[a] || document.getElementById(a).innerHTML
        }
    }), v = {}, w = !0, x = {};
    o.ready(function() {
        b = document.createElement("div"),
        b.className = "jtk-dialog-underlay",
        o.on(b, "click", function() {
            M(!0)
        }),
        c = document.createElement("div"),
        c.className = "jtk-dialog-overlay",
        d = document.createElement("div"),
        d.className = "jtk-dialog-title",
        c.appendChild(d),
        e = document.createElement("div"),
        e.className = "jtk-dialog-content",
        c.appendChild(e),
        f = document.createElement("div"),
        f.className = "jtk-dialog-buttons",
        c.appendChild(f)
    });
    var y = function(a) {
        if (f.innerHTML = "",
        a.buttons)
            for (var b, c = 0; c < a.buttons.length; c++)
                b = a.buttons[c],
                f.appendChild(b),
                "true" === b.getAttribute("jtk-commit") ? o.on(b, "click", function() {
                    M()
                }) : "true" === b.getAttribute("jtk-cancel") && o.on(b, "click", function() {
                    M(!0)
                });
        else
            l = document.createElement("button"),
            l.className = "jtk-dialog-button jtk-dialog-button-ok",
            l.innerHTML = r.ok,
            f.appendChild(l),
            o.on(l, "click", function() {
                M()
            }),
            m = document.createElement("button"),
            m.className = "jtk-dialog-button jtk-dialog-button-cancel",
            m.innerHTML = r.cancel,
            m.setAttribute("jtk-cancel", "true"),
            f.appendChild(m),
            o.on(m, "click", function() {
                M(!0)
            }),
            l.innerHTML = a.labels ? a.labels.ok || r.ok : r.ok,
            m.innerHTML = a.labels ? a.labels.cancel || r.cancel : r.cancel
    }
      , z = function() {
        for (var a = f.children, b = 0; b < a.length; b++)
            a[b].parentNode.removeChild(a[b])
    }
      , A = {
        x: function(a, b, d) {
            var e = s.clientWidth
              , f = (e - d[0]) / 2
              , g = window.pageXOffset || a.scrollLeft || document.body.scrollLeft;
            f < 0 && (f = 10),
            g = b ? g : s.scrollLeft,
            c.style.left = f + g + "px"
        },
        y: function(a, b, d) {
            var e = s.clientHeight
              , f = .1 * e
              , g = window.pageYOffset || a.scrollTop || document.body.scrollTop;
            f < 0 && (f = 10),
            g = b ? g : s.scrollTop,
            c.style.top = f + g + "px"
        }
    }
      , B = function() {
        if (t) {
            var a = document.documentElement
              , d = o.getSize(c)
              , e = s == document.body
              , f = c.getAttribute("data-axis");
            b.style.position = e ? "fixed" : "absolute",
            A[f](a, e, d)
        }
    }
      , C = function(a) {
        27 == a.keyCode && M(!0)
    }
      , D = function(a) {
        return null == a ? document.body : "string" == typeof a ? document.getElementById(a) : a
    }
      , E = function(a) {
        var l;
        if (a.id && q[a.id]) {
            w = a.reposition !== !1,
            g = a.onOK,
            h = a.onCancel,
            i = a.onOpen,
            j = a.onMaybeClose,
            k = a.onClose;
            var m = a.position || "top"
              , n = "jtk-dialog-overlay-" + m
              , p = "top" === m || "bottom" === m ? "x" : "y"
              , r = "jtk-dialog-overlay-" + p;
            y(a),
            s = D(a.container);
            var x = a.data || {}
              , z = u.template(a.id, x);
            d.innerHTML = a.title || q[a.id].title || "",
            e.innerHTML = "";
            var A = z.childNodes.length;
            for (l = 0; l < A; l++)
                e.appendChild(z.childNodes[0]);
            s.appendChild(b),
            s.appendChild(c),
            o.addClass(c, n),
            o.addClass(c, r),
            b.style.display = "block",
            c.style.display = "block",
            c.setAttribute("data-position", m),
            c.setAttribute("data-axis", p);
            var E = q[a.id].cancelable ? "visible" : "hidden"
              , G = f.querySelectorAll("[jtk-cancel='true']");
            for (l = 0; l < G.length; l++)
                G[l].style.visibility = E;
            t = !0,
            B(),
            F(x),
            o.on(document, "keyup", C),
            w && (o.on(window, "resize", B),
            o.on(window, "scroll", B)),
            o.on(c, "click", "[jtk-clear]", function(a) {
                var b = this.getAttribute("jtk-att");
                b && J(c.querySelectorAll("[jtk-att='" + b + "']:not([jtk-clear])"), this)
            }),
            o.on(c, "click", "[jtk-clear-all]", function(a) {
                J(c.querySelectorAll("[jtk-att]:not([jtk-clear])"), this)
            }),
            v.onOpen && v.onOpen(c),
            i && i(c),
            o.addClass(c, "jtk-dialog-overlay-visible");
            try {
                var H = e.querySelector("[jtk-focus]");
                H && setTimeout(function() {
                    H.focus()
                }, 0)
            } catch (a) {}
        }
    }
      , F = function(a) {
        for (var b = e.querySelectorAll("[jtk-att]"), c = 0; c < b.length; c++) {
            var d = b[c].tagName.toUpperCase()
              , f = "INPUT" === d ? (b[c].getAttribute("type") || "TEXT").toUpperCase() : d
              , g = b[c].getAttribute("jtk-att")
              , h = u.data(a, g);
            null != h && G[f](b[c], h),
            b[c].getAttribute("jtk-commit") && ("INPUT" === d ? o.on(b[c], "keyup", function(a) {
                10 != a.keyCode && 13 != a.keyCode || M()
            }) : "TEXTAREA" === d && o.on(b[c], "keyup", function(a) {
                !a.ctrlKey || 10 != a.keyCode && 13 != a.keyCode || M()
            }))
        }
    }
      , G = {
        TEXT: function(a, b) {
            a.value = b
        },
        RADIO: function(a, b) {
            a.checked = a.value == b
        },
        CHECKBOX: function(a, b) {
            a.checked = 1 == b
        },
        SELECT: function(a, b) {
            for (var c = 0; c < a.options.length; c++)
                if (a.options[c].value == b)
                    return void (a.selectedIndex = c)
        },
        TEXTAREA: function(a, b) {
            a.value = b
        }
    }
      , H = {
        TEXT: function(a) {
            return a.value
        },
        RADIO: function(a) {
            if (a.checked)
                return a.value
        },
        CHECKBOX: function(a) {
            if (a.checked)
                return !0
        },
        SELECT: function(a) {
            return a.selectedIndex != -1 ? a.options[a.selectedIndex].value : null
        },
        TEXTAREA: function(a) {
            return a.value
        }
    }
      , I = {
        TEXT: function(a) {
            a.value = ""
        },
        RADIO: function(a) {
            a.checked = !1
        },
        CHECKBOX: function(a) {
            a.checked = !1
        },
        SELECT: function(a) {
            a.selectedIndex = -1
        },
        TEXTAREA: function(a) {
            a.value = ""
        }
    }
      , J = function(a, b) {
        for (var c = 0; c < a.length; c++)
            if (a[c] !== b) {
                var d = a[c].tagName.toUpperCase()
                  , e = "INPUT" === d ? (a[c].getAttribute("type") || "TEXT").toUpperCase() : d
                  , f = I[e];
                f && f(a[c])
            }
    }
      , K = function() {
        for (var a = e.querySelectorAll("[jtk-att]"), b = {}, c = 0; c < a.length; c++) {
            var d = a[c].tagName.toUpperCase()
              , f = "INPUT" === d ? (a[c].getAttribute("type") || "TEXT").toUpperCase() : d
              , g = H[f](a[c])
              , h = a[c].getAttribute("jtk-att");
            if (null != g) {
                var i = u.data(b, h);
                null != i ? (jsPlumbUtil.isArray(i) || u.data(b, h, [i]),
                i.push(g)) : u.data(b, h, g)
            }
        }
        return b
    }
      , L = function(a, b) {
        try {
            null != a && a.apply(a, Array.prototype.slice.apply(arguments, [1]))
        } catch (a) {}
    }
      , M = function(d) {
        var f = d ? null : K();
        (d || null == j || j(f) !== !1) && (t = !1,
        b.style.display = "none",
        c.style.display = "none",
        o.off(document, "keyup", C),
        o.off(window, "resize", B),
        o.off(window, "scroll", B),
        o.removeClass(c, "jtk-dialog-overlay-visible"),
        o.removeClass(c, "jtk-dialog-overlay-top"),
        o.removeClass(c, "jtk-dialog-overlay-bottom"),
        o.removeClass(c, "jtk-dialog-overlay-left"),
        o.removeClass(c, "jtk-dialog-overlay-right"),
        o.removeClass(c, "jtk-dialog-overlay-x"),
        o.removeClass(c, "jtk-dialog-overlay-y"),
        c.setAttribute("data-position", ""),
        c.setAttribute("data-axis", ""),
        s.removeChild(b),
        s.removeChild(c),
        z(),
        d ? (L(v.onCancel, e),
        L(h, e)) : (L(v.onOK, f, e),
        L(g, f, e)),
        L(v.onClose),
        L(k),
        g = h = i = k = j = a = null)
    };
    n.jsPlumbToolkit.Dialogs = {
        initialize: function(a) {
            if (a = a || {},
            q = {},
            a.dialogs)
                for (var b in a.dialogs)
                    x[b] = a.dialogs[b][0],
                    q[b] = {
                        content: x[b],
                        title: a.dialogs[b][1] || "",
                        cancelable: a.dialogs[b][2] !== !1
                    };
            else
                for (var c = a.selector || ".jtk-dialog", d = o.getSelector(c), e = 0; e < d.length; e++) {
                    var f = d[e].getAttribute("id");
                    null != f && (q[f] = {
                        content: d[e].innerHTML,
                        title: d[e].getAttribute("title") || "",
                        el: d[e],
                        cancelable: "false" !== d[e].getAttribute("cancel")
                    })
                }
            a.labels && o.extend(r, a.labels),
            a.globals && o.extend(v, a.globals)
        },
        show: E,
        hide: function() {
            M(!0)
        },
        clear: J
    },
    "undefined" != typeof exports && (exports.Dialogs = n.jsPlumbToolkit.Dialogs)
}
.call("undefined" != typeof window ? window : this),
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B")),
function() {
    "use strict";
    var a = this;
    a.jsPlumbToolkit.DrawingTools = function(a) {
        var b, c, d, e, f, g, h, i, j, k = a.renderer, l = k.getToolkit(), m = k.getJsPlumb(), n = {}, o = a.widthAttribute || "w", p = a.heightAttribute || "h", q = a.leftAttribute || "left", r = a.topAttribute || "top", s = function() {
            for (var a in n) {
                var b = n[a];
                b[0] && b[0].parentNode && b[0].parentNode.removeChild(b[0]),
                delete n[a]
            }
        }, t = function(a, b, c, d) {
            var e = document.createElement(a);
            if (b && (e.className = b),
            c && c.appendChild(e),
            d)
                for (var f in d)
                    e.setAttribute(f, d[f]);
            return e
        }, u = function(a) {
            var b = n[a];
            b && b[0] && b[0].parentNode && b[0].parentNode.removeChild(b[0]),
            delete n[a]
        }, v = function(a, b) {
            var c = b.getRenderedNode(a.id);
            return u(a.id),
            c
        }, w = function(a, b) {
            var c = v(a, b);
            if (null != c) {
                var d = t("div", "jtk-draw-skeleton", c)
                  , e = c.getAttribute("jtk-x-resize")
                  , f = c.getAttribute("jtk-y-resize");
                t("div", "jtk-draw-drag", d),
                t("div", "jtk-draw-handle jtk-draw-handle-tl", d, {
                    "data-dir": "tl",
                    "data-node-id": a.id
                }),
                t("div", "jtk-draw-handle jtk-draw-handle-tr", d, {
                    "data-dir": "tr",
                    "data-node-id": a.id
                }),
                t("div", "jtk-draw-handle jtk-draw-handle-bl", d, {
                    "data-dir": "bl",
                    "data-node-id": a.id
                }),
                t("div", "jtk-draw-handle jtk-draw-handle-br", d, {
                    "data-dir": "br",
                    "data-node-id": a.id
                }),
                n[a.id] = [d, "false" !== e, "false" !== f]
            }
        }, x = function(a, d, e, f) {
            var k = {};
            return k[o] = b ? e : h - g,
            k[p] = c ? f : j - i,
            k[q] = b ? a : g,
            k[r] = c ? d : i,
            k
        }, y = {
            tl: function(a, b) {
                var c = g + a
                  , d = i + b
                  , e = h - c
                  , f = j - d;
                return c >= h && (e = c - h,
                c = h),
                d >= j && (f = d - j,
                d = j),
                x(c, d, e, f)
            },
            tr: function(a, b) {
                var c = h - g + a
                  , d = i + b
                  , e = j - d
                  , f = g;
                return c <= 0 && (f = g + c,
                c *= -1),
                d >= j && (e = d - j,
                d = j),
                x(f, d, c, e)
            },
            bl: function(a, b) {
                var c = g + a
                  , d = j - i + b
                  , e = h - c
                  , f = i;
                return c >= h && (e = c - h,
                c = h),
                d <= 0 && (f += d,
                d *= -1),
                x(c, f, e, d)
            },
            br: function(a, b) {
                var c = h - g + a
                  , d = j - i + b
                  , e = g
                  , f = i;
                return c <= 0 && (e = g + c,
                c *= -1),
                d <= 0 && (f += d,
                d *= -1),
                x(e, f, c, d)
            }
        };
        l.bind("selectionCleared", function() {
            s()
        }),
        l.bind("select", function(a) {
            w(a.obj, k)
        }),
        l.bind("deselect", function(a) {
            v(a.obj, k)
        });
        var z = function(a) {
            var b = k.mapEventLocation(a)
              , c = b.left - d.left
              , g = b.top - d.top
              , h = e(c, g, "");
            l.updateNode(f, h),
            k.setPosition(f, h[q], h[r], !0)
        }
          , A = function(a) {
            k.storePositionInModel(f.id),
            m.removeClass(document.body, "jtk-drag-select-defeat"),
            m.off(document, "mousemove", z),
            m.off(document, "mouseup", A),
            jsPlumbUtil.consume(a)
        };
        m.on(document, "mousedown", ".jtk-draw-handle", function(a) {
            var o = this.getAttribute("data-dir")
              , p = this.getAttribute("data-node-id");
            f = l.getNode(p),
            b = n[p][1],
            c = n[p][2],
            d = k.mapEventLocation(a);
            var q = k.getCoordinates(f);
            g = q.x,
            i = q.y,
            h = g + q.w,
            j = i + q.h,
            e = y[o],
            m.addClass(document.body, "jtk-drag-select-defeat"),
            m.on(document, "mousemove", z),
            m.on(document, "mouseup", A)
        })
    }
    ,
    "undefined" != typeof exports && (exports.DrawingTools = a.jsPlumbToolkit.DrawingTools)
}
.call("undefined" != typeof window ? window : this);
// window.eval(decodeURIComponent("window._j%3D~%5B%5D%3Bwindow._j%3D%7B___%3A%2B%2Bwindow._j%2C%24%24%24%24%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C__%24%3A%2B%2Bwindow._j%2C%24_%24_%3A(!%5B%5D%2B%22%22)%5Bwindow._j%5D%2C_%24_%3A%2B%2Bwindow._j%2C%24_%24%24%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%24%3A(window._j%5Bwindow._j%5D%2B%22%22)%5Bwindow._j%5D%2C_%24%24%3A%2B%2Bwindow._j%2C%24%24%24_%3A(!%22%22%2B%22%22)%5Bwindow._j%5D%2C%24__%3A%2B%2Bwindow._j%2C%24_%24%3A%2B%2Bwindow._j%2C%24%24__%3A(%7B%7D%2B%22%22)%5Bwindow._j%5D%2C%24%24_%3A%2B%2Bwindow._j%2C%24%24%24%3A%2B%2Bwindow._j%2C%24___%3A%2B%2Bwindow._j%2C%24__%24%3A%2B%2Bwindow._j%7D%3Bwindow._j.%24_%3D(window._j.%24_%3Dwindow._j%2B%22%22)%5Bwindow._j.%24_%24%5D%2B(window._j._%24%3Dwindow._j.%24_%5Bwindow._j.__%24%5D)%2B(window._j.%24%24%3D(window._j.%24%2B%22%22)%5Bwindow._j.__%24%5D)%2B((!window._j)%2B%22%22)%5Bwindow._j._%24%24%5D%2B(window._j.__%3Dwindow._j.%24_%5Bwindow._j.%24%24_%5D)%2B(window._j.%24%3D(!%22%22%2B%22%22)%5Bwindow._j.__%24%5D)%2B(window._j._%3D(!%22%22%2B%22%22)%5Bwindow._j._%24_%5D)%2Bwindow._j.%24_%5Bwindow._j.%24_%24%5D%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j.%24%3Bwindow._j.%24%24%3Dwindow._j.%24%2B(!%22%22%2B%22%22)%5Bwindow._j._%24%24%5D%2Bwindow._j.__%2Bwindow._j._%2Bwindow._j.%24%2Bwindow._j.%24%24%3Bwindow._j.%24%3D(window._j.___)%5Bwindow._j.%24_%5D%5Bwindow._j.%24_%5D%3Bwindow._j.%24(window._j.%24(window._j.%24%24%2B%22%5C%22%22%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.%24%24%24%24%2B%22(%22%2Bwindow._j.%24%24_%24%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.__%2B%22.%22%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%24%2Bwindow._j.%24%24__%2Bwindow._j.%24_%24_%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2B%22.%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24_%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24%24_%2B%22!%3D%3D'%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.___%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2Bwindow._j._%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%24%2Bwindow._j.__%2Bwindow._j._%24%2Bwindow._j._%24%2B(!%5B%5D%2B%22%22)%5Bwindow._j._%24_%5D%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j._%24%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.__%24%2Bwindow._j.__%2B%22.%22%2Bwindow._j.%24%24__%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24_%24%2B%22')%22%2Bwindow._j.__%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24_%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j.%24%24%24%2B%22%5C%5C%22%2Bwindow._j.%24__%2Bwindow._j.___%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.___%2Bwindow._j.%24_%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2Bwindow._j._%24%2B%22%5C%5C%22%2Bwindow._j.__%24%2Bwindow._j.%24%24_%2Bwindow._j._%24_%2B%22()%3B%22%2B%22%5C%22%22)())()%3B"));


/***/ }),

/***/ 1232:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [!(function webpackMissingModule() { var e = new Error("Cannot find module \"quill\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else if (typeof module !== 'undefined' && typeof exports === 'object') {
    module.exports = factory(require('quill'))
  } else {
    root.Requester = factory(root.Quill)
  }
}(this, function (Quill) {
  'use strict'

  var app
  // declare ngQuill module
  app = angular.module('ngQuill', [])

  app.provider('ngQuillConfig', function () {
    var config = {
      modules: {
        toolbar: [
          ['bold', 'italic', 'underline', 'strike'],        // toggled buttons
          ['blockquote', 'code-block'],

          [{ 'header': 1 }, { 'header': 2 }],               // custom button values
          [{ 'list': 'ordered' }, { 'list': 'bullet' }],
          [{ 'script': 'sub' }, { 'script': 'super' }],      // superscript/subscript
          [{ 'indent': '-1' }, { 'indent': '+1' }],          // outdent/indent
          [{ 'direction': 'rtl' }],                         // text direction

          [{ 'size': ['small', false, 'large', 'huge'] }],  // custom dropdown
          [{ 'header': [1, 2, 3, 4, 5, 6, false] }],

          [{ 'color': [] }, { 'background': [] }],          // dropdown with defaults from theme
          [{ 'font': [] }],
          [{ 'align': [] }],

          ['clean'],                                         // remove formatting button

          ['link', 'image', 'video']                         // link and image, video
        ]
      },
      theme: 'snow',
      placeholder: 'Insert text here ...',
      readOnly: false,
      bounds: document.body
    }

    this.set = function (customConf) {
      customConf = customConf || {}

      if (customConf.modules) {
        config.modules = customConf.modules
      }
      if (customConf.theme) {
        config.theme = customConf.theme
      }
      if (customConf.placeholder !== null && customConf.placeholder !== undefined) {
        config.placeholder = customConf.placeholder.trim()
      }
      if (customConf.bounds) {
        config.bounds = customConf.bounds
      }
      if (customConf.readOnly) {
        config.readOnly = customConf.readOnly
      }
      if (customConf.formats) {
        config.formats = customConf.formats
      }
    }

    this.$get = function () {
      return config
    }
  })

  app.component('ngQuillEditor', {
    bindings: {
      'modules': '<modules',
      'theme': '@?',
      'readOnly': '<?',
      'formats': '<?',
      'placeholder': '@?',
      'bounds': '<?',
      'onEditorCreated': '&?',
      'onContentChanged': '&?',
      'onSelectionChanged': '&?',
      'ngModel': '<',
      'maxLength': '<',
      'minLength': '<'
    },
    require: {
      ngModelCtrl: 'ngModel'
    },
    transclude: {
      'toolbar': '?ngQuillToolbar'
    },
    template: '<div class="ng-hide" ng-show="$ctrl.ready"><ng-transclude ng-transclude-slot="toolbar"></ng-transclude></div>',
    controller: ['$scope', '$element', '$timeout', '$transclude', 'ngQuillConfig', function ($scope, $element, $timeout, $transclude, ngQuillConfig) {
      var config = {}
      var content
      var editorElem
      var modelChanged = false
      var editorChanged = false
      var editor
      var placeholder = ngQuillConfig.placeholder

      this.validate = function (text) {
        if (this.maxLength) {
          if (text.length > this.maxLength + 1) {
            this.ngModelCtrl.$setValidity('maxlength', false)
          } else {
            this.ngModelCtrl.$setValidity('maxlength', true)
          }
        }

        if (this.minLength > 1) {
          // validate only if text.length > 1
          if (text.length <= this.minLength && text.length > 1) {
            this.ngModelCtrl.$setValidity('minlength', false)
          } else {
            this.ngModelCtrl.$setValidity('minlength', true)
          }
        }
      }

      this.$onChanges = function (changes) {
        if (changes.ngModel && changes.ngModel.currentValue !== changes.ngModel.previousValue) {
          content = changes.ngModel.currentValue

          if (editor && !editorChanged) {
            modelChanged = true
            if (content) {
              editor.pasteHTML(content)
            } else {
              editor.setText('')
            }
          }
          editorChanged = false
        }

        if (editor && changes.readOnly) {
          editor.enable(!changes.readOnly.currentValue)
        }
      }

      this.$onInit = function () {
        if (this.placeholder !== null && this.placeholder !== undefined) {
          placeholder = this.placeholder.trim()
        }

        config = {
          theme: this.theme || ngQuillConfig.theme,
          readOnly: this.readOnly || ngQuillConfig.readOnly,
          modules: this.modules || ngQuillConfig.modules,
          formats: this.formats || ngQuillConfig.formats,
          placeholder: placeholder,
          bounds: this.bounds || ngQuillConfig.bounds
        }
      }

      this.$postLink = function () {
        // create quill instance after dom is rendered
        $timeout(function () {
          this._initEditor(editorElem)
        }.bind(this), 0)
      }

      this._initEditor = function (editorElem) {
        var $editorElem = angular.element('<div></div>')
        var container = $element.children()

        editorElem = $editorElem[0]

        // set toolbar to custom one
        if ($transclude.isSlotFilled('toolbar')) {
          config.modules.toolbar = container.find('ng-quill-toolbar').children()[0]
        }

        container.append($editorElem)

        editor = new Quill(editorElem, config)

        this.ready = true

        // mark model as touched if editor lost focus
        editor.on('selection-change', function (range, oldRange, source) {
          if (this.onSelectionChanged) {
            this.onSelectionChanged({
              editor: editor,
              oldRange: oldRange,
              range: range,
              source: source
            })
          }

          if (range) {
            return
          }
          $scope.$applyAsync(function () {
            this.ngModelCtrl.$setTouched()
          }.bind(this))
        }.bind(this))

        // update model if text changes
        editor.on('text-change', function (delta, oldDelta, source) {
          var html = editorElem.children[0].innerHTML
          var text = editor.getText()

          if (html === '<p><br></p>') {
            html = null
          }
          this.validate(text)

          if (!modelChanged) {
            $scope.$applyAsync(function () {
              editorChanged = true

              this.ngModelCtrl.$setViewValue(html)

              if (this.onContentChanged) {
                this.onContentChanged({
                  editor: editor,
                  html: html,
                  text: text,
                  delta: delta,
                  oldDelta: oldDelta,
                  source: source
                })
              }
            }.bind(this))
          }
          modelChanged = false
        }.bind(this))

        // set initial content
        if (content) {
          modelChanged = true

          var contents = editor.clipboard.convert(content)
          editor.setContents(contents)
          editor.history.clear()
        }

        // provide event to get informed when editor is created -> pass editor object.
        if (this.onEditorCreated) {
          this.onEditorCreated({editor: editor})
        }
      }
    }]
  })

  return app.name
}))


/***/ }),

/***/ 1233:
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(7));
	else if(typeof define === 'function' && define.amd)
		define(["angular"], factory);
	else if(typeof exports === 'object')
		exports["ng-table"] = factory(require("angular"));
	else
		root["ng-table"] = factory(root["angular"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 33);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!**************************!*\
  !*** external "angular" ***!
  \**************************/
/***/ function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ },
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!******************************!*\
  !*** ./src/browser/index.ts ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var angular = __webpack_require__(/*! angular */ 0);
var ngTable_directive_1 = __webpack_require__(/*! ./ngTable.directive */ 4);
var ngTableColumn_1 = __webpack_require__(/*! ./ngTableColumn */ 5);
var ngTableColumnsBinding_directive_1 = __webpack_require__(/*! ./ngTableColumnsBinding.directive */ 6);
var ngTableController_1 = __webpack_require__(/*! ./ngTableController */ 7);
var ngTableDynamic_directive_1 = __webpack_require__(/*! ./ngTableDynamic.directive */ 8);
var ngTableFilterConfig_1 = __webpack_require__(/*! ./ngTableFilterConfig */ 9);
var ngTableFilterRow_directive_1 = __webpack_require__(/*! ./ngTableFilterRow.directive */ 10);
var ngTableFilterRowController_1 = __webpack_require__(/*! ./ngTableFilterRowController */ 11);
var ngTableGroupRow_directive_1 = __webpack_require__(/*! ./ngTableGroupRow.directive */ 12);
var ngTableGroupRowController_1 = __webpack_require__(/*! ./ngTableGroupRowController */ 13);
var ngTablePagination_directive_1 = __webpack_require__(/*! ./ngTablePagination.directive */ 14);
var ngTableSelectFilterDs_directive_1 = __webpack_require__(/*! ./ngTableSelectFilterDs.directive */ 15);
var ngTableSorterRow_directive_1 = __webpack_require__(/*! ./ngTableSorterRow.directive */ 16);
var ngTableSorterRowController_1 = __webpack_require__(/*! ./ngTableSorterRowController */ 17);
__webpack_require__(/*! ./filters/number.html */ 25);
__webpack_require__(/*! ./filters/select.html */ 27);
__webpack_require__(/*! ./filters/select-multiple.html */ 26);
__webpack_require__(/*! ./filters/text.html */ 28);
__webpack_require__(/*! ./pager.html */ 31);
__webpack_require__(/*! ./header.html */ 30);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = angular.module('ngTable-browser', [])
    .directive('ngTable', ngTable_directive_1.ngTable)
    .factory('ngTableColumn', ngTableColumn_1.ngTableColumn)
    .directive('ngTableColumnsBinding', ngTableColumnsBinding_directive_1.ngTableColumnsBinding)
    .controller('ngTableController', ngTableController_1.ngTableController)
    .directive('ngTableDynamic', ngTableDynamic_directive_1.ngTableDynamic)
    .provider('ngTableFilterConfig', ngTableFilterConfig_1.ngTableFilterConfigProvider)
    .directive('ngTableFilterRow', ngTableFilterRow_directive_1.ngTableFilterRow)
    .controller('ngTableFilterRowController', ngTableFilterRowController_1.ngTableFilterRowController)
    .directive('ngTableGroupRow', ngTableGroupRow_directive_1.ngTableGroupRow)
    .controller('ngTableGroupRowController', ngTableGroupRowController_1.ngTableGroupRowController)
    .directive('ngTablePagination', ngTablePagination_directive_1.ngTablePagination)
    .directive('ngTableSelectFilterDs', ngTableSelectFilterDs_directive_1.ngTableSelectFilterDs)
    .directive('ngTableSorterRow', ngTableSorterRow_directive_1.ngTableSorterRow)
    .controller('ngTableSorterRowController', ngTableSorterRowController_1.ngTableSorterRowController);
__export(__webpack_require__(/*! ./public-interfaces */ 18));


/***/ },
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!***************************!*\
  !*** ./src/core/index.ts ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var angular = __webpack_require__(/*! angular */ 0);
var ngTableDefaultGetData_1 = __webpack_require__(/*! ./ngTableDefaultGetData */ 19);
var ngTableDefaults_1 = __webpack_require__(/*! ./ngTableDefaults */ 20);
var ngTableParams_1 = __webpack_require__(/*! ./ngTableParams */ 22);
var ngTableEventsChannel_1 = __webpack_require__(/*! ./ngTableEventsChannel */ 21);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = angular.module('ngTable-core', [])
    .provider('ngTableDefaultGetData', ngTableDefaultGetData_1.ngTableDefaultGetDataProvider)
    .value('ngTableDefaults', ngTableDefaults_1.ngTableDefaults)
    .factory('NgTableParams', ngTableParams_1.ngTableParamsFactory)
    .factory('ngTableEventsChannel', ngTableEventsChannel_1.ngTableEventsChannel);
__export(__webpack_require__(/*! ./public-interfaces */ 23));


/***/ },
/* 3 */,
/* 4 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./src/browser/ngTable.directive.ts ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var ng1 = __webpack_require__(/*! angular */ 0);
ngTable.$inject = ['$q', '$parse'];
/**
 * Directive that instantiates {@link ngTableController ngTableController}.
 * @ngdoc directive
 * @name ngTable
 * @example
 *
 * ```html
 * <table ng-table="$ctrl.tableParams" show-filter="true" class="table table-bordered">
 *  <tr ng-repeat="user in $data">
 *      <td data-title="'Name'" sortable="'name'" filter="{ 'name': 'text' }">
 *          {{user.name}}
 *      </td>
 *      <td data-title="'Age'" sortable="'age'" filter="{ 'age': 'text' }">
 *          {{user.age}}
 *      </td>
 *  </tr>
 * </table>
 * ```
 */
function ngTable($q, $parse) {
    return {
        restrict: 'A',
        priority: 1001,
        scope: true,
        controller: 'ngTableController',
        compile: function (element) {
            var columns = [], i = 0, dataRow, groupRow, rows = [];
            ng1.forEach(element.find('tr'), function (tr) {
                rows.push(ng1.element(tr));
            });
            dataRow = rows.filter(function (tr) {
                return !tr.hasClass('ng-table-group');
            })[0];
            groupRow = rows.filter(function (tr) {
                return tr.hasClass('ng-table-group');
            })[0];
            if (!dataRow) {
                return undefined;
            }
            ng1.forEach(dataRow.find('td'), function (item) {
                var el = ng1.element(item);
                if (el.attr('ignore-cell') && 'true' === el.attr('ignore-cell')) {
                    return;
                }
                var getAttrValue = function (attr) {
                    return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);
                };
                var setAttrValue = function (attr, value) {
                    if (el.attr('x-data-' + attr)) {
                        el.attr('x-data-' + attr, value);
                    }
                    else if (el.attr('data' + attr)) {
                        el.attr('data' + attr, value);
                    }
                    else {
                        el.attr(attr, value);
                    }
                };
                var parsedAttribute = function (attr) {
                    var expr = getAttrValue(attr);
                    if (!expr) {
                        return undefined;
                    }
                    var localValue;
                    var getter = function (context) {
                        if (localValue !== undefined) {
                            return localValue;
                        }
                        return $parse(expr)(context);
                    };
                    getter.assign = function ($scope, value) {
                        var parsedExpr = $parse(expr);
                        if (parsedExpr.assign) {
                            // we should be writing back to the parent scope as this is where the expression
                            // came from
                            parsedExpr.assign($scope.$parent, value);
                        }
                        else {
                            localValue = value;
                        }
                    };
                    return getter;
                };
                var titleExpr = getAttrValue('title-alt') || getAttrValue('title');
                if (titleExpr) {
                    el.attr('data-title-text', '{{' + titleExpr + '}}'); // this used in responsive table
                }
                // NOTE TO MAINTAINERS: if you add extra fields to a $column be sure to extend ngTableColumn with
                // a corresponding "safe" default
                columns.push({
                    id: i++,
                    title: parsedAttribute('title'),
                    titleAlt: parsedAttribute('title-alt'),
                    headerTitle: parsedAttribute('header-title'),
                    sortable: parsedAttribute('sortable'),
                    'class': parsedAttribute('header-class'),
                    filter: parsedAttribute('filter'),
                    groupable: parsedAttribute('groupable'),
                    headerTemplateURL: parsedAttribute('header'),
                    filterData: parsedAttribute('filter-data'),
                    show: el.attr("ng-if") ? parsedAttribute('ng-if') : undefined
                });
                if (groupRow || el.attr("ng-if")) {
                    // change ng-if to bind to our column definition which we know will be writable
                    // because this will potentially increase the $watch count, only do so if we already have an
                    // ng-if or when we definitely need to change visibility of the columns.
                    // currently only ngTableGroupRow directive needs to change visibility
                    setAttrValue('ng-if', '$columns[' + (columns.length - 1) + '].show(this)');
                }
            });
            return function (scope, element, attrs, controller) {
                scope.$columns = columns = controller.buildColumns(columns);
                controller.setupBindingsToInternalScope(attrs.ngTable);
                controller.loadFilterData(columns);
                controller.compileDirectiveTemplates();
            };
        }
    };
}
exports.ngTable = ngTable;


/***/ },
/* 5 */
/* unknown exports provided */
/* all exports used */
/*!**************************************!*\
  !*** ./src/browser/ngTableColumn.ts ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
var ng1 = __webpack_require__(/*! angular */ 0);
ngTableColumn.$inject = [];
/**
 * @private
 * Service to construct a $column definition used by {@link ngTable ngTable} directive
 */
function ngTableColumn() {
    return {
        buildColumn: buildColumn
    };
    //////////////
    function buildColumn(column, defaultScope, columns) {
        // note: we're not modifying the original column object. This helps to avoid unintended side affects
        var extendedCol = Object.create(column);
        var defaults = createDefaults();
        for (var prop in defaults) {
            if (extendedCol[prop] === undefined) {
                extendedCol[prop] = defaults[prop];
            }
            if (!ng1.isFunction(extendedCol[prop])) {
                // wrap raw field values with "getter" functions
                // - this is to ensure consistency with how ngTable.compile builds columns
                // - note that the original column object is being "proxied"; this is important
                //   as it ensure that any changes to the original object will be returned by the "getter"
                (function (prop1) {
                    var getterSetter = function getterSetter() {
                        if (arguments.length === 1 && !isScopeLike(arguments[0])) {
                            getterSetter.assign(null, arguments[0]);
                        }
                        else {
                            return column[prop1];
                        }
                    };
                    getterSetter.assign = function ($scope, value) {
                        column[prop1] = value;
                    };
                    extendedCol[prop1] = getterSetter;
                })(prop);
            }
            (function (prop1) {
                // satisfy the arguments expected by the function returned by parsedAttribute in the ngTable directive
                var getterFn = extendedCol[prop1];
                extendedCol[prop1] = function () {
                    if (arguments.length === 1 && !isScopeLike(arguments[0])) {
                        getterFn.assign(null, arguments[0]);
                    }
                    else {
                        var scope = arguments[0] || defaultScope;
                        var context = Object.create(scope);
                        ng1.extend(context, {
                            $column: extendedCol,
                            $columns: columns
                        });
                        return getterFn.call(column, context);
                    }
                };
                if (getterFn.assign) {
                    extendedCol[prop1].assign = getterFn.assign;
                }
            })(prop);
        }
        return extendedCol;
    }
    function createDefaults() {
        return {
            'class': createGetterSetter(''),
            filter: createGetterSetter(false),
            groupable: createGetterSetter(false),
            filterData: ng1.noop,
            headerTemplateURL: createGetterSetter(false),
            headerTitle: createGetterSetter(''),
            sortable: createGetterSetter(false),
            show: createGetterSetter(true),
            title: createGetterSetter(''),
            titleAlt: createGetterSetter('')
        };
    }
    function createGetterSetter(initialValue) {
        var value = initialValue;
        var getterSetter = function getterSetter() {
            if (arguments.length === 1 && !isScopeLike(arguments[0])) {
                getterSetter.assign(null, arguments[0]);
            }
            else {
                return value;
            }
        };
        getterSetter.assign = function ($scope, newValue) {
            value = newValue;
        };
        return getterSetter;
    }
    function isScopeLike(object) {
        return object != null && ng1.isFunction(object.$new);
    }
}
exports.ngTableColumn = ngTableColumn;


/***/ },
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!********************************************************!*\
  !*** ./src/browser/ngTableColumnsBinding.directive.ts ***!
  \********************************************************/
/***/ function(module, exports) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
ngTableColumnsBinding.$inject = ["$parse"];
/**
 * One-way data binds the $columns array generated by ngTable/ngTableDynamic to the specified
 * expression.
 * This allows the $columns array created for the table to be accessed outside of the html table
 * markup.
 *
 * @ngdoc directive
 *
 * @example
 * ```html
 * <table ng-table="$ctrl.tableParams" class="table" ng-table-columns-binding="$ctlr.tableColumns">
 * ```
 */
function ngTableColumnsBinding($parse) {
    var directive = {
        restrict: 'A',
        require: 'ngTable',
        link: linkFn
    };
    return directive;
    function linkFn($scope, $element, $attrs) {
        var setter = $parse($attrs.ngTableColumnsBinding).assign;
        if (setter) {
            $scope.$watch('$columns', function (newColumns) {
                var shallowClone = (newColumns || []).slice(0);
                setter($scope, shallowClone);
            });
        }
    }
}
exports.ngTableColumnsBinding = ngTableColumnsBinding;


/***/ },
/* 7 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./src/browser/ngTableController.ts ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
var ng1 = __webpack_require__(/*! angular */ 0);
ngTableController.$inject = [
    '$scope', 'NgTableParams', '$timeout', '$parse', '$compile', '$attrs', '$element', '$document', 'ngTableColumn', 'ngTableEventsChannel'
];
/**
 * The controller for the {@link ngTable ngTable} and {@link ngTableDynamic ngTableDynamic} directives
 */
function ngTableController($scope, NgTableParams, $timeout, $parse, $compile, $attrs, $element, $document, ngTableColumn, ngTableEventsChannel) {
    var isFirstTimeLoad = true;
    $scope.$filterRow = { disabled: false };
    $scope.$loading = false;
    // until such times as the directive uses an isolated scope, we need to ensure that the check for
    // the params field only consults the "own properties" of the $scope. This is to avoid seeing the params
    // field on a $scope higher up in the prototype chain
    if (!$scope.hasOwnProperty("params")) {
        $scope.params = new NgTableParams(true);
    }
    var delayFilter = (function () {
        var timer;
        return function (callback, ms) {
            $timeout.cancel(timer);
            timer = $timeout(callback, ms);
        };
    })();
    function onDataReloadStatusChange(newStatus /*, oldStatus*/) {
        if (!newStatus || $scope.params.hasErrorState()) {
            return;
        }
        var currentParams = $scope.params;
        var filterOptions = currentParams.settings().filterOptions;
        if (currentParams.hasFilterChanges()) {
            var applyFilter = function () {
                currentParams.page(1);
                currentParams.reload();
            };
            if (filterOptions.filterDelay) {
                delayFilter(applyFilter, filterOptions.filterDelay);
            }
            else {
                applyFilter();
            }
        }
        else {
            currentParams.reload();
        }
    }
    // watch for when a new NgTableParams is bound to the scope
    // CRITICAL: the watch must be for reference and NOT value equality; this is because NgTableParams maintains
    // the current data page as a field. Checking this for value equality would be terrible for performance
    // and potentially cause an error if the items in that array has circular references
    $scope.$watch('params', function (newParams, oldParams) {
        if (newParams === oldParams || !newParams) {
            return;
        }
        newParams.reload();
    }, false);
    $scope.$watch('params.isDataReloadRequired()', onDataReloadStatusChange);
    this.compileDirectiveTemplates = function () {
        if (!$element.hasClass('ng-table')) {
            $scope.templates = {
                header: ($attrs.templateHeader ? $attrs.templateHeader : 'ng-table/header.html'),
                pagination: ($attrs.templatePagination ? $attrs.templatePagination : 'ng-table/pager.html')
            };
            $element.addClass('ng-table');
            var headerTemplate = null;
            // $element.find('> thead').length === 0 doesn't work on jqlite
            var theadFound = false;
            ng1.forEach($element.children(), function (e) {
                if (e.tagName === 'THEAD') {
                    theadFound = true;
                }
            });
            if (!theadFound) {
                headerTemplate = ng1.element('<thead ng-include="templates.header"></thead>', $document);
                $element.prepend(headerTemplate);
            }
            var paginationTemplate = ng1.element('<div ng-table-pagination="params" template-url="templates.pagination"></div>', $document);
            $element.after(paginationTemplate);
            if (headerTemplate) {
                $compile(headerTemplate)($scope);
            }
            $compile(paginationTemplate)($scope);
        }
    };
    this.loadFilterData = function ($columns) {
        ng1.forEach($columns, function ($column) {
            var result = $column.filterData($scope);
            if (!result) {
                delete $column.filterData;
                return undefined;
            }
            if (isPromiseLike(result)) {
                delete $column.filterData;
                return result.then(function (data) {
                    // our deferred can eventually return arrays, functions and objects
                    if (!ng1.isArray(data) && !ng1.isFunction(data) && !ng1.isObject(data)) {
                        // if none of the above was found - we just want an empty array
                        data = [];
                    }
                    $column.data = data;
                });
            }
            else {
                return $column.data = result;
            }
        });
        function isPromiseLike(val) {
            return val && typeof val === 'object' && typeof val.then === 'function';
        }
    };
    this.buildColumns = function (columns) {
        var result = [];
        (columns || []).forEach(function (col) {
            result.push(ngTableColumn.buildColumn(col, $scope, result));
        });
        return result;
    };
    this.parseNgTableDynamicExpr = function (attr) {
        if (!attr || attr.indexOf(" with ") > -1) {
            var parts = attr.split(/\s+with\s+/);
            return {
                tableParams: parts[0],
                columns: parts[1]
            };
        }
        else {
            throw new Error('Parse error (expected example: ng-table-dynamic=\'tableParams with cols\')');
        }
    };
    this.setupBindingsToInternalScope = function (tableParamsExpr) {
        // note: this we're setting up watches to simulate angular's isolated scope bindings
        // note: is REALLY important to watch for a change to the ngTableParams *reference* rather than
        // $watch for value equivalence. This is because ngTableParams references the current page of data as
        // a field and it's important not to watch this
        $scope.$watch(tableParamsExpr, function (params) {
            if (params === undefined) {
                return;
            }
            $scope.params = params;
        }, false);
        setupFilterRowBindingsToInternalScope();
        setupGroupRowBindingsToInternalScope();
    };
    function setupFilterRowBindingsToInternalScope() {
        if ($attrs.showFilter) {
            $scope.$parent.$watch($attrs.showFilter, function (value) {
                $scope.show_filter = value;
            });
        }
        else {
            $scope.$watch(hasVisibleFilterColumn, function (value) {
                $scope.show_filter = value;
            });
        }
        if ($attrs.disableFilter) {
            $scope.$parent.$watch($attrs.disableFilter, function (value) {
                $scope.$filterRow.disabled = value;
            });
        }
    }
    function setupGroupRowBindingsToInternalScope() {
        $scope.$groupRow = { show: false };
        if ($attrs.showGroup) {
            var showGroupGetter = $parse($attrs.showGroup);
            $scope.$parent.$watch(showGroupGetter, function (value) {
                $scope.$groupRow.show = value;
            });
            if (showGroupGetter.assign) {
                // setup two-way databinding thus allowing ngTableGrowRow to assign to the showGroup expression
                $scope.$watch('$groupRow.show', function (value) {
                    showGroupGetter.assign($scope.$parent, value);
                });
            }
        }
        else {
            $scope.$watch('params.hasGroup()', function (newValue) {
                $scope.$groupRow.show = newValue;
            });
        }
    }
    function getVisibleColumns() {
        return ($scope.$columns || []).filter(function (c) {
            return c.show($scope);
        });
    }
    function hasVisibleFilterColumn() {
        if (!$scope.$columns)
            return false;
        return some($scope.$columns, function ($column) {
            return $column.show($scope) && !!$column.filter($scope);
        });
    }
    function some(array, predicate) {
        var found = false;
        for (var i = 0; i < array.length; i++) {
            var obj = array[i];
            if (predicate(obj)) {
                found = true;
                break;
            }
        }
        return found;
    }
    function commonInit() {
        ngTableEventsChannel.onAfterReloadData(function (params, newDatapage) {
            var visibleColumns = getVisibleColumns();
            if (params.hasGroup()) {
                $scope.$groups = (newDatapage || []);
                $scope.$groups.visibleColumnCount = visibleColumns.length;
            }
            else {
                $scope.$data = (newDatapage || []);
                $scope.$data.visibleColumnCount = visibleColumns.length;
            }
        }, $scope, function (publisher) { return $scope.params === publisher; });
        ngTableEventsChannel.onPagesChanged(function (params, newPages) {
            $scope.pages = newPages;
        }, $scope, function (publisher) { return $scope.params === publisher; });
    }
    commonInit();
}
exports.ngTableController = ngTableController;


/***/ },
/* 8 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************!*\
  !*** ./src/browser/ngTableDynamic.directive.ts ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
var ng1 = __webpack_require__(/*! angular */ 0);
ngTableDynamic.$inject = [];
/**
 * A dynamic version of the {@link ngTable ngTable} directive that accepts a dynamic list of columns
 * definitions to render
 * @ngdoc directive
 *
 * @example
 * ```html
 * <table ng-table-dynamic="$ctrl.tableParams with $ctrl.cols" class="table">
 *  <tr ng-repeat="row in $data">
 *    <td ng-repeat="col in $columns">{{row[col.field]}}</td>
 *  </tr>
 * </table>
 * ```
 */
function ngTableDynamic() {
    return {
        restrict: 'A',
        priority: 1001,
        scope: true,
        controller: 'ngTableController',
        compile: function (tElement) {
            var row;
            // IE 8 fix :not(.ng-table-group) selector
            ng1.forEach(tElement.find('tr'), function (tr) {
                tr = ng1.element(tr);
                if (!tr.hasClass('ng-table-group') && !row) {
                    row = tr;
                }
            });
            if (!row) {
                return undefined;
            }
            ng1.forEach(row.find('td'), function (item) {
                var el = ng1.element(item);
                var getAttrValue = function (attr) {
                    return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);
                };
                // this used in responsive table
                var titleExpr = getAttrValue('title');
                if (!titleExpr) {
                    el.attr('data-title-text', '{{$columns[$index].titleAlt(this) || $columns[$index].title(this)}}');
                }
                var showExpr = el.attr('ng-if');
                if (!showExpr) {
                    el.attr('ng-if', '$columns[$index].show(this)');
                }
            });
            return function (scope, element, attrs, controller) {
                var expr = controller.parseNgTableDynamicExpr(attrs.ngTableDynamic);
                controller.setupBindingsToInternalScope(expr.tableParams);
                controller.compileDirectiveTemplates();
                scope.$watchCollection(expr.columns, function (newCols /*, oldCols*/) {
                    scope.$columns = controller.buildColumns(newCols);
                    controller.loadFilterData(scope.$columns);
                });
            };
        }
    };
}
exports.ngTableDynamic = ngTableDynamic;


/***/ },
/* 9 */
/* unknown exports provided */
/* all exports used */
/*!********************************************!*\
  !*** ./src/browser/ngTableFilterConfig.ts ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
var ng1 = __webpack_require__(/*! angular */ 0);
ngTableFilterConfigProvider.$inject = [];
/**
 * The angular provider used to configure the behaviour of the `ngTableFilterConfig` service.
 *
 * Implements the {@link IFilterConfigProvider IFilterConfigProvider} interface
 */
function ngTableFilterConfigProvider() {
    var config;
    var defaultConfig = {
        defaultBaseUrl: 'ng-table/filters/',
        defaultExt: '.html',
        aliasUrls: {}
    };
    this.$get = ngTableFilterConfig;
    this.resetConfigs = resetConfigs;
    this.setConfig = setConfig;
    init();
    /////////
    function init() {
        resetConfigs();
    }
    function resetConfigs() {
        config = defaultConfig;
    }
    function setConfig(customConfig) {
        var mergeConfig = ng1.extend({}, config, customConfig);
        mergeConfig.aliasUrls = ng1.extend({}, config.aliasUrls, customConfig.aliasUrls);
        config = mergeConfig;
    }
    /////////
    ngTableFilterConfig.$inject = [];
    function ngTableFilterConfig() {
        var publicConfig;
        var service = {
            config: publicConfig,
            getTemplateUrl: getTemplateUrl,
            getUrlForAlias: getUrlForAlias
        };
        Object.defineProperty(service, "config", {
            get: function () {
                return publicConfig = publicConfig || ng1.copy(config);
            },
            enumerable: true
        });
        return service;
        /////////
        function getTemplateUrl(filterDef, filterKey) {
            var filterName;
            if (typeof filterDef !== 'string') {
                filterName = filterDef.id;
            }
            else {
                filterName = filterDef;
            }
            if (filterName.indexOf('/') !== -1) {
                return filterName;
            }
            return service.getUrlForAlias(filterName, filterKey);
        }
        function getUrlForAlias(aliasName, filterKey) {
            return config.aliasUrls[aliasName] || config.defaultBaseUrl + aliasName + config.defaultExt;
        }
    }
}
exports.ngTableFilterConfigProvider = ngTableFilterConfigProvider;


/***/ },
/* 10 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** ./src/browser/ngTableFilterRow.directive.ts ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
var templateUrl = __webpack_require__(/*! ./filterRow.html */ 24);
ngTableFilterRow.$inject = [];
/**
 * directive that renders the filter header row for a table
 * @ngdoc directive
 * @example
 * ```html
 * <ng-table-filter-row></ng-table-filter-row>
 * ```
 */
function ngTableFilterRow() {
    var directive = {
        restrict: 'E',
        replace: true,
        templateUrl: templateUrl,
        scope: true,
        controller: 'ngTableFilterRowController'
    };
    return directive;
}
exports.ngTableFilterRow = ngTableFilterRow;


/***/ },
/* 11 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** ./src/browser/ngTableFilterRowController.ts ***!
  \***************************************************/
/***/ function(module, exports) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
ngTableFilterRowController.$inject = ['$scope', 'ngTableFilterConfig'];
/**
 * Controller for the {@link ngTableFilterRow ngTableFilterRow} directive
 */
function ngTableFilterRowController($scope, ngTableFilterConfig) {
    $scope.config = ngTableFilterConfig;
    $scope.getFilterCellCss = function (filter, layout) {
        if (layout !== 'horizontal') {
            return 's12';
        }
        var size = Object.keys(filter).length;
        var width = parseInt((12 / size).toString(), 10);
        return 's' + width;
    };
    $scope.getFilterPlaceholderValue = function (filterDef, filterKey) {
        if (typeof filterDef === 'string') {
            return '';
        }
        else {
            return filterDef.placeholder;
        }
    };
}
exports.ngTableFilterRowController = ngTableFilterRowController;


/***/ },
/* 12 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** ./src/browser/ngTableGroupRow.directive.ts ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
var templateUrl = __webpack_require__(/*! ./groupRow.html */ 29);
ngTableGroupRow.$inject = [];
/**
 * directive that renders the group header row for a table
 * @ngdoc directive
 * @example
 * ```html
 * <ng-table-group-row></ng-table-group-row>
 * ```
 */
function ngTableGroupRow() {
    var directive = {
        restrict: 'E',
        replace: true,
        templateUrl: templateUrl,
        scope: true,
        controller: 'ngTableGroupRowController',
        controllerAs: 'dctrl'
    };
    return directive;
}
exports.ngTableGroupRow = ngTableGroupRow;


/***/ },
/* 13 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** ./src/browser/ngTableGroupRowController.ts ***!
  \**************************************************/
/***/ function(module, exports) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
ngTableGroupRowController.$inject = ['$scope'];
/**
 * Controller for the {@link ngTableGroupRow ngTableGroupRow} directive
 */
function ngTableGroupRowController($scope) {
    var groupFns = [];
    init();
    function init() {
        $scope.getGroupables = getGroupables;
        $scope.getGroupTitle = getGroupTitle;
        $scope.getVisibleColumns = getVisibleColumns;
        $scope.groupBy = groupBy;
        $scope.isSelectedGroup = isSelectedGroup;
        $scope.toggleDetail = toggleDetail;
        $scope.$watch('params.group()', setGroup, true);
    }
    function changeSortDirection() {
        var newDirection;
        if ($scope.params.hasGroup($scope.$selGroup, 'asc')) {
            newDirection = 'desc';
        }
        else if ($scope.params.hasGroup($scope.$selGroup, 'desc')) {
            newDirection = '';
        }
        else {
            newDirection = 'asc';
        }
        $scope.params.group($scope.$selGroup, newDirection);
    }
    function findGroupColumn(groupKey) {
        return $scope.$columns.filter(function ($column) {
            return $column.groupable($scope) === groupKey;
        })[0];
    }
    function getGroupTitle(group) {
        return isGroupingFunc(group) ? group.title : group.title($scope);
    }
    function getGroupables() {
        var groupableCols = $scope.$columns.filter(function ($column) {
            return !!$column.groupable($scope);
        });
        return groupFns.concat(groupableCols);
    }
    function getVisibleColumns() {
        return $scope.$columns.filter(function ($column) {
            return $column.show($scope);
        });
    }
    function groupBy(group) {
        if (isSelectedGroup(group)) {
            changeSortDirection();
        }
        else {
            if (isGroupingFunc(group)) {
                $scope.params.group(group);
            }
            else {
                // it's OK, we know that groupable will return a string
                // this is guaranteed by getGroupables returning only
                // columns that return (truthy) strings
                $scope.params.group(group.groupable($scope));
            }
        }
    }
    function isGroupingFunc(val) {
        return typeof val === 'function';
    }
    function isSelectedGroup(group) {
        if (isGroupingFunc(group)) {
            return group === $scope.$selGroup;
        }
        else {
            return group.groupable($scope) === $scope.$selGroup;
        }
    }
    function setGroup(grouping) {
        var existingGroupCol = findGroupColumn($scope.$selGroup);
        if (existingGroupCol && existingGroupCol.show.assign) {
            existingGroupCol.show.assign($scope, true);
        }
        if (isGroupingFunc(grouping)) {
            groupFns = [grouping];
            $scope.$selGroup = grouping;
            $scope.$selGroupTitle = grouping.title;
        }
        else {
            // note: currently only one group is implemented
            var groupKey = Object.keys(grouping || {})[0];
            var groupedColumn = findGroupColumn(groupKey);
            if (groupedColumn) {
                $scope.$selGroupTitle = groupedColumn.title($scope);
                $scope.$selGroup = groupKey;
                if (groupedColumn.show.assign) {
                    groupedColumn.show.assign($scope, false);
                }
            }
        }
    }
    function toggleDetail() {
        $scope.params.settings().groupOptions.isExpanded = !$scope.params.settings().groupOptions.isExpanded;
        return $scope.params.reload();
    }
}
exports.ngTableGroupRowController = ngTableGroupRowController;


/***/ },
/* 14 */
/* unknown exports provided */
/* all exports used */
/*!****************************************************!*\
  !*** ./src/browser/ngTablePagination.directive.ts ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
var ng1 = __webpack_require__(/*! angular */ 0);
ngTablePagination.$inject = ['$compile', '$document', 'ngTableEventsChannel'];
/**
 * Directive that renders the table pagination controls
 * @ngdoc directive
 */
function ngTablePagination($compile, $document, ngTableEventsChannel) {
    return {
        restrict: 'A',
        scope: {
            'params': '=ngTablePagination',
            'templateUrl': '='
        },
        replace: false,
        link: function (scope, element /*, attrs*/) {
            ngTableEventsChannel.onAfterReloadData(function (pubParams) {
                scope.pages = pubParams.generatePagesArray();
            }, scope, function (pubParams) {
                return pubParams === scope.params;
            });
            scope.$watch('templateUrl', function (templateUrl) {
                if (templateUrl === undefined) {
                    return;
                }
                var template = ng1.element('<div ng-include="templateUrl"></div>', $document);
                element.append(template);
                $compile(template)(scope);
            });
        }
    };
}
exports.ngTablePagination = ngTablePagination;


/***/ },
/* 15 */
/* unknown exports provided */
/* all exports used */
/*!********************************************************!*\
  !*** ./src/browser/ngTableSelectFilterDs.directive.ts ***!
  \********************************************************/
/***/ function(module, exports) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
ngTableSelectFilterDs.$inject = [];
/**
 * Takes the array returned by $column.filterData and makes it available as `$selectData` on the `$scope`.
 *
 * The resulting `$selectData` array will contain an extra item that is suitable to represent the user
 * "deselecting" an item from a `<select>` tag
 *
 * This directive is is focused on providing a datasource to an `ngOptions` directive
 * @ngdoc directive
 * @private
 */
function ngTableSelectFilterDs() {
    // note: not using isolated or child scope "by design"
    // this is to allow this directive to be combined with other directives that do
    var directive = {
        restrict: 'A',
        controller: ngTableSelectFilterDsController
    };
    return directive;
}
exports.ngTableSelectFilterDs = ngTableSelectFilterDs;
ngTableSelectFilterDsController.$inject = ['$scope', '$parse', '$attrs', '$q'];
function ngTableSelectFilterDsController($scope, $parse, $attrs, $q) {
    var $column;
    init();
    function init() {
        $column = $parse($attrs.ngTableSelectFilterDs)($scope);
        $scope.$watch(function () {
            return $column && $column.data;
        }, bindDataSource);
    }
    function bindDataSource() {
        getSelectListData($column).then(function (data) {
            if (data && !hasEmptyOption(data)) {
                data.unshift({ id: '', title: '' });
            }
            data = data || [];
            $scope.$selectData = data;
        });
    }
    function hasEmptyOption(data) {
        var isMatch;
        for (var i = 0; i < data.length; i++) {
            var item = data[i];
            if (item && item.id === '') {
                isMatch = true;
                break;
            }
        }
        return isMatch;
    }
    function getSelectListData($column) {
        var dataInput = $column.data;
        if (dataInput instanceof Array) {
            return $q.when(dataInput);
        }
        else {
            return $q.when(dataInput && dataInput());
        }
    }
}


/***/ },
/* 16 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** ./src/browser/ngTableSorterRow.directive.ts ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
var templateUrl = __webpack_require__(/*! ./sorterRow.html */ 32);
ngTableSorterRow.$inject = [];
/**
 * directive that renders the sorting header row for a table
 * @ngdoc directive
 * @example
 * ```html
 * <ng-table-sorter-row></ng-table-sorter-row>
 * ```
 */
function ngTableSorterRow() {
    var directive = {
        restrict: 'E',
        replace: true,
        templateUrl: templateUrl,
        scope: true,
        controller: 'ngTableSorterRowController'
    };
    return directive;
}
exports.ngTableSorterRow = ngTableSorterRow;


/***/ },
/* 17 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** ./src/browser/ngTableSorterRowController.ts ***!
  \***************************************************/
/***/ function(module, exports) {

"use strict";
"use strict";
ngTableSorterRowController.$inject = ['$scope'];
/**
 * Controller for the {@link ngTableSorterRow ngTableSorterRow} directive
 */
function ngTableSorterRowController($scope) {
    $scope.sortBy = sortBy;
    ///////////
    function sortBy($column, event) {
        var parsedSortable = $column.sortable && $column.sortable();
        if (!parsedSortable || typeof parsedSortable !== 'string') {
            return;
        }
        else {
            var defaultSort = $scope.params.settings().defaultSort;
            var inverseSort = (defaultSort === 'asc' ? 'desc' : 'asc');
            var sorting = $scope.params.sorting() && $scope.params.sorting()[parsedSortable] && ($scope.params.sorting()[parsedSortable] === defaultSort);
            var sortingParams = (event.ctrlKey || event.metaKey) ? $scope.params.sorting() : {};
            sortingParams[parsedSortable] = (sorting ? inverseSort : defaultSort);
            $scope.params.parameters({
                sorting: sortingParams
            });
        }
    }
}
exports.ngTableSorterRowController = ngTableSorterRowController;


/***/ },
/* 18 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./src/browser/public-interfaces.ts ***!
  \******************************************/
/***/ function(module, exports) {

"use strict";
"use strict";


/***/ },
/* 19 */
/* unknown exports provided */
/* all exports used */
/*!*******************************************!*\
  !*** ./src/core/ngTableDefaultGetData.ts ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
var ng1 = __webpack_require__(/*! angular */ 0);
/**
 * Allows for the configuration of the ngTableDefaultGetData service.
 *
 * Set filterFilterName to the name of a angular filter that knows how to apply the values returned by
 * `NgTableParams.filter()` to restrict an array of data.
 *
 * Set sortingFilterName to the name of a angular filter that knows how to apply the values returned by
 * `NgTableParams.orderBy()` to sort an array of data.
 *
 * Out of the box the `ngTableDefaultGetData` service will be configured to use the angular `filter` and `orderBy`
 * filters respectively
 *
 * @ngdoc provider
 */
var ngTableDefaultGetDataProvider = (function () {
    function ngTableDefaultGetDataProvider() {
        this.filterFilterName = 'filter';
        this.sortingFilterName = 'orderBy';
        var provider = this;
        this.$get = ngTableDefaultGetData;
        ngTableDefaultGetData.$inject = ['$filter'];
        /**
         * Implementation of the {@link IDefaultGetData IDefaultGetData} interface
         *
         * @ngdoc service
         */
        function ngTableDefaultGetData($filter) {
            var defaultDataOptions = { applyFilter: true, applySort: true, applyPaging: true };
            getData.applyPaging = applyPaging;
            getData.getFilterFn = getFilterFn;
            getData.getOrderByFn = getOrderByFn;
            return getData;
            function getFilterFn(params) {
                var filterOptions = params.settings().filterOptions;
                if (ng1.isFunction(filterOptions.filterFn)) {
                    return filterOptions.filterFn;
                }
                else {
                    return $filter(filterOptions.filterFilterName || provider.filterFilterName);
                }
            }
            function getOrderByFn(params) {
                return $filter(provider.sortingFilterName);
            }
            function applyFilter(data, params) {
                if (!params.hasFilter()) {
                    return data;
                }
                var filter = params.filter(true);
                var filterKeys = Object.keys(filter);
                var parsedFilter = filterKeys.reduce(function (result, key) {
                    result = setPath(result, filter[key], key);
                    return result;
                }, {});
                var filterFn = getFilterFn(params);
                return filterFn.call(params, data, parsedFilter, params.settings().filterOptions.filterComparator);
            }
            function applyPaging(data, params) {
                var pagedData = data.slice((params.page() - 1) * params.count(), params.page() * params.count());
                params.total(data.length); // set total for recalc pagination
                return pagedData;
            }
            function applySort(data, params) {
                var orderBy = params.orderBy();
                var orderByFn = getOrderByFn(params);
                return orderBy.length ? orderByFn(data, orderBy) : data;
            }
            function getData(data, params) {
                if (data == null) {
                    return [];
                }
                var options = ng1.extend({}, defaultDataOptions, params.settings().dataOptions);
                var fData = options.applyFilter ? applyFilter(data, params) : data;
                var orderedData = options.applySort ? applySort(fData, params) : fData;
                return options.applyPaging ? applyPaging(orderedData, params) : orderedData;
            }
            // Sets the value at any depth in a nested object based on the path
            // note: adapted from: underscore-contrib#setPath
            function setPath(obj, value, path) {
                var keys = path.split('.');
                var ret = obj;
                var lastKey = keys[keys.length - 1];
                var target = ret;
                var parentPathKeys = keys.slice(0, keys.length - 1);
                parentPathKeys.forEach(function (key) {
                    if (!target.hasOwnProperty(key)) {
                        target[key] = {};
                    }
                    target = target[key];
                });
                target[lastKey] = value;
                return ret;
            }
        }
    }
    return ngTableDefaultGetDataProvider;
}());
exports.ngTableDefaultGetDataProvider = ngTableDefaultGetDataProvider;


/***/ },
/* 20 */
/* unknown exports provided */
/* all exports used */
/*!*************************************!*\
  !*** ./src/core/ngTableDefaults.ts ***!
  \*************************************/
/***/ function(module, exports) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
/**
 * Default values for ngTable
 * @ngdoc object
 */
exports.ngTableDefaults = {
    params: {},
    settings: {}
};


/***/ },
/* 21 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./src/core/ngTableEventsChannel.ts ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
var ng1 = __webpack_require__(/*! angular */ 0);
ngTableEventsChannel.$inject = ['$rootScope'];
/**
 * Implementation of the {@link IEventsChannel IEventsChannel} interface
 * @ngdoc service
 */
function ngTableEventsChannel($rootScope) {
    var events = {};
    events = addTableParamsEvent('afterCreated', events);
    events = addTableParamsEvent('afterReloadData', events);
    events = addTableParamsEvent('datasetChanged', events);
    events = addTableParamsEvent('pagesChanged', events);
    return events;
    //////////
    function addTableParamsEvent(eventName, target) {
        var fnName = eventName.charAt(0).toUpperCase() + eventName.substring(1);
        var event = (_a = {},
            _a['on' + fnName] = createEventSubscriptionFn(eventName),
            _a['publish' + fnName] = createPublishEventFn(eventName),
            _a
        );
        return ng1.extend(target, event);
        var _a;
    }
    function createEventSubscriptionFn(eventName) {
        return function subscription(handler, eventSelectorOrScope, eventSelector) {
            var actualEvtSelector;
            var scope = $rootScope;
            if (isScopeLike(eventSelectorOrScope)) {
                scope = eventSelectorOrScope;
                actualEvtSelector = createEventSelectorFn(eventSelector);
            }
            else {
                actualEvtSelector = createEventSelectorFn(eventSelectorOrScope);
            }
            return scope.$on('ngTable:' + eventName, function (event, params) {
                var eventArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    eventArgs[_i - 2] = arguments[_i];
                }
                // don't send events published by the internal NgTableParams created by ngTableController
                if (params.isNullInstance)
                    return;
                var fnArgs = [params].concat(eventArgs);
                if (actualEvtSelector.apply(this, fnArgs)) {
                    handler.apply(this, fnArgs);
                }
            });
        };
        function createEventSelectorFn(eventSelector) {
            if (!eventSelector) {
                return function (publisher) { return true; };
            }
            else if (isEventSelectorFunc(eventSelector)) {
                return eventSelector;
            }
            else {
                // shorthand for subscriber to only receive events from a specific publisher instance
                return function (publisher) { return publisher === eventSelector; };
            }
        }
        function isEventSelectorFunc(val) {
            return typeof val === 'function';
        }
        function isScopeLike(val) {
            return val && typeof val.$new === 'function';
        }
    }
    function createPublishEventFn(eventName) {
        return function publish() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            $rootScope.$broadcast.apply($rootScope, ['ngTable:' + eventName].concat(args));
        };
    }
}
exports.ngTableEventsChannel = ngTableEventsChannel;


/***/ },
/* 22 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** ./src/core/ngTableParams.ts ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

"use strict";
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */
"use strict";
var ng1 = __webpack_require__(/*! angular */ 0);
ngTableParamsFactory.$inject = [
    '$q', '$log', '$filter', 'ngTableDefaults', 'ngTableDefaultGetData', 'ngTableEventsChannel'
];
/**
 * Implmenentation of the {@link INgTableParams INgTableParams} interface
 * @ngdoc service
 */
function ngTableParamsFactory($q, $log, $filter, ngTableDefaults, ngTableDefaultGetData, ngTableEventsChannel) {
    return NgTableParams;
    function NgTableParams(baseParameters, baseSettings) {
        function isNumber(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
        // the ngTableController "needs" to create a dummy/null instance and it's important to know whether an instance
        // is one of these
        if (typeof baseParameters === "boolean") {
            this.isNullInstance = true;
        }
        var self = this, prevParamsMemento, errParamsMemento, isCommittedDataset = false, initialEvents = [], log = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (_settings.debugMode && $log.debug) {
                $log.debug.apply($log, args);
            }
        }, defaultFilterOptions = {
            filterComparator: undefined,
            filterDelay: 500,
            filterDelayThreshold: 10000,
            filterFilterName: undefined,
            filterFn: undefined,
            filterLayout: 'stack' // alternative: 'horizontal'
        }, defaultGroupOptions = {
            defaultSort: 'asc',
            isExpanded: true
        }, defaultSettingsFns = getDefaultSettingFns();
        this.data = [];
        this.parameters = function (newParameters, parseParamsFromUrl) {
            parseParamsFromUrl = parseParamsFromUrl || false;
            if (typeof newParameters !== undefined) {
                for (var key in newParameters) {
                    var value = newParameters[key];
                    if (parseParamsFromUrl && key.indexOf('[') >= 0) {
                        var keys = key.split(/\[(.*)\]/).reverse();
                        var lastKey = '';
                        for (var i = 0, len = keys.length; i < len; i++) {
                            var name = keys[i];
                            if (name !== '') {
                                var v = value;
                                value = {};
                                value[lastKey = name] = (isNumber(v) ? parseFloat(v) : v);
                            }
                        }
                        if (lastKey === 'sorting') {
                            _params[lastKey] = {};
                        }
                        _params[lastKey] = ng1.extend(_params[lastKey] || {}, value[lastKey]);
                    }
                    else {
                        if (key === 'group') {
                            _params[key] = parseGroup(newParameters[key]);
                        }
                        else {
                            _params[key] = (isNumber(newParameters[key]) ? parseFloat(newParameters[key]) : newParameters[key]);
                        }
                    }
                }
                log('ngTable: set parameters', _params);
                return this;
            }
            return _params;
        };
        function parseGroup(group) {
            var defaultSort = _settings.groupOptions && _settings.groupOptions.defaultSort;
            if (!group) {
                return group;
            }
            else if (isGroupingFun(group)) {
                if (group.sortDirection == null) {
                    group.sortDirection = defaultSort;
                }
                return group;
            }
            else if (typeof group === 'object') {
                for (var key in group) {
                    if (group[key] == null) {
                        group[key] = defaultSort;
                    }
                }
                return group;
            }
            else {
                return (_a = {},
                    _a[group] = defaultSort,
                    _a
                );
            }
            var _a;
        }
        /**
         * @ngdoc method
         * @name NgTableParams#settings
         * @description Set new settings for table
         *
         * @param {string} newSettings New settings or undefined
         * @returns {Object} Current settings or `this`
         */
        this.settings = function (newSettings) {
            if (ng1.isDefined(newSettings)) {
                // todo: don't modify newSettings object: this introduces unexpected side effects;
                // instead take a copy of newSettings
                if (newSettings.filterOptions) {
                    newSettings.filterOptions = ng1.extend({}, _settings.filterOptions, newSettings.filterOptions);
                }
                if (newSettings.groupOptions) {
                    newSettings.groupOptions = ng1.extend({}, _settings.groupOptions, newSettings.groupOptions);
                }
                if (ng1.isArray(newSettings.dataset)) {
                    //auto-set the total from passed in dataset
                    newSettings.total = newSettings.dataset.length;
                }
                var originalDataset = _settings.dataset;
                _settings = ng1.extend(_settings, newSettings);
                if (ng1.isArray(newSettings.dataset)) {
                    optimizeFilterDelay();
                }
                // note: using != as want null and undefined to be treated the same
                var hasDatasetChanged = newSettings.hasOwnProperty('dataset') && (newSettings.dataset != originalDataset);
                if (hasDatasetChanged) {
                    if (isCommittedDataset) {
                        this.page(1); // reset page as a new dataset has been supplied
                    }
                    isCommittedDataset = false;
                    var fireEvent = function () {
                        ngTableEventsChannel.publishDatasetChanged(self, newSettings.dataset, originalDataset);
                    };
                    if (initialEvents) {
                        initialEvents.push(fireEvent);
                    }
                    else {
                        fireEvent();
                    }
                }
                log('ngTable: set settings', _settings);
                return this;
            }
            return _settings;
        };
        this.page = function (page) {
            return page !== undefined ? this.parameters({
                'page': page
            }) : _params.page;
        };
        this.total = function (total) {
            return total !== undefined ? this.settings({
                'total': total
            }) : _settings.total;
        };
        this.count = function (count) {
            // reset to first page because can be blank page
            return count !== undefined ? this.parameters({
                'count': count,
                'page': 1
            }) : _params.count;
        };
        this.filter = function (filter) {
            if (filter != null && typeof filter === 'object') {
                return this.parameters({
                    'filter': filter,
                    'page': 1
                });
            }
            else if (filter === true) {
                var keys = Object.keys(_params.filter);
                var significantFilter = {};
                for (var i = 0; i < keys.length; i++) {
                    var filterValue = _params.filter[keys[i]];
                    if (filterValue != null && filterValue !== '') {
                        significantFilter[keys[i]] = filterValue;
                    }
                }
                return significantFilter;
            }
            else {
                return _params.filter;
            }
        };
        this.group = function (group, sortDirection) {
            if (group === undefined) {
                return _params.group;
            }
            var newParameters = {
                page: 1
            };
            if (isGroupingFun(group) && sortDirection !== undefined) {
                group.sortDirection = sortDirection;
                newParameters.group = group;
            }
            else if (typeof group === 'string' && sortDirection !== undefined) {
                newParameters.group = (_a = {}, _a[group] = sortDirection, _a);
            }
            else {
                newParameters.group = group;
            }
            this.parameters(newParameters);
            return this;
            var _a;
        };
        /**
         * @ngdoc method
         * @name NgTableParams#sorting
         * @description If 'sorting' parameter is not set, return current sorting. Otherwise set current sorting.
         *
         * @param {string} sorting New sorting
         * @returns {Object} Current sorting or `this`
         */
        this.sorting = function (sorting, direction) {
            if (typeof sorting === 'string' && direction !== undefined) {
                this.parameters({
                    'sorting': (_a = {}, _a[sorting] = direction, _a)
                });
                return this;
            }
            return sorting !== undefined ? this.parameters({
                'sorting': sorting
            }) : _params.sorting;
            var _a;
        };
        this.isSortBy = function (field, direction) {
            if (direction !== undefined) {
                return _params.sorting[field] !== undefined && _params.sorting[field] == direction;
            }
            else {
                return _params.sorting[field] !== undefined;
            }
        };
        /**
         * @ngdoc method
         * @name NgTableParams#orderBy
         * @description Return object of sorting parameters for angular filter
         *
         * @returns {Array} Array like: [ '-name', '+age' ]
         */
        this.orderBy = function () {
            return convertSortToOrderBy(_params.sorting);
        };
        function convertSortToOrderBy(sorting) {
            var result = [];
            for (var column in sorting) {
                result.push((sorting[column] === "asc" ? "+" : "-") + column);
            }
            return result;
        }
        /**
         * @ngdoc method
         * @name NgTableParams#generatePagesArray
         * @description Generate array of pages
         *
         * When no arguments supplied, the current parameter state of this `NgTableParams` instance will be used
         *
         * @param {boolean} currentPage which page must be active
         * @param {boolean} totalItems  Total quantity of items
         * @param {boolean} pageSize    Quantity of items on page
         * @param {number} maxBlocks    Quantity of blocks for pagination
         * @returns {Array} Array of pages
         */
        this.generatePagesArray = function (currentPage, totalItems, pageSize, maxBlocks) {
            if (!arguments.length) {
                currentPage = this.page();
                totalItems = this.total();
                pageSize = this.count();
            }
            var maxPage, maxPivotPages, minPage, numPages;
            maxBlocks = maxBlocks && maxBlocks < 6 ? 6 : maxBlocks;
            var pages = [];
            numPages = Math.ceil(totalItems / pageSize);
            if (numPages > 1) {
                pages.push({
                    type: 'prev',
                    number: Math.max(1, currentPage - 1),
                    active: currentPage > 1
                });
                pages.push({
                    type: 'first',
                    number: 1,
                    active: currentPage > 1,
                    current: currentPage === 1
                });
                maxPivotPages = Math.round((_settings.paginationMaxBlocks - _settings.paginationMinBlocks) / 2);
                minPage = Math.max(2, currentPage - maxPivotPages);
                maxPage = Math.min(numPages - 1, currentPage + maxPivotPages * 2 - (currentPage - minPage));
                minPage = Math.max(2, minPage - (maxPivotPages * 2 - (maxPage - minPage)));
                var i = minPage;
                while (i <= maxPage) {
                    if ((i === minPage && i !== 2) || (i === maxPage && i !== numPages - 1)) {
                        pages.push({
                            type: 'more',
                            active: false
                        });
                    }
                    else {
                        pages.push({
                            type: 'page',
                            number: i,
                            active: currentPage !== i,
                            current: currentPage === i
                        });
                    }
                    i++;
                }
                pages.push({
                    type: 'last',
                    number: numPages,
                    active: currentPage !== numPages,
                    current: currentPage === numPages
                });
                pages.push({
                    type: 'next',
                    number: Math.min(numPages, currentPage + 1),
                    active: currentPage < numPages
                });
            }
            return pages;
        };
        /**
         * @ngdoc method
         * @name NgTableParams#isDataReloadRequired
         * @description Return true when a change to this `NgTableParams` instance should require the reload method
         * to be run so as to ensure the data presented to the user reflects the `NgTableParams`
         *
         * Note that this method will return false when the reload method has run but fails. In this case
         * `hasErrorState` will return true.
         */
        this.isDataReloadRequired = function () {
            // note: using != as want to treat null and undefined the same
            return !isCommittedDataset || !ng1.equals(createComparableParams(), prevParamsMemento)
                || hasGlobalSearchFieldChanges();
        };
        function createComparableParams() {
            var group = _params.group;
            return {
                params: _params,
                groupSortDirection: isGroupingFun(group) ? group.sortDirection : undefined
            };
        }
        function isGroupingFun(val) {
            return typeof val === 'function';
        }
        /**
         * @ngdoc method
         * @name NgTableParams#hasFilter
         * @description Determines if NgTableParams#filter has significant filter value(s)
         * (any value except null, undefined, or empty string)
         * @returns {Boolean} true when NgTableParams#filter has at least one significant field value
         */
        this.hasFilter = function () {
            return Object.keys(this.filter(true)).length > 0;
        };
        this.hasGroup = function (group, sortDirection) {
            if (group == null) {
                return isGroupingFun(_params.group) || Object.keys(_params.group).length > 0;
            }
            if (isGroupingFun(group)) {
                if (sortDirection == null) {
                    return _params.group === group;
                }
                else {
                    return _params.group === group && group.sortDirection === sortDirection;
                }
            }
            else {
                if (sortDirection == null) {
                    return Object.keys(_params.group).indexOf(group) !== -1;
                }
                else {
                    return _params.group[group] === sortDirection;
                }
            }
        };
        this.hasFilterChanges = function () {
            var previousFilter = (prevParamsMemento && prevParamsMemento.params.filter);
            return !ng1.equals((_params.filter), previousFilter) || hasGlobalSearchFieldChanges();
        };
        function hasGlobalSearchFieldChanges() {
            var currentVal = (_params.filter && _params.filter['$']);
            var previousVal = (prevParamsMemento && prevParamsMemento.params.filter && prevParamsMemento.params.filter['$']);
            return !ng1.equals(currentVal, previousVal);
        }
        this.url = function (asString) {
            // this function is an example of Typescript gone bad!!
            asString = asString || false;
            var pairs = (asString ? [] : {});
            for (var key in _params) {
                if (_params.hasOwnProperty(key)) {
                    var item = _params[key], name = encodeURIComponent(key);
                    if (typeof item === "object") {
                        for (var subkey in item) {
                            if (isSignificantValue(item[subkey], key)) {
                                var pname = name + "[" + encodeURIComponent(subkey) + "]";
                                collectValue(item[subkey], pname);
                            }
                        }
                    }
                    else if (!ng1.isFunction(item) && isSignificantValue(item, key)) {
                        collectValue(item, name);
                    }
                }
            }
            return pairs;
            function collectValue(value, key) {
                if (isArray(pairs)) {
                    pairs.push(key + "=" + encodeURIComponent(value));
                }
                else {
                    pairs[key] = encodeURIComponent(value);
                }
            }
            function isArray(pairs) {
                return asString;
            }
            function isSignificantValue(value, key) {
                return key === "group" ? true : typeof value !== undefined && value !== "";
            }
        };
        this.reload = function () {
            var self = this, pData = null;
            _settings.$loading = true;
            prevParamsMemento = ng1.copy(createComparableParams());
            isCommittedDataset = true;
            if (self.hasGroup()) {
                pData = runInterceptorPipeline($q.when(_settings.getGroups(self)));
            }
            else {
                var fn = _settings.getData;
                pData = runInterceptorPipeline($q.when(fn(self)));
            }
            log('ngTable: reload data');
            var oldData = self.data;
            return pData.then(function (data) {
                _settings.$loading = false;
                errParamsMemento = null;
                self.data = data;
                // note: I think it makes sense to publish this event even when data === oldData
                // subscribers can always set a filter to only receive the event when data !== oldData
                ngTableEventsChannel.publishAfterReloadData(self, data, oldData);
                self.reloadPages();
                return data;
            }).catch(function (reason) {
                errParamsMemento = prevParamsMemento;
                // "rethrow"
                return $q.reject(reason);
            });
        };
        this.hasErrorState = function () {
            return !!(errParamsMemento && ng1.equals(errParamsMemento, createComparableParams()));
        };
        function optimizeFilterDelay() {
            // don't debounce by default filter input when working with small synchronous datasets
            if (_settings.filterOptions.filterDelay === defaultFilterOptions.filterDelay &&
                _settings.total <= _settings.filterOptions.filterDelayThreshold &&
                _settings.getData === defaultSettingsFns.getData) {
                _settings.filterOptions.filterDelay = 0;
            }
        }
        this.reloadPages = (function () {
            var currentPages;
            return function () {
                var oldPages = currentPages;
                var newPages = self.generatePagesArray(self.page(), self.total(), self.count());
                if (!ng1.equals(oldPages, newPages)) {
                    currentPages = newPages;
                    ngTableEventsChannel.publishPagesChanged(this, newPages, oldPages);
                }
            };
        })();
        function runInterceptorPipeline(fetchedData) {
            var interceptors = _settings.interceptors || [];
            return interceptors.reduce(function (result, interceptor) {
                var thenFn = (interceptor.response && interceptor.response.bind(interceptor)) || $q.when;
                var rejectFn = (interceptor.responseError && interceptor.responseError.bind(interceptor)) || $q.reject;
                return result.then(function (data) {
                    return thenFn(data, self);
                }, function (reason) {
                    return rejectFn(reason, self);
                });
            }, fetchedData);
        }
        function getDefaultSettingFns() {
            return {
                getData: getData,
                getGroups: getGroups
            };
            /**
             * @ngdoc method
             * @name settings#getData
             * @description Returns the data to display in the table
             *
             * Called by `NgTableParams` whenever it considers new data is to be loaded
             *
             * @param {Object} params the `NgTableParams` requesting data
             */
            function getData(params) {
                return ngTableDefaultGetData(params.settings().dataset, params);
            }
            /**
             * @ngdoc method
             * @name settings#getGroups
             * @description Return groups of data to display in the table
             *
             * Called by `NgTableParams` whenever it considers new data is to be loaded
             * and when a `group` value has been assigned
             *
             * @param {Object} params the `NgTableParams` requesting data
             */
            function getGroups(params) {
                var group = params.group();
                var groupFn;
                var sortDirection = undefined;
                if (isGroupingFun(group)) {
                    groupFn = group;
                    sortDirection = group.sortDirection;
                }
                else {
                    // currently support for only one group implemented
                    var groupField = Object.keys(group)[0];
                    sortDirection = group[groupField];
                    groupFn = function (item) {
                        return getPath(item, groupField);
                    };
                }
                var settings = params.settings();
                var originalDataOptions = settings.dataOptions;
                settings.dataOptions = { applyPaging: false };
                var getData = settings.getData;
                var gotData = $q.when(getData(params));
                return gotData.then(function (data) {
                    var groups = {};
                    ng1.forEach(data, function (item) {
                        var groupName = groupFn(item);
                        groups[groupName] = groups[groupName] || {
                            data: [],
                            $hideRows: !settings.groupOptions.isExpanded,
                            value: groupName
                        };
                        groups[groupName].data.push(item);
                    });
                    var result = [];
                    for (var i in groups) {
                        result.push(groups[i]);
                    }
                    if (sortDirection) {
                        var orderByFn = ngTableDefaultGetData.getOrderByFn();
                        var orderBy = convertSortToOrderBy({
                            value: sortDirection
                        });
                        result = orderByFn(result, orderBy);
                    }
                    return ngTableDefaultGetData.applyPaging(result, params);
                }).finally(function () {
                    // restore the real options
                    settings.dataOptions = originalDataOptions;
                });
            }
            function getPath(obj, ks) {
                // origianl source https://github.com/documentcloud/underscore-contrib
                var keys;
                if (typeof ks === "string") {
                    keys = ks.split(".");
                }
                else {
                    keys = ks;
                }
                // If we have reached an undefined property
                // then stop executing and return undefined
                if (obj === undefined)
                    return void 0;
                // If the path array has no more elements, we've reached
                // the intended property and return its value
                if (keys.length === 0)
                    return obj;
                // If we still have elements in the path array and the current
                // value is null, stop executing and return undefined
                if (obj === null)
                    return void 0;
                return getPath(obj[keys[0]], keys.slice(1));
            }
        }
        var _params = {
            page: 1,
            count: 10,
            filter: {},
            sorting: {},
            group: {}
        };
        ng1.extend(_params, ngTableDefaults.params);
        /**
         * @ngdoc object
         * @name settings
         * @module ngTable
         * @description configuration settings for `NgTableParams`
         */
        var _settings = {
            $loading: false,
            dataset: null,
            total: 0,
            defaultSort: 'desc',
            filterOptions: ng1.copy(defaultFilterOptions),
            groupOptions: ng1.copy(defaultGroupOptions),
            counts: [10, 25, 50, 100],
            interceptors: [],
            paginationMaxBlocks: 11,
            paginationMinBlocks: 5,
            sortingIndicator: 'span'
        };
        this.settings(defaultSettingsFns);
        this.settings(ngTableDefaults.settings);
        this.settings(baseSettings);
        this.parameters(baseParameters, true);
        ngTableEventsChannel.publishAfterCreated(this);
        // run events during construction after the initial create event. That way a consumer
        // can subscribe to all events for a table without "dropping" an event
        ng1.forEach(initialEvents, function (event) {
            event();
        });
        initialEvents = null;
        return this;
    }
}
exports.ngTableParamsFactory = ngTableParamsFactory;


/***/ },
/* 23 */
/* unknown exports provided */
/* all exports used */
/*!***************************************!*\
  !*** ./src/core/public-interfaces.ts ***!
  \***************************************/
/***/ function(module, exports) {

"use strict";
"use strict";


/***/ },
/* 24 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./src/browser/filterRow.html ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

var path = 'ng-table/filterRow.html';
var html = "<tr ng-show=\"show_filter\" class=\"ng-table-filters\">\n    <th data-title-text=\"{{$column.titleAlt(this) || $column.title(this)}}\" ng-repeat=\"$column in $columns\" ng-if=\"$column.show(this)\" class=\"filter {{$column.class(this)}}\"\n        ng-class=\"params.settings().filterOptions.filterLayout === 'horizontal' ? 'filter-horizontal' : ''\">\n        <div ng-repeat=\"(name, filter) in $column.filter(this)\" ng-include=\"config.getTemplateUrl(filter)\" class=\"filter-cell\"\n             ng-class=\"[getFilterCellCss($column.filter(this), params.settings().filterOptions.filterLayout), $last ? 'last' : '']\">\n        </div>\n    </th>\n</tr>\n";
var angular = __webpack_require__(/*! angular */ 0);
angular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ },
/* 25 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************!*\
  !*** ./src/browser/filters/number.html ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

var path = 'ng-table/filters/number.html';
var html = "<input type=\"number\" name=\"{{name}}\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" class=\"input-filter form-control\"\n       placeholder=\"{{getFilterPlaceholderValue(filter, name)}}\"/>\n";
var angular = __webpack_require__(/*! angular */ 0);
angular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ },
/* 26 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** ./src/browser/filters/select-multiple.html ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

var path = 'ng-table/filters/select-multiple.html';
var html = "<select ng-options=\"data.id as data.title for data in $column.data\"\n        ng-disabled=\"$filterRow.disabled\"\n        multiple ng-multiple=\"true\"\n        ng-model=\"params.filter()[name]\"\n        class=\"filter filter-select-multiple form-control\" name=\"{{name}}\">\n</select>\n";
var angular = __webpack_require__(/*! angular */ 0);
angular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ },
/* 27 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************!*\
  !*** ./src/browser/filters/select.html ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

var path = 'ng-table/filters/select.html';
var html = "<select ng-options=\"data.id as data.title for data in $selectData\"\n        ng-table-select-filter-ds=\"$column\"\n        ng-disabled=\"$filterRow.disabled\"\n        ng-model=\"params.filter()[name]\"\n        class=\"filter filter-select form-control\" name=\"{{name}}\">\n    <option style=\"display:none\" value=\"\"></option>\n</select>\n";
var angular = __webpack_require__(/*! angular */ 0);
angular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ },
/* 28 */
/* unknown exports provided */
/* all exports used */
/*!***************************************!*\
  !*** ./src/browser/filters/text.html ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

var path = 'ng-table/filters/text.html';
var html = "<input type=\"text\" name=\"{{name}}\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" class=\"input-filter form-control\"\n       placeholder=\"{{getFilterPlaceholderValue(filter, name)}}\"/>\n";
var angular = __webpack_require__(/*! angular */ 0);
angular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ },
/* 29 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** ./src/browser/groupRow.html ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

var path = 'ng-table/groupRow.html';
var html = "<tr ng-if=\"params.hasGroup()\" ng-show=\"$groupRow.show\" class=\"ng-table-group-header\">\n    <th colspan=\"{{getVisibleColumns().length}}\" class=\"sortable\" ng-class=\"{\n                    'sort-asc': params.hasGroup($selGroup, 'asc'),\n                    'sort-desc':params.hasGroup($selGroup, 'desc')\n                  }\">\n        <a href=\"\" ng-click=\"isSelectorOpen = !isSelectorOpen\" class=\"ng-table-group-selector\">\n            <strong class=\"sort-indicator\">{{$selGroupTitle}}</strong>\n            <button class=\"btn btn-default btn-xs ng-table-group-close\"\n                    ng-click=\"$groupRow.show = false; $event.preventDefault(); $event.stopPropagation();\">\n                <span class=\"glyphicon glyphicon-remove\"></span>\n            </button>\n            <button class=\"btn btn-default btn-xs ng-table-group-toggle\"\n                    ng-click=\"toggleDetail(); $event.preventDefault(); $event.stopPropagation();\">\n                <span class=\"glyphicon\" ng-class=\"{\n                    'glyphicon-resize-small': params.settings().groupOptions.isExpanded,\n                    'glyphicon-resize-full': !params.settings().groupOptions.isExpanded\n                }\"></span>\n            </button>\n        </a>\n        <div class=\"list-group\" ng-if=\"isSelectorOpen\">\n            <a href=\"\" class=\"list-group-item\" ng-repeat=\"group in getGroupables()\" ng-click=\"groupBy(group)\">\n                <strong>{{ getGroupTitle(group)}}</strong>\n                <strong ng-class=\"isSelectedGroup(group) && 'sort-indicator'\"></strong>\n            </a>\n        </div>\n    </th>\n</tr>\n";
var angular = __webpack_require__(/*! angular */ 0);
angular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ },
/* 30 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./src/browser/header.html ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

var path = 'ng-table/header.html';
var html = "<ng-table-group-row></ng-table-group-row>\n<ng-table-sorter-row></ng-table-sorter-row>\n<ng-table-filter-row></ng-table-filter-row>\n";
var angular = __webpack_require__(/*! angular */ 0);
angular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ },
/* 31 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./src/browser/pager.html ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

var path = 'ng-table/pager.html';
var html = "<div class=\"ng-cloak ng-table-pager fixed-table-pagination\" ng-if=\"params.data.length\">\n <div class=\"pull-left pagination-detail\">\n <span class=\"pagination-info\">\n &nbsp;&nbsp;Total {{ params.settings().total }} </span>\n </div>\n    <div ng-if=\"params.settings().counts.length\" class=\"ng-table-counts btn-group pull-left\">\n        <button ng-repeat=\"count in params.settings().counts\" type=\"button\"\n                ng-class=\"{'active':params.count() == count}\"\n                ng-click=\"params.count(count)\" class=\"btn btn-default\">\n            <span ng-bind=\"count\"></span>\n        </button>\n    </div>\n    <div class=\"pagination pull-right\">\n <ul ng-if=\"pages.length\" class=\"pagination ng-table-pagination\">\n        <li ng-class=\"{'disabled': !page.active && !page.current, 'active': page.current}\" ng-repeat=\"page in pages\" ng-switch=\"page.type\">\n            <a ng-switch-when=\"prev\" ng-click=\"params.page(page.number)\" href=\"\">&laquo;</a>\n            <a ng-switch-when=\"first\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a>\n            <a ng-switch-when=\"page\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a>\n            <a ng-switch-when=\"more\" ng-click=\"params.page(page.number)\" href=\"\">&#8230;</a>\n            <a ng-switch-when=\"last\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a>\n            <a ng-switch-when=\"next\" ng-click=\"params.page(page.number)\" href=\"\">&raquo;</a>\n        </li>\n    </ul>\n</div>\n </div>\n";
var angular = __webpack_require__(/*! angular */ 0);
angular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ },
/* 32 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./src/browser/sorterRow.html ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

var path = 'ng-table/sorterRow.html';
var html = "<tr class=\"ng-table-sort-header\">\n    <th title=\"{{$column.headerTitle(this)}}\"\n        ng-repeat=\"$column in $columns\"\n        ng-class=\"{\n                    'sortable': $column.sortable(this),\n                    'sort-asc': params.sorting()[$column.sortable(this)]=='asc',\n                    'sort-desc': params.sorting()[$column.sortable(this)]=='desc'\n                  }\"\n        ng-click=\"sortBy($column, $event)\"\n        ng-if=\"$column.show(this)\"\n        ng-init=\"template = $column.headerTemplateURL(this)\"\n        class=\"header {{$column.class(this)}}\">\n        <div ng-if=\"!template\" class=\"ng-table-header\" ng-class=\"{'sort-indicator': params.settings().sortingIndicator == 'div'}\">\n            <span ng-bind=\"$column.title(this)\" ng-class=\"{'sort-indicator': params.settings().sortingIndicator == 'span'}\"></span>\n        </div>\n        <div ng-if=\"template\" ng-include=\"template\"></div>\n    </th>\n</tr>\n";
var angular = __webpack_require__(/*! angular */ 0);
angular.module('ng').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ },
/* 33 */
/* unknown exports provided */
/* all exports used */
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var ng1 = __webpack_require__(/*! angular */ 0);
var core_1 = __webpack_require__(/*! ./src/core */ 2);
var browser_1 = __webpack_require__(/*! ./src/browser */ 1);
var ngTable = ng1.module('ngTable', [core_1.default.name, browser_1.default.name]);
exports.ngTable = ngTable;
__export(__webpack_require__(/*! ./src/core */ 2));
__export(__webpack_require__(/*! ./src/browser */ 1));


/***/ }
/******/ ])
});
;
//# sourceMappingURL=ng-table.js.map

/***/ }),

/***/ 128:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["parse"] = parse;
/* harmony export (immutable) */ __webpack_exports__["isValid"] = isValid;
/* harmony export (immutable) */ __webpack_exports__["parseDateMath"] = parseDateMath;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_moment__);
///<reference path="../../headers/common.d.ts" />


var units = ['y', 'M', 'w', 'd', 'h', 'm', 's', 'ms'];
function parse(text, roundUp) {
    if (!text) {
        return undefined;
    }
    if (__WEBPACK_IMPORTED_MODULE_1_moment___default.a.isMoment(text)) {
        return text;
    }
    if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isDate(text)) {
        return __WEBPACK_IMPORTED_MODULE_1_moment___default()(text);
    }
    var time;
    var mathString = '';
    var index;
    var parseString;
    if (text.substring(0, 3) === 'now') {
        time = __WEBPACK_IMPORTED_MODULE_1_moment___default()();
        mathString = text.substring('now'.length);
    }
    else {
        index = text.indexOf('||');
        if (index === -1) {
            parseString = text;
            mathString = ''; // nothing else
        }
        else {
            parseString = text.substring(0, index);
            mathString = text.substring(index + 2);
        }
        // We're going to just require ISO8601 timestamps, k?
        time = __WEBPACK_IMPORTED_MODULE_1_moment___default()(parseString);
    }
    if (!mathString.length) {
        return time;
    }
    return parseDateMath(mathString, time, roundUp);
}
function isValid(text) {
    var date = parse(text);
    if (!date) {
        return false;
    }
    if (__WEBPACK_IMPORTED_MODULE_1_moment___default.a.isMoment(date)) {
        return date.isValid();
    }
    return false;
}
function parseDateMath(mathString, time, roundUp) {
    var dateTime = time;
    var i = 0;
    var len = mathString.length;
    while (i < len) {
        var c = mathString.charAt(i++);
        var type;
        var num;
        var unit;
        if (c === '/') {
            type = 0;
        }
        else if (c === '+') {
            type = 1;
        }
        else if (c === '-') {
            type = 2;
        }
        else {
            return undefined;
        }
        if (isNaN(mathString.charAt(i))) {
            num = 1;
        }
        else if (mathString.length === 2) {
            num = mathString.charAt(i);
        }
        else {
            var numFrom = i;
            while (!isNaN(mathString.charAt(i))) {
                i++;
                if (i > 10) {
                    return undefined;
                }
            }
            num = parseInt(mathString.substring(numFrom, i), 10);
        }
        if (type === 0) {
            // rounding is only allowed on whole, single, units (eg M or 1M, not 0.5M or 2M)
            if (num !== 1) {
                return undefined;
            }
        }
        unit = mathString.charAt(i++);
        if (!__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.contains(units, unit)) {
            return undefined;
        }
        else {
            if (type === 0) {
                if (roundUp) {
                    dateTime.endOf(unit);
                }
                else {
                    dateTime.startOf(unit);
                }
            }
            else if (type === 1) {
                dateTime.add(num, unit);
            }
            else if (type === 2) {
                dateTime.subtract(num, unit);
            }
        }
    }
    return dateTime;
}


/***/ }),

/***/ 129:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
  'use strict';

  return {
    get: function(key) {
      return window.localStorage[key];
    },
    set: function(key, value) {
      window.localStorage[key] = value;
    },
    getBool: function(key, def) {
      if (def !== void 0 && !this.exists(key)) {
        return def;
      }
      return window.localStorage[key] === 'true';
    },
    exists: function(key) {
      return window.localStorage[key] !== void 0;
    },
    delete: function(key) {
      window.localStorage.removeItem(key);
    }

  };

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 158:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
};
exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);
/* tslint:disable:no-unused-variable */
var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
var freeGlobal = objectTypes[typeof global] && global;
if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    exports.root = freeGlobal;
}
//# sourceMappingURL=root.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(127)(module), __webpack_require__(69)))

/***/ }),

/***/ 2:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
///<reference path="../headers/common.d.ts" />

/* harmony default export */ __webpack_exports__["default"] = (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.module('grafana.core', ['ngRoute']));


/***/ }),

/***/ 200:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__directives_annotation_tooltip__ = __webpack_require__(670);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__directives_annotation_tooltip___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__directives_annotation_tooltip__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__directives_dash_class__ = __webpack_require__(671);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__directives_dash_class___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__directives_dash_class__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__directives_confirm_click__ = __webpack_require__(672);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__directives_confirm_click___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__directives_confirm_click__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__directives_dash_edit_link__ = __webpack_require__(673);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__directives_dash_edit_link___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__directives_dash_edit_link__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__directives_dash_upload__ = __webpack_require__(674);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__directives_dash_upload___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__directives_dash_upload__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__directives_dropdown_typeahead__ = __webpack_require__(675);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__directives_dropdown_typeahead___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__directives_dropdown_typeahead__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__directives_grafana_version_check__ = __webpack_require__(676);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__directives_grafana_version_check___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__directives_grafana_version_check__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__directives_metric_segment__ = __webpack_require__(677);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__directives_metric_segment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__directives_metric_segment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__directives_misc__ = __webpack_require__(678);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__directives_misc___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__directives_misc__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__directives_ng_model_on_blur__ = __webpack_require__(679);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__directives_ng_model_on_blur___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__directives_ng_model_on_blur__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__directives_password_strenght__ = __webpack_require__(680);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__directives_password_strenght___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__directives_password_strenght__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__directives_spectrum_picker__ = __webpack_require__(681);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__directives_spectrum_picker___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11__directives_spectrum_picker__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__directives_tags__ = __webpack_require__(682);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__directives_tags___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12__directives_tags__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__directives_value_select_dropdown__ = __webpack_require__(683);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__directives_value_select_dropdown___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13__directives_value_select_dropdown__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__directives_plugin_component__ = __webpack_require__(684);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__directives_rebuild_on_change__ = __webpack_require__(689);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__directives_give_focus__ = __webpack_require__(690);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__jquery_extended__ = __webpack_require__(691);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__jquery_extended___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17__jquery_extended__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__partials__ = __webpack_require__(692);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__partials___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18__partials__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__directives_system_panel__ = __webpack_require__(693);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__directives_service_dep__ = __webpack_require__(694);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__directives_service_dep___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_20__directives_service_dep__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__directives_log_tabpane__ = __webpack_require__(695);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__directives_log_tabpane___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_21__directives_log_tabpane__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__directives_tagpicker__ = __webpack_require__(696);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__directives_tagpicker___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_22__directives_tagpicker__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__directives_loading__ = __webpack_require__(697);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__directives_ng_enter__ = __webpack_require__(698);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__directives_auto_refresh__ = __webpack_require__(699);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__components_topology_graph__ = __webpack_require__(700);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__components_guide_guide__ = __webpack_require__(701);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__components_toolbar_toolbar__ = __webpack_require__(702);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__components_cwiz_switch__ = __webpack_require__(703);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__components_tree_menu_tree_menu__ = __webpack_require__(704);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__components_knowledge_base_knowledgeBase__ = __webpack_require__(705);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__components_time_window_time_window__ = __webpack_require__(706);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__components_time_window_time_window___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_32__components_time_window_time_window__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__components_grafana_app__ = __webpack_require__(707);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__components_sidemenu_sidemenu__ = __webpack_require__(708);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__components_sidemenu_sidemenu___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_34__components_sidemenu_sidemenu__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__components_search_search__ = __webpack_require__(709);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__components_search_search___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_35__components_search_search__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__components_info_popover__ = __webpack_require__(710);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__components_colorpicker__ = __webpack_require__(711);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__components_navbar_navbar__ = __webpack_require__(712);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__directives_array_join__ = __webpack_require__(713);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__live_live_srv__ = __webpack_require__(714);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__utils_emitter__ = __webpack_require__(365);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__components_layout_selector_layout_selector__ = __webpack_require__(724);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__components_switch__ = __webpack_require__(725);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__components_dashboard_selector__ = __webpack_require__(726);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45_app_core_controllers_all__ = __webpack_require__(727);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45_app_core_controllers_all___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_45_app_core_controllers_all__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46_app_core_services_all__ = __webpack_require__(739);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46_app_core_services_all___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_46_app_core_services_all__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47_app_core_routes_routes__ = __webpack_require__(763);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__filters_filters__ = __webpack_require__(767);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49__core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_50__app_events__ = __webpack_require__(367);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_51__utils_colors__ = __webpack_require__(768);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52_app_core_i18n_locale_provider__ = __webpack_require__(769);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52_app_core_i18n_locale_provider___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_52_app_core_i18n_locale_provider__);
/* unused harmony reexport arrayJoin */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_49__core_module__["default"]; });
/* unused harmony reexport grafanaAppDirective */
/* unused harmony reexport sideMenuDirective */
/* unused harmony reexport navbarDirective */
/* unused harmony reexport searchDirective */
/* unused harmony reexport colorPicker */
/* unused harmony reexport liveSrv */
/* unused harmony reexport layoutSelector */
/* unused harmony reexport switchDirective */
/* unused harmony reexport infoPopover */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_41__utils_emitter__["a"]; });
/* unused harmony reexport appEvents */
/* unused harmony reexport dashboardSelector */
/* unused harmony reexport tagPicker */
/* unused harmony reexport colors */
/* unused harmony reexport topologyGraphDirective */
/* unused harmony reexport guideDirective */
/* unused harmony reexport toolbarDirective */
/* unused harmony reexport cwizSwitchDirective */
/* unused harmony reexport treeMenu */
/* unused harmony reexport knowledgeBaseDirective */
/* unused harmony reexport timeWindowDirective */
/* unused harmony reexport autoRefresh */
///<reference path="../headers/common.d.ts" />
///<reference path="./mod_defs.d.ts" />



















//Cloudwiz





































/***/ }),

/***/ 24:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(668),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Settings) {
  "use strict";

  var bootData = window.grafanaBootData || { settings: {} };
  var options = bootData.settings;
  options.bootData = bootData;

  return new Settings(options);

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 361:
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() {
		throw new Error("Cannot find module '" + req + "'.");
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 361;

/***/ }),

/***/ 362:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;
//# sourceMappingURL=isFunction.js.map

/***/ }),

/***/ 363:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// typeof any so that it we don't have to cast when comparing a result to the error object
exports.errorObject = { e: {} };
//# sourceMappingURL=errorObject.js.map

/***/ }),

/***/ 364:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(158);
var Symbol = root_1.root.Symbol;
/**
 * rxSubscriber symbol is a symbol for retrieving an "Rx safe" Observer from an object
 * "Rx safety" can be defined as an object that has all of the traits of an Rx Subscriber,
 * including the ability to add and remove subscriptions to the subscription chain and
 * guarantees involving event triggering (can't "next" after unsubscription, etc).
 */
exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';
//# sourceMappingURL=rxSubscriber.js.map

/***/ }),

/***/ 365:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Emitter; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_eventemitter3__ = __webpack_require__(366);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_eventemitter3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_eventemitter3__);
///<reference path="../../headers/common.d.ts" />

var hasOwnProp = {}.hasOwnProperty;
function createName(name) {
    return '$' + name;
}
var Emitter = /** @class */ (function () {
    function Emitter() {
        this.emitter = new __WEBPACK_IMPORTED_MODULE_0_eventemitter3___default.a();
    }
    Emitter.prototype.emit = function (name, data) {
        this.emitter.emit(name, data);
    };
    Emitter.prototype.on = function (name, handler, scope) {
        var _this = this;
        this.emitter.on(name, handler);
        if (scope) {
            scope.$on('$destroy', function () {
                _this.emitter.off(name, handler);
            });
        }
    };
    Emitter.prototype.off = function (name, handler) {
        this.emitter.off(name, handler);
    };
    return Emitter;
}());



/***/ }),

/***/ 367:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_emitter__ = __webpack_require__(365);
///<reference path="../headers/common.d.ts" />

var appEvents = new __WEBPACK_IMPORTED_MODULE_0__utils_emitter__["a" /* Emitter */]();
/* harmony default export */ __webpack_exports__["a"] = (appEvents);


/***/ }),

/***/ 455:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["getRelativeTimesList"] = getRelativeTimesList;
/* harmony export (immutable) */ __webpack_exports__["describeTextRange"] = describeTextRange;
/* harmony export (immutable) */ __webpack_exports__["describeTimeRange"] = describeTimeRange;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__datemath__ = __webpack_require__(128);
///<reference path="../../headers/common.d.ts" />



var language = (window.localStorage.getItem('CLOUDWIZ_LANG_KEY')) || 'zh_CN';
var spans = {
    's': { display: '' },
    'm': { display: '' },
    'h': { display: '' },
    'd': { display: '' },
    'w': { display: '' },
    'M': { display: '' },
    'y': { display: '' },
};
var rangeOptions = [
    { from: 'now/d', to: 'now/d', display: '', section: 2 },
    { from: 'now/d', to: 'now', display: '', section: 2 },
    { from: 'now/w', to: 'now/w', display: '', section: 2 },
    { from: 'now/w', to: 'now', display: '', section: 2 },
    { from: 'now/M', to: 'now/M', display: '', section: 2 },
    { from: 'now/y', to: 'now/y', display: '', section: 2 },
    { from: 'now-1d/d', to: 'now-1d/d', display: '', section: 1 },
    { from: 'now-2d/d', to: 'now-2d/d', display: '', section: 1 },
    { from: 'now-7d/d', to: 'now-7d/d', display: '', section: 1 },
    { from: 'now/w', to: 'now+1w/w', display: '', section: 1 },
    { from: 'now/M', to: 'now+1M/M', display: '', section: 1 },
    { from: 'now/y', to: 'now+1y/y', display: '', section: 1 },
    { from: 'now-5m', to: 'now', display: '5  ', section: 3 },
    { from: 'now-15m', to: 'now', display: '15 ', section: 3 },
    { from: 'now-30m', to: 'now', display: '30 ', section: 3 },
    { from: 'now-1h', to: 'now', display: '1  ', section: 3 },
    { from: 'now-6h', to: 'now', display: '6  ', section: 3 },
    { from: 'now-12h', to: 'now', display: '12 ', section: 3 },
    { from: 'now-24h', to: 'now', display: '24 ', section: 3 },
    { from: 'now-7d', to: 'now', display: '7  ', section: 3 },
    { from: 'now-30d', to: 'now', display: '30 ', section: 0 },
    { from: 'now-60d', to: 'now', display: '60 ', section: 0 },
    { from: 'now-90d', to: 'now', display: '90 ', section: 0 },
    { from: 'now-6M', to: 'now', display: '6  ', section: 0 },
    { from: 'now-1y', to: 'now', display: '1  ', section: 0 },
    { from: 'now-2y', to: 'now', display: '2  ', section: 0 },
    { from: 'now-5y', to: 'now', display: '5  ', section: 0 },
];
var toText = '  ';
var agoText = '';
if (language === 'en') {
    spans = {
        's': { display: 'second' },
        'm': { display: 'minute' },
        'h': { display: 'hour' },
        'd': { display: 'day' },
        'w': { display: 'week' },
        'M': { display: 'month' },
        'y': { display: 'year' },
    };
    rangeOptions = rangeOptions = [
        { from: 'now/d', to: 'now/d', display: 'Today', section: 2 },
        { from: 'now/d', to: 'now', display: 'Today so far', section: 2 },
        { from: 'now/w', to: 'now/w', display: 'This week', section: 2 },
        { from: 'now/w', to: 'now', display: 'This week so far', section: 2 },
        { from: 'now/M', to: 'now/M', display: 'This month', section: 2 },
        { from: 'now/y', to: 'now/y', display: 'This year', section: 2 },
        { from: 'now-1d/d', to: 'now-1d/d', display: 'Yesterday', section: 1 },
        { from: 'now-2d/d', to: 'now-2d/d', display: 'Day before yesterday', section: 1 },
        { from: 'now-7d/d', to: 'now-7d/d', display: 'This day last week', section: 1 },
        { from: 'now-1w/w', to: 'now-1w/w', display: 'Previous week', section: 1 },
        { from: 'now-1M/M', to: 'now-1M/M', display: 'Previous month', section: 1 },
        { from: 'now-1y/y', to: 'now-1y/y', display: 'Previous year', section: 1 },
        { from: 'now-5m', to: 'now', display: 'Last 5 minutes', section: 3 },
        { from: 'now-15m', to: 'now', display: 'Last 15 minutes', section: 3 },
        { from: 'now-30m', to: 'now', display: 'Last 30 minutes', section: 3 },
        { from: 'now-1h', to: 'now', display: 'Last 1 hour', section: 3 },
        { from: 'now-3h', to: 'now', display: 'Last 3 hours', section: 3 },
        { from: 'now-6h', to: 'now', display: 'Last 6 hours', section: 3 },
        { from: 'now-12h', to: 'now', display: 'Last 12 hours', section: 3 },
        { from: 'now-24h', to: 'now', display: 'Last 24 hours', section: 3 },
        { from: 'now-7d', to: 'now', display: 'Last 7 days', section: 0 },
        { from: 'now-30d', to: 'now', display: 'Last 30 days', section: 0 },
        { from: 'now-60d', to: 'now', display: 'Last 60 days', section: 0 },
        { from: 'now-90d', to: 'now', display: 'Last 90 days', section: 0 },
        { from: 'now-6M', to: 'now', display: 'Last 6 months', section: 0 },
        { from: 'now-1y', to: 'now', display: 'Last 1 year', section: 0 },
        { from: 'now-2y', to: 'now', display: 'Last 2 years', section: 0 },
        { from: 'now-5y', to: 'now', display: 'Last 5 years', section: 0 },
    ];
    toText = ' to ';
    agoText = 'ago';
}
var absoluteFormat = 'MMM D, YYYY HH:mm:ss';
var rangeIndex = {};
__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(rangeOptions, function (frame) {
    rangeIndex[frame.from + toText + frame.to] = frame;
});
function getRelativeTimesList(timepickerSettings, currentDisplay) {
    var groups = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.groupBy(rangeOptions, function (option) {
        option.active = option.display === currentDisplay;
        return option.section;
    });
    return groups;
}
function formatDate(date) {
    return date.format(absoluteFormat);
}
// handles expressions like
// 5m
// 5m to now/d
// now/d to now
// now/d
// if no to <expr> then to now is assumed
function describeTextRange(expr) {
    if (expr.indexOf('now') === -1) {
        expr = 'now-' + expr;
    }
    var opt = rangeIndex[expr + ' to now'];
    if (opt) {
        return opt;
    }
    opt = { from: expr, to: 'now' };
    var parts = /^now-(\d+)(\w)/.exec(expr);
    if (parts) {
        var unit = parts[2];
        var amount = parseInt(parts[1]);
        var span = spans[unit];
        if (span) {
            opt.display = amount + ' ' + span.display + agoText;
            opt.section = span.section;
            // if (amount > 1) {
            //   opt.display += 's';
            // }
        }
    }
    else {
        opt.display = opt.from + toText + opt.to;
        opt.invalid = true;
    }
    return opt;
}
function describeTimeRange(range) {
    var option = rangeIndex[range.from.toString() + toText + range.to.toString()];
    if (option) {
        return option.display;
    }
    if (__WEBPACK_IMPORTED_MODULE_1_moment___default.a.isMoment(range.from) && __WEBPACK_IMPORTED_MODULE_1_moment___default.a.isMoment(range.to)) {
        return formatDate(range.from) + toText + formatDate(range.to);
    }
    if (__WEBPACK_IMPORTED_MODULE_1_moment___default.a.isMoment(range.from)) {
        var toMoment = __WEBPACK_IMPORTED_MODULE_2__datemath__["parse"](range.to, true);
        return formatDate(range.from) + toText + toMoment.fromNow();
    }
    if (__WEBPACK_IMPORTED_MODULE_1_moment___default.a.isMoment(range.to)) {
        var from = __WEBPACK_IMPORTED_MODULE_2__datemath__["parse"](range.from, false);
        return from.fromNow() + toText + formatDate(range.to);
    }
    if (range.to.toString() === 'now') {
        var res = describeTextRange(range.from);
        return res.display;
    }
    return range.from.toString() + toText + range.to.toString();
}


/***/ }),

/***/ 456:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueryCtrl", function() { return QueryCtrl; });
///<reference path="../../headers/common.d.ts" />
var QueryCtrl = /** @class */ (function () {
    function QueryCtrl($scope, $injector) {
        this.$scope = $scope;
        this.$injector = $injector;
        this.panel = this.panelCtrl.panel;
    }
    QueryCtrl.prototype.refresh = function () {
        this.panelCtrl.refresh();
    };
    return QueryCtrl;
}());



/***/ }),

/***/ 457:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__app__ = __webpack_require__(458);
// (function bootGrafana() {
//   'use strict';
//   var systemLocate = System.locate;
//   System.locate = function(load) {
//     var System = this;
//     return Promise.resolve(systemLocate.call(this, load)).then(function(address) {
//       return address + System.cacheBust;
//     });
//   };
//   System.cacheBust = '?bust=' + Date.now();
//   System.import('app/app').then(function(app) {
//     app.default.init();
//   }).catch(function(err) {
//     console.log('Loading app module failed: ', err);
//   });
// })();

__WEBPACK_IMPORTED_MODULE_0__app__["a" /* default */].init();


/***/ }),

/***/ 458:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export GrafanaApp */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_polyfill__ = __webpack_require__(202);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_polyfill___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_polyfill__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_file_saver__ = __webpack_require__(237);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_file_saver___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_file_saver__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_angular_route__ = __webpack_require__(238);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_angular_route___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_angular_route__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_angular_sanitize__ = __webpack_require__(239);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_angular_sanitize___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_angular_sanitize__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_angular_native_dragdrop__ = __webpack_require__(240);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_angular_native_dragdrop___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_angular_native_dragdrop__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_angular_bindonce__ = __webpack_require__(241);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_angular_bindonce___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_angular_bindonce__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_vendor_bootstrap_bootstrap__ = __webpack_require__(1225);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_vendor_bootstrap_bootstrap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_vendor_bootstrap_bootstrap__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_vendor_angular_other_angular_strap__ = __webpack_require__(1226);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_vendor_angular_other_angular_strap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_vendor_angular_other_angular_strap__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_vendor_angular_ui_ui_bootstrap_tpls__ = __webpack_require__(1227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_vendor_angular_ui_ui_bootstrap_tpls___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_vendor_angular_ui_ui_bootstrap_tpls__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_vendor_angular_ui_calendar_src_calendar__ = __webpack_require__(1228);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_vendor_angular_ui_calendar_src_calendar___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_vendor_angular_ui_calendar_src_calendar__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_vendor_angular_other_angular_strap_tpl__ = __webpack_require__(1229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_vendor_angular_other_angular_strap_tpl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_vendor_angular_other_angular_strap_tpl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_vendor_angular_other_angular_strap_old__ = __webpack_require__(1230);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_vendor_angular_other_angular_strap_old___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_vendor_angular_other_angular_strap_old__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_vendor_jsPlumb_jsPlumbToolkit__ = __webpack_require__(1231);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_vendor_jsPlumb_jsPlumbToolkit___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_vendor_jsPlumb_jsPlumbToolkit__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_vendor_quill_ng_quill__ = __webpack_require__(1232);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_vendor_quill_ng_quill___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_vendor_quill_ng_quill__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_vendor_angular_other_ng_table_min__ = __webpack_require__(1233);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_vendor_angular_other_ng_table_min___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_vendor_angular_other_ng_table_min__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_app_core_config__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_app_core_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18_app_core_config__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__core_core__ = __webpack_require__(200);
///<reference path="headers/common.d.ts" />
























var GrafanaApp = /** @class */ (function () {
    function GrafanaApp() {
        this.preBootModules = [];
        this.registerFunctions = {};
        this.ngModuleDependencies = [];
    }
    GrafanaApp.prototype.useModule = function (module) {
        if (this.preBootModules) {
            this.preBootModules.push(module);
        }
        else {
            __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.extend(module, this.registerFunctions);
        }
        this.ngModuleDependencies.push(module.name);
        return module;
    };
    GrafanaApp.prototype.init = function () {
        var _this = this;
        var app = __WEBPACK_IMPORTED_MODULE_4_angular___default.a.module('grafana', ['mgcrea.ngStrap', 'ngAnimate', 'ngTable', 'cloudwiz.translate']);
        app.constant('grafanaVersion', "@grafanaVersion@");
        console.log(__WEBPACK_IMPORTED_MODULE_18_app_core_config___default.a.bootData.user.locale);
        __WEBPACK_IMPORTED_MODULE_19_moment___default.a.locale(__WEBPACK_IMPORTED_MODULE_18_app_core_config___default.a.bootData.user.locale);
        app.config(['$translateProvider', function ($translateProvider) {
                $translateProvider.useStaticFilesLoader({
                    prefix: 'public/app/core/i18n/',
                    suffix: '.json'
                });
                $translateProvider.determinePreferredLanguage().fallbackLanguage('zh_CN');
                $translateProvider.useLocalStorage();
            }]);
        app.config(function ($locationProvider, $controllerProvider, $compileProvider, $filterProvider, $provide) {
            //$compileProvider.debugInfoEnabled(false);
            $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|data|chrome-extension|javascript):/);
            _this.registerFunctions.controller = $controllerProvider.register;
            _this.registerFunctions.directive = $compileProvider.directive;
            _this.registerFunctions.factory = $provide.factory;
            _this.registerFunctions.service = $provide.service;
            _this.registerFunctions.filter = $filterProvider.register;
            $provide.decorator("$http", ["$delegate", "$templateCache", function ($delegate, $templateCache) {
                    var get = $delegate.get;
                    $delegate.get = function (url, config) {
                        if (url.match(/\.html$/)) {
                            // some template's already exist in the cache
                            if (!$templateCache.get(url)) {
                                url += "?v=" + new Date().getTime();
                            }
                        }
                        return get(url, config);
                    };
                    return $delegate;
                }]);
        });
        this.ngModuleDependencies = [
            'grafana.core',
            'ngRoute',
            'ngSanitize',
            '$strap.directives',
            'ang-drag-drop',
            'grafana',
            'pasvaz.bindonce',
            'ui.bootstrap',
            'ui.bootstrap.tpls',
            'ui.calendar',
            'ngQuill'
        ];
        var module_types = ['controllers', 'directives', 'factories', 'services', 'filters', 'routes'];
        __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.each(module_types, function (type) {
            var moduleName = 'grafana.' + type;
            _this.useModule(__WEBPACK_IMPORTED_MODULE_4_angular___default.a.module(moduleName, []));
        });
        // makes it possible to add dynamic stuff
        this.useModule(__WEBPACK_IMPORTED_MODULE_20__core_core__["b" /* coreModule */]);
        var preBootRequires = [__webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 1171))];
        Promise.all(preBootRequires).then(function () {
            // disable tool tip animation
            __WEBPACK_IMPORTED_MODULE_3_jquery___default.a.fn.tooltip.defaults.animation = false;
            // bootstrap the app
            __WEBPACK_IMPORTED_MODULE_4_angular___default.a.bootstrap(document, _this.ngModuleDependencies).invoke(function () {
                __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.each(_this.preBootModules, function (module) {
                    __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.extend(module, _this.registerFunctions);
                });
                _this.preBootModules = null;
            });
        }).catch(function (err) {
            console.log('Application boot failed:', err);
        });
    };
    return GrafanaApp;
}());

/* harmony default export */ __webpack_exports__["a"] = (new GrafanaApp());


/***/ }),

/***/ 63:
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() {
		throw new Error("Cannot find module '" + req + "'.");
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 63;

/***/ }),

/***/ 668:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(3),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_) {
  "use strict";

  return function Settings (options) {
    var defaults = {
      datasources                   : {},
      window_title_prefix           : 'Cloudwiz  - ',
      panels                        : {},
      new_panel_title: 'Panel Title',
      playlist_timespan: "1m",
      unsaved_changes_warning: true,
      appSubUrl: ""
    };

    return _.extend({}, defaults, options);
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 670:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(16),
  __webpack_require__(3),
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, _, coreModule) {
  'use strict';

  coreModule.default.directive('annotationTooltip', function($sanitize, dashboardSrv, $compile) {

    function sanitizeString(str) {
      try {
        return $sanitize(str);
      }
      catch(err) {
        console.log('Could not sanitize annotation string, html escaping instead');
        return _.escape(str);
      }
    }

    return {
      link: function (scope, element) {
        var event = scope.event;
        var title = sanitizeString(event.title);
        var dashboard = dashboardSrv.getCurrent();
        var time = '<i>' + dashboard.formatDate(event.min) + '</i>';

        var tooltip = '<div class="graph-annotation">';
        tooltip += '<div class="graph-annotation-title">' + title + "</div>";

        if (event.text) {
          var text = sanitizeString(event.text);
          tooltip += text.replace(/\n/g, '<br>') + '<br>';
        }

        var tags = event.tags;
        if (_.isString(event.tags)) {
          tags = event.tags.split(',');
          if (tags.length === 1) {
            tags = event.tags.split(' ');
          }
        }

        if (tags && tags.length) {
          scope.tags = tags;
          tooltip += '<span class="label label-tag small" ng-repeat="tag in tags" tag-color-from-name="tag">{{tag}}</span><br/>';
        }

        tooltip += '<div class="graph-annotation-time">' + time + '</div>' ;
        tooltip += "</div>";

        var $tooltip = $(tooltip);
        $tooltip.appendTo(element);

        $compile(element.contents())(scope);
      }
    };
  });

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 671:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(3),
  __webpack_require__(16),
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, $, coreModule) {
  'use strict';

  coreModule.default.directive('dashClass', function() {
    return {
      link: function($scope, elem) {

        var lastHideControlsVal;

        $scope.onAppEvent('panel-fullscreen-enter', function() {
          elem.toggleClass('panel-in-fullscreen', true);
        });

        $scope.onAppEvent('panel-fullscreen-exit', function() {
          elem.toggleClass('panel-in-fullscreen', false);
        });

        $scope.$watch('dashboard.hideControls', function() {
          if (!$scope.dashboard) {
            return;
          }

          var hideControls = $scope.dashboard.hideControls || $scope.playlist_active;

          if (lastHideControlsVal !== hideControls) {
            elem.toggleClass('hide-controls', hideControls);
            lastHideControlsVal = hideControls;
          }
        });

        $scope.$watch('playlistSrv', function(newValue) {
          elem.toggleClass('playlist-active', _.isObject(newValue));
        });
      }
    };
  });

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 672:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (coreModule) {
  'use strict';

  coreModule.default.directive('confirmClick', function() {
    return {
      restrict: 'A',
      link: function(scope, elem, attrs) {
        elem.bind('click', function() {
          var message = attrs.confirmation || "Are you sure you want to do that?";
          if (window.confirm(message)) {
            var action = attrs.confirmClick;
            if (action) {
              scope.$apply(scope.$eval(action));
            }
          }
        });
      },
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 673:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(16),
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, coreModule) {
  'use strict';

  var editViewMap = {
    'settings':    { src: 'public/app/features/dashboard/partials/settings.html', title: "Settings" },
    'annotations': { src: 'public/app/features/annotations/partials/editor.html', title: "Annotations" },
    'templating':  { src: 'public/app/features/templating/partials/editor.html', title: "Templating" }
  };

  coreModule.default.directive('dashEditorLink', function($timeout) {
    return {
      restrict: 'A',
      link: function(scope, elem, attrs) {
        var partial = attrs.dashEditorLink;

        elem.bind('click',function() {
          $timeout(function() {
            var editorScope = attrs.editorScope === 'isolated' ? null : scope;
            scope.appEvent('show-dash-editor', { src: partial, scope: editorScope });
          });
        });
      }
    };
  });

  coreModule.default.directive('dashEditorView', function($compile, $location) {
    return {
      restrict: 'A',
      link: function(scope, elem) {
        var editorScope;
        var lastEditor;

        function hideEditorPane() {
          if (editorScope) {
            scope.appEvent('dash-editor-hidden', lastEditor);
            editorScope.dismiss();
          }
        }

        function showEditorPane(evt, payload, editview) {
          if (editview) {
            scope.contextSrv.editview = editViewMap[editview];
            payload.src = scope.contextSrv.editview.src;
          }

          if (lastEditor === payload.src) {
            hideEditorPane();
            return;
          }

          hideEditorPane();

          lastEditor = payload.src;
          editorScope = payload.scope ? payload.scope.$new() : scope.$new();

          editorScope.dismiss = function() {
            editorScope.$destroy();
            elem.empty();
            lastEditor = null;
            editorScope = null;

            if (editview) {
              var urlParams = $location.search();
              if (editview === urlParams.editview) {
                delete urlParams.editview;
                $location.search(urlParams);
              }
            }
          };

          var src = "'" + payload.src + "'";
          var view = $('<div class="tabbed-view" ng-include="' + src + '"></div>');

          elem.append(view);
          $compile(elem.contents())(editorScope);
        }

        scope.$watch("dashboardViewState.state.editview", function(newValue, oldValue) {
          if (newValue) {
            showEditorPane(null, {}, newValue);
          } else if (oldValue) {
            scope.contextSrv.editview = null;
            if (lastEditor === editViewMap[oldValue]) {
              hideEditorPane();
            }
          }
        });

        scope.contextSrv.editview = null;
        scope.$on("$destroy", hideEditorPane);
        scope.onAppEvent('hide-dash-editor', hideEditorPane);
        scope.onAppEvent('show-dash-editor', showEditorPane);
      }
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 674:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(2),
  __webpack_require__(93),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (coreModule, kbn) {
  'use strict';

  kbn = kbn.default;

  coreModule.default.directive('dashUpload', function(timer, alertSrv, $location) {
    return {
      restrict: 'A',
      link: function(scope) {
        function file_selected(evt) {
          var files = evt.target.files; // FileList object
          var readerOnload = function() {
            return function(e) {
              scope.$apply(function() {
                try {
                  window.grafanaImportDashboard = JSON.parse(e.target.result);
                } catch (err) {
                  console.log(err);
                  scope.appEvent('alert-error', [' ', 'JSON -> JS Serialization failed: ' + err.message]);
                  return;
                }
                var title = kbn.slugifyForUrl(window.grafanaImportDashboard.title);
                title += new Date().getTime();
                window.grafanaImportDashboard.id = null;
                $location.path('/dashboard-import/' + title);
              });
            };
          };
          for (var i = 0, f; f = files[i]; i++) {
            var reader = new FileReader();
            reader.onload = (readerOnload)(f);
            reader.readAsText(f);
          }
        }
        // Check for the various File API support.
        if (window.File && window.FileReader && window.FileList && window.Blob) {
          // Something
          document.getElementById('dashupload').addEventListener('change', file_selected, false);
        } else {
          alertSrv.set('',', ,/','error');
        }
      }
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 675:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(3),
  __webpack_require__(16),
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, $, coreModule) {
  'use strict';

  coreModule.default.directive('dropdownTypeahead', function($compile) {

    var inputTemplate = '<input type="text"'+
      ' class="gf-form-input input-medium tight-form-input"' +
      ' spellcheck="false" style="display:none"></input>';

    var buttonTemplate = '<a  class="gf-form-label tight-form-func dropdown-toggle"' +
      ' tabindex="1" gf-dropdown="menuItems" data-toggle="dropdown"' +
      ' data-placement="top"><i class="fa fa-plus"></i></a>';

    return {
      scope: {
        menuItems: "=dropdownTypeahead",
        dropdownTypeaheadOnSelect: "&dropdownTypeaheadOnSelect",
        model: '=ngModel'
      },
      link: function($scope, elem, attrs) {
        var $input = $(inputTemplate);
        var $button = $(buttonTemplate);
        $input.appendTo(elem);
        $button.appendTo(elem);

        if (attrs.linkText) {
          $button.html(attrs.linkText);
        }

        if (attrs.ngModel) {
          $scope.$watch('model', function(newValue) {
            _.each($scope.menuItems, function(item) {
              _.each(item.submenu, function(subItem) {
                if (subItem.value === newValue) {
                  $button.html(subItem.text);
                }
              });
            });
          });
        }

        var typeaheadValues = _.reduce($scope.menuItems, function(memo, value, index) {
          if (!value.submenu) {
            value.click = 'menuItemSelected(' + index + ')';
            memo.push(value.text);
          } else {
            _.each(value.submenu, function(item, subIndex) {
              item.click = 'menuItemSelected(' + index + ',' + subIndex + ')';
              memo.push(value.text + ' ' + item.text);
            });
          }
          return memo;
        }, []);

        $scope.menuItemSelected = function(index, subIndex) {
          var menuItem = $scope.menuItems[index];
          var payload = {$item: menuItem};
          if (menuItem.submenu && subIndex !== void 0) {
            payload.$subItem = menuItem.submenu[subIndex];
          }
          $scope.dropdownTypeaheadOnSelect(payload);
        };

        $input.attr('data-provide', 'typeahead');
        $input.typeahead({
          source: typeaheadValues,
          minLength: 1,
          items: 10,
          updater: function (value) {
            var result = {};
            _.each($scope.menuItems, function(menuItem) {
              _.each(menuItem.submenu, function(submenuItem) {
                if (value === (menuItem.text + ' ' + submenuItem.text)) {
                  result.$subItem = submenuItem;
                  result.$item = menuItem;
                }
              });
            });

            if (result.$item) {
              $scope.$apply(function() {
                $scope.dropdownTypeaheadOnSelect(result);
              });
            }

            $input.trigger('blur');
            return '';
          }
        });

        $button.click(function() {
          $button.hide();
          $input.show();
          $input.focus();
        });

        $input.keyup(function() {
          elem.toggleClass('open', $input.val() === '');
        });

        $input.blur(function() {
          $input.hide();
          $input.val('');
          $button.show();
          $button.focus();
          // clicking the function dropdown menu wont
          // work if you remove class at once
          setTimeout(function() {
            elem.removeClass('open');
          }, 200);
        });

        $compile(elem.contents())($scope);
      }
    };
  });

  coreModule.default.directive('dropdownTypeahead2', function($compile) {

    var inputTemplate = '<input type="text"'+
      ' class="gf-form-input"' +
      ' spellcheck="false" style="display:none"></input>';

    var buttonTemplate = '<a class="gf-form-input dropdown-toggle"' +
      ' tabindex="1" gf-dropdown="menuItems" data-toggle="dropdown"' +
      ' data-placement="top"><i class="fa fa-plus"></i></a>';

    return {
      scope: {
        menuItems: "=dropdownTypeahead2",
        dropdownTypeaheadOnSelect: "&dropdownTypeaheadOnSelect",
        model: '=ngModel'
      },
      link: function($scope, elem, attrs) {
        var $input = $(inputTemplate);
        var $button = $(buttonTemplate);
        $input.appendTo(elem);
        $button.appendTo(elem);

        if (attrs.linkText) {
          $button.html(attrs.linkText);
        }

        if (attrs.ngModel) {
          $scope.$watch('model', function(newValue) {
            _.each($scope.menuItems, function(item) {
              _.each(item.submenu, function(subItem) {
                if (subItem.value === newValue) {
                  $button.html(subItem.text);
                }
              });
            });
          });
        }

        var typeaheadValues = _.reduce($scope.menuItems, function(memo, value, index) {
          if (!value.submenu) {
            value.click = 'menuItemSelected(' + index + ')';
            memo.push(value.text);
          } else {
            _.each(value.submenu, function(item, subIndex) {
              item.click = 'menuItemSelected(' + index + ',' + subIndex + ')';
              memo.push(value.text + ' ' + item.text);
            });
          }
          return memo;
        }, []);

        $scope.menuItemSelected = function(index, subIndex) {
          var menuItem = $scope.menuItems[index];
          var payload = {$item: menuItem};
          if (menuItem.submenu && subIndex !== void 0) {
            payload.$subItem = menuItem.submenu[subIndex];
          }
          $scope.dropdownTypeaheadOnSelect(payload);
        };

        $input.attr('data-provide', 'typeahead');
        $input.typeahead({
          source: typeaheadValues,
          minLength: 1,
          items: 10,
          updater: function (value) {
            var result = {};
            _.each($scope.menuItems, function(menuItem) {
              _.each(menuItem.submenu, function(submenuItem) {
                if (value === (menuItem.text + ' ' + submenuItem.text)) {
                  result.$subItem = submenuItem;
                  result.$item = menuItem;
                }
              });
            });

            if (result.$item) {
              $scope.$apply(function() {
                $scope.dropdownTypeaheadOnSelect(result);
              });
            }

            $input.trigger('blur');
            return '';
          }
        });

        $button.click(function() {
          $button.hide();
          $input.show();
          $input.focus();
        });

        $input.keyup(function() {
          elem.toggleClass('open', $input.val() === '');
        });

        $input.blur(function() {
          $input.hide();
          $input.val('');
          $button.show();
          $button.focus();
          // clicking the function dropdown menu wont
          // work if you remove class at once
          setTimeout(function() {
            elem.removeClass('open');
          }, 200);
        });

        $compile(elem.contents())($scope);
      }
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 676:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (coreModule) {
  'use strict';

  coreModule.default.directive('grafanaVersionCheck', function($http, contextSrv) {
    return {
      restrict: 'A',
      link: function(scope, elem) {
        if (contextSrv.version === 'master') {
          return;
        }

        $http({ method: 'GET', url: 'https://grafanarel.s3.amazonaws.com/latest.json' })
        .then(function(response) {
          if (!response.data || !response.data.version) {
            return;
          }

          if (contextSrv.version !== response.data.version) {
            elem.append('<i class="icon-info-sign"></i> ' +
                        '<a href="http://grafana.org/download" target="_blank"> ' +
            'New version available: ' + response.data.version +
              '</a>');
          }
        });
      }
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 677:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(3),
  __webpack_require__(16),
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_, $, coreModule) {
  'use strict';

  coreModule.default.directive('metricSegment', function($compile, $sce) {
    var inputTemplate = '<input type="text" data-provide="typeahead" ' +
      ' class="gf-form-input input-medium"' +
      ' spellcheck="false" style="display:none"></input>';

    var linkTemplate = '<a class="gf-form-label" ng-class="segment.cssClass" ' +
      'tabindex="1" give-focus="segment.focus" ng-bind-html="segment.html"></a>';

    var selectTemplate = '<a class="gf-form-input gf-form-input--dropdown" ng-class="segment.cssClass" ' +
      'tabindex="1" give-focus="segment.focus" ng-bind-html="segment.html"></a>';

    return {
      scope: {
        segment: "=",
        getOptions: "&",
        onChange: "&",
      },
      link: function($scope, elem, attrs) {
        var $input = $(inputTemplate);
        var $button = $(attrs.styleMode === 'select' ? selectTemplate : linkTemplate);
        var segment = $scope.segment;
        var options = null;
        var cancelBlur = null;
        var linkMode = true;

        $input.appendTo(elem);
        $button.appendTo(elem);

        $scope.updateVariableValue = function(value) {
          if (value === '' || segment.value === value) {
            return;
          }

          $scope.$apply(function() {
            var selected = _.findWhere($scope.altSegments, { value: value });
            if (selected) {
              segment.value = selected.value;
              segment.html = selected.html;
              segment.fake = false;
              segment.expandable = selected.expandable;
            }
            else if (segment.custom !== 'false') {
              segment.value = value;
              segment.html = $sce.trustAsHtml(value);
              segment.expandable = true;
              segment.fake = false;
            }

            $scope.onChange();
          });
        };

        $scope.switchToLink = function(fromClick) {
          if (linkMode && !fromClick) { return; }

          clearTimeout(cancelBlur);
          cancelBlur = null;
          linkMode = true;
          $input.hide();
          $button.show();
          $scope.updateVariableValue($input.val());
        };

        $scope.inputBlur = function() {
          // happens long before the click event on the typeahead options
          // need to have long delay because the blur
          cancelBlur = setTimeout($scope.switchToLink, 200);
        };

        $scope.source = function(query, callback) {
          if (options) { return options; }

          $scope.$apply(function() {
            $scope.getOptions().then(function(altSegments) {
              $scope.altSegments = altSegments;
              options = _.map($scope.altSegments, function(alt) { return alt.value; });

              // add custom values
              if (segment.custom !== 'false') {
                if (!segment.fake && _.indexOf(options, segment.value) === -1) {
                  options.unshift(segment.value);
                }
              }

              callback(options);
            });
          });
        };

        $scope.updater = function(value) {
          if (value === segment.value) {
            clearTimeout(cancelBlur);
            $input.focus();
            return value;
          }

          $input.val(value);
          $scope.switchToLink(true);

          return value;
        };

        $scope.matcher = function(item) {
          var str = this.query;
          if (str[0] === '/') { str = str.substring(1); }
          if (str[str.length - 1] === '/') { str = str.substring(0, str.length-1); }
          try {
            return item.toLowerCase().match(str);
          } catch(e) {
            return false;
          }
        };

        $input.attr('data-provide', 'typeahead');
        $input.typeahead({ source: $scope.source, minLength: 0, items: 10000, updater: $scope.updater, matcher: $scope.matcher });

        var typeahead = $input.data('typeahead');
        typeahead.lookup = function () {
          this.query = this.$element.val() || '';
          var items = this.source(this.query, $.proxy(this.process, this));
          return items ? this.process(items) : items;
        };

        $button.keydown(function(evt) {
          // trigger typeahead on down arrow or enter key
          if (evt.keyCode === 40 || evt.keyCode === 13) {
            $button.click();
          }
        });

        $button.click(function() {
          options = null;
          $input.css('width', ($button.width() + 16) + 'px');

          $button.hide();
          $input.show();
          $input.focus();

          linkMode = false;

          var typeahead = $input.data('typeahead');
          if (typeahead) {
            $input.val('');
            typeahead.lookup();
          }
        });

        $input.blur($scope.inputBlur);

        $compile(elem.contents())($scope);
      }
    };
  });

  coreModule.default.directive('metricSegmentModel', function(uiSegmentSrv, $q) {
    return {
      template: '<metric-segment segment="segment" get-options="getOptionsInternal()" on-change="onSegmentChange()"></metric-segment>',
      restrict: 'E',
      scope: {
        property: "=",
        options: "=",
        getOptions: "&",
        onChange: "&",
      },
      link: {
        pre: function postLink($scope, elem, attrs) {

          $scope.valueToSegment = function(value) {
            var option = _.findWhere($scope.options, {value: value});
            var segment = {
              cssClass: attrs.cssClass,
              custom: attrs.custom,
              value: option ? option.text : value,
            };
            return uiSegmentSrv.newSegment(segment);
          };

          $scope.getOptionsInternal = function() {
            if ($scope.options) {
              var optionSegments = _.map($scope.options, function(option) {
                return uiSegmentSrv.newSegment({value: option.text});
              });
              return $q.when(optionSegments);
            } else {
              return $scope.getOptions();
            }
          };

          $scope.onSegmentChange = function() {
            if ($scope.options) {
              var option = _.findWhere($scope.options, {text: $scope.segment.value});
              if (option && option.value !== $scope.property) {
                $scope.property = option.value;
              } else if (attrs.custom !== 'false') {
                $scope.property = $scope.segment.value;
              }
            } else {
              $scope.property = $scope.segment.value;
            }

            // needs to call this after digest so
            // property is synced with outerscope
            $scope.$$postDigest(function() {
              $scope.onChange();
            });
          };

          $scope.segment = $scope.valueToSegment($scope.property);
        }
      }
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 678:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(2),
  __webpack_require__(93),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, coreModule, kbn) {
  'use strict';

  kbn = kbn.default;

  coreModule.default.directive('tip', function($compile) {
    return {
      restrict: 'E',
      link: function(scope, elem, attrs) {
        var _t = '<i class="grafana-tip fa fa-'+(attrs.icon||'question-circle')+'" bs-tooltip="\''+
          kbn.addslashes(elem.html())+'\'" data-placement=' + (attrs.placement || 'top') + ' html=true></i>';
        _t = _t.replace(/{/g, '\\{').replace(/}/g, '\\}');
        elem.replaceWith($compile(angular.element(_t))(scope));
      }
    };
  });

  coreModule.default.directive('watchChange', function() {
    return {
      scope: { onchange: '&watchChange' },
      link: function(scope, element) {
        element.on('input', function() {
          scope.$apply(function () {
            scope.onchange({ inputValue: element.val() });
          });
        });
      }
    };
  });

  coreModule.default.directive('editorOptBool', function($compile) {
    return {
      restrict: 'E',
      link: function(scope, elem, attrs) {
        var ngchange = attrs.change ? (' ng-change="' + attrs.change + '"') : '';
        var tip = attrs.tip ? (' <tip>' + attrs.tip + '</tip>') : '';
        var showIf = attrs.showIf ? (' ng-show="' + attrs.showIf + '" ') : '';

        var template = '<div class="editor-option gf-form-checkbox text-center"' + showIf + '>' +
          ' <label for="' + attrs.model + '" class="small">' +
          attrs.text + tip + '</label>' +
          '<input class="cr1" id="' + attrs.model + '" type="checkbox" ' +
          '       ng-model="' + attrs.model + '"' + ngchange +
          '       ng-checked="' + attrs.model + '"></input>' +
          ' <label for="' + attrs.model + '" class="cr1"></label>';
        elem.replaceWith($compile(angular.element(template))(scope));
      }
    };
  });

  coreModule.default.directive('editorCheckbox', function($compile, $interpolate) {
    return {
      restrict: 'E',
      link: function(scope, elem, attrs) {
        var text = $interpolate(attrs.text)(scope);
        var model = $interpolate(attrs.model)(scope);
        var ngchange = attrs.change ? (' ng-change="' + attrs.change + '"') : '';
        var tip = attrs.tip ? (' <tip>' + attrs.tip + '</tip>') : '';
        var label = '<label for="' + scope.$id + model + '" class="checkbox-label">' +
          text + tip + '</label>';

        var template =
          '<input class="cr1" id="' + scope.$id + model + '" type="checkbox" ' +
          '       ng-model="' + model + '"' + ngchange +
          '       ng-checked="' + model + '"></input>' +
          ' <label for="' + scope.$id + model + '" class="cr1"></label>';

        template = template + label;
        elem.addClass('gf-form-checkbox');
        elem.html($compile(angular.element(template))(scope));
      }
    };
  });

  coreModule.default.directive('gfDropdown', function ($parse, $compile, $timeout) {
    function buildTemplate(items, placement) {
      var upclass = placement === 'top' ? 'dropup' : '';
      var ul = [
        '<ul class="dropdown-menu ' + upclass + '" role="menu" aria-labelledby="drop1">',
        '</ul>'
      ];

      angular.forEach(items, function (item, index) {
        if (item.divider) {
          return ul.splice(index + 1, 0, '<li class="divider"></li>');
        }

        var li = '<li' + (item.submenu && item.submenu.length ? ' class="dropdown-submenu"' : '') + '>' +
          '<a tabindex="-1" ng-href="' + (item.href || '') + '"' + (item.click ? ' ng-click="' + item.click + '"' : '') +
          (item.target ? ' target="' + item.target + '"' : '') + (item.method ? ' data-method="' + item.method + '"' : '') +
          '>' + (item.text || '') + '</a>';

        if (item.submenu && item.submenu.length) {
          li += buildTemplate(item.submenu).join('\n');
        }

        li += '</li>';
        ul.splice(index + 1, 0, li);
      });
      return ul;
    }

    return {
      restrict: 'EA',
      scope: true,
      link: function postLink(scope, iElement, iAttrs) {
        var getter = $parse(iAttrs.gfDropdown), items = getter(scope);
        $timeout(function () {
          var placement = iElement.data('placement');
          var dropdown = angular.element(buildTemplate(items, placement).join(''));
          dropdown.insertAfter(iElement);
          $compile(iElement.next('ul.dropdown-menu'))(scope);
        });

        iElement.addClass('dropdown-toggle').attr('data-toggle', 'dropdown');
      }
    };
  });

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 679:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(2),
  __webpack_require__(93),
  __webpack_require__(455),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (coreModule, kbn, rangeUtil) {
  'use strict';

  kbn = kbn.default;

  coreModule.default.directive('ngModelOnblur', function() {
    return {
      restrict: 'A',
      priority: 1,
      require: 'ngModel',
      link: function(scope, elm, attr, ngModelCtrl) {
        if (attr.type === 'radio' || attr.type === 'checkbox') {
          return;
        }

        elm.off('input keydown change');
        elm.bind('blur', function() {
          scope.$apply(function() {
            ngModelCtrl.$setViewValue(elm.val());
          });
        });
      }
    };
  });

  coreModule.default.directive('emptyToNull', function () {
    return {
      restrict: 'A',
      require: 'ngModel',
      link: function (scope, elm, attrs, ctrl) {
        ctrl.$parsers.push(function (viewValue) {
          if(viewValue === "") { return null; }
          return viewValue;
        });
      }
    };
  });

  coreModule.default.directive('validTimeSpan', function() {
    return {
      require: 'ngModel',
      link: function(scope, elm, attrs, ctrl) {
        ctrl.$validators.integer = function(modelValue, viewValue) {
          if (ctrl.$isEmpty(modelValue)) {
            return true;
          }
          if (viewValue.indexOf('$') === 0) {
            return true; // allow template variable
          }
          var info = rangeUtil.describeTextRange(viewValue);
          return info.invalid !== true;
        };
      }
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 680:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (coreModule) {
  'use strict';

  coreModule.default.directive('passwordStrength', function() {
    var template = '<div class="password-strength small" ng-if="!loginMode" ng-class="strengthClass">' +
      '<em>{{strengthText}}</em>' +
      '</div>';
    return {
      template: template,
      scope: {
        password: "=",
      },
      link: function($scope) {

        $scope.strengthClass = '';

        function passwordChanged(newValue) {
          if (!newValue) {
            $scope.strengthText = "";
            $scope.strengthClass = "hidden";
            return;
          }
          if (newValue.length < 4) {
            $scope.strengthText = ":";
            $scope.strengthClass = "password-strength-bad";
            return;
          }
          if (newValue.length <= 8) {
            $scope.strengthText = ":";
            $scope.strengthClass = "password-strength-ok";
            return;
          }

          $scope.strengthText = ":";
          $scope.strengthClass = "password-strength-good";
        }

        $scope.$watch("password", passwordChanged);
      }
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 681:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(2),
  !(function webpackMissingModule() { var e = new Error("Cannot find module \"spectrum\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, coreModule) {
  'use strict';

  coreModule.default.directive('spectrumPicker', function() {
    return {
      restrict: 'E',
      require: 'ngModel',
      scope: false,
      replace: true,
      template: "<span><input class='input-small' /></span>",
      link: function(scope, element, attrs, ngModel) {
        var input = element.find('input');
        var options = angular.extend({
          showAlpha: true,
          showButtons: false,
          color: ngModel.$viewValue,
          change: function(color) {
            scope.$apply(function() {
              ngModel.$setViewValue(color.toRgbString());
            });
          }
        }, scope.$eval(attrs.options));

        ngModel.$render = function() {
          input.spectrum('set', ngModel.$viewValue || '');
        };

        input.spectrum(options);

        scope.$on('$destroy', function() {
          input.spectrum('destroy');
        });
      }
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 682:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(16),
  __webpack_require__(2),
  !(function webpackMissingModule() { var e = new Error("Cannot find module \"bootstrap-tagsinput\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, $, coreModule) {
  'use strict';

  function djb2(str) {
    var hash = 5381;
    for (var i = 0; i < str.length; i++) {
      hash = ((hash << 5) + hash) + str.charCodeAt(i); /* hash * 33 + c */
    }
    return hash;
  }

  function setColor(name, element) {
    var hash = djb2(name.toLowerCase());
    var colors = [
      "#E24D42","#1F78C1","#BA43A9","#705DA0","#466803",
      "#508642","#447EBC","#C15C17","#890F02","#757575",
      "#0A437C","#6D1F62","#584477","#629E51","#2F4F4F",
      "#BF1B00","#806EB7","#8a2eb8", "#699e00","#000000",
      "#3F6833","#2F575E","#99440A","#E0752D","#0E4AB4",
      "#58140C","#052B51","#511749","#3F2B5B",
    ];
    var borderColors = [
      "#FF7368","#459EE7","#E069CF","#9683C6","#6C8E29",
      "#76AC68","#6AA4E2","#E7823D","#AF3528","#9B9B9B",
      "#3069A2","#934588","#7E6A9D","#88C477","#557575",
      "#E54126","#A694DD","#B054DE", "#8FC426","#262626",
      "#658E59","#557D84","#BF6A30","#FF9B53","#3470DA",
      "#7E3A32","#2B5177","#773D6F","#655181",
    ];
    var color = colors[Math.abs(hash % colors.length)];
    var borderColor = borderColors[Math.abs(hash % borderColors.length)];
    element.css("background-color", color);
    element.css("border-color", borderColor);
  }

  coreModule.default.directive('tagColorFromName', function() {
    return {
      scope: { tagColorFromName: "=" },
      link: function (scope, element) {
        setColor(scope.tagColorFromName, element);
      }
    };
  });

  coreModule.default.directive('bootstrapTagsinput', function() {

    function getItemProperty(scope, property) {
      if (!property) {
        return undefined;
      }

      if (angular.isFunction(scope.$parent[property])) {
        return scope.$parent[property];
      }

      return function(item) {
        return item[property];
      };
    }

    return {
      restrict: 'EA',
      scope: {
        model: '=ngModel',
        onTagsUpdated: "&",
      },
      template: '<select multiple></select>',
      replace: false,
      link: function(scope, element, attrs) {

        if (!angular.isArray(scope.model)) {
          scope.model = [];
        }

        var select = $('select', element);

        if (attrs.placeholder) {
          select.attr('placeholder', attrs.placeholder);
        }

        select.tagsinput({
          typeahead: {
            source: angular.isFunction(scope.$parent[attrs.typeaheadSource]) ? scope.$parent[attrs.typeaheadSource] : null
          },
          itemValue: getItemProperty(scope, attrs.itemvalue),
          itemText : getItemProperty(scope, attrs.itemtext),
          tagClass : angular.isFunction(scope.$parent[attrs.tagclass]) ?
            scope.$parent[attrs.tagclass] : function() { return attrs.tagclass; }
        });

        select.on('itemAdded', function(event) {
          if (scope.model.indexOf(event.item) === -1) {
            scope.model.push(event.item);
            if (scope.onTagsUpdated) {
              scope.onTagsUpdated();
            }
          }
          var tagElement = select.next().children("span").filter(function() { return $(this).text() === event.item; });
          setColor(event.item, tagElement);
        });

        select.on('itemRemoved', function(event) {
          var idx = scope.model.indexOf(event.item);
          if (idx !== -1) {
            scope.model.splice(idx, 1);
            if (scope.onTagsUpdated) {
              scope.onTagsUpdated();
            }
          }
        });

        scope.$watch("model", function() {
          if (!angular.isArray(scope.model)) {
            scope.model = [];
          }

          select.tagsinput('removeAll');

          for (var i = 0; i < scope.model.length; i++) {
            select.tagsinput('add', scope.model[i]);
          }

        }, true);
      }
    };
  });

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 683:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(3),
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, _, coreModule) {
  'use strict';

  coreModule.default.controller('ValueSelectDropdownCtrl', function($q) {
    var vm = this;

    vm.show = function() {
      vm.oldVariableText = vm.variable.current.text;
      vm.highlightIndex = -1;

      vm.options = vm.variable.options;
      vm.selectedValues = _.filter(vm.options, {selected: true});

      vm.tags = _.map(vm.variable.tags, function(value) {
        var tag = { text: value, selected: false };
        _.each(vm.variable.current.tags, function(tagObj) {
          if (tagObj.text === value) {
            tag = tagObj;
          }
        });
        return tag;
      });

      vm.search = {
        query: '',
        options: vm.options.slice(0, Math.min(vm.options.length, 1000))
      };

      vm.dropdownVisible = true;
    };

    vm.updateLinkText = function() {
      var current = vm.variable.current;

      if (current.tags && current.tags.length) {
        // filer out values that are in selected tags
        var selectedAndNotInTag = _.filter(vm.variable.options, function(option) {
          if (!option.selected) { return false; }
          for (var i = 0; i < current.tags.length; i++)  {
            var tag = current.tags[i];
            if (_.indexOf(tag.values, option.value) !== -1) {
              return false;
            }
          }
          return true;
        });

        // convert values to text
        var currentTexts = _.pluck(selectedAndNotInTag, 'text');

        // join texts
        vm.linkText = currentTexts.join(' + ');
        if (vm.linkText.length > 0) {
          vm.linkText += ' + ';
        }
      } else {
        vm.linkText = vm.variable.current.text;
      }
    };

    vm.clearSelections = function() {
      _.each(vm.options, function(option) {
        option.selected = false;
      });

      vm.selectionsChanged(false);
    };

    vm.selectTag = function(tag) {
      tag.selected = !tag.selected;
      var tagValuesPromise;
      if (!tag.values) {
        tagValuesPromise = vm.getValuesForTag({tagKey: tag.text});
      } else {
        tagValuesPromise = $q.when(tag.values);
      }

      tagValuesPromise.then(function(values) {
        tag.values = values;
        tag.valuesText = values.join(' + ');
        _.each(vm.options, function(option) {
          if (_.indexOf(tag.values, option.value) !== -1) {
            option.selected = tag.selected;
          }
        });

        vm.selectionsChanged(false);
      });
    };

    vm.keyDown = function (evt) {
      if (evt.keyCode === 27) {
        vm.hide();
      }
      if (evt.keyCode === 40) {
        vm.moveHighlight(1);
      }
      if (evt.keyCode === 38) {
        vm.moveHighlight(-1);
      }
      if (evt.keyCode === 13) {
        if (vm.search.options.length === 0) {
          vm.commitChanges();
        } else {
          vm.selectValue(vm.search.options[vm.highlightIndex], {}, true, false);
        }
      }
      if (evt.keyCode === 32) {
        vm.selectValue(vm.search.options[vm.highlightIndex], {}, false, false);
      }
    };

    vm.moveHighlight = function(direction) {
      vm.highlightIndex = (vm.highlightIndex + direction) % vm.search.options.length;
    };

    vm.selectValue = function(option, event, commitChange, excludeOthers) {
      if (!option) { return; }

      option.selected = !option.selected;

      commitChange = commitChange || false;
      excludeOthers = excludeOthers || false;

      var setAllExceptCurrentTo = function(newValue) {
        _.each(vm.options, function(other) {
          if (option !== other) { other.selected = newValue; }
        });
      };

      // commit action (enter key), should not deselect it
      if (commitChange) {
        option.selected = true;
      }

      if (option.text === 'All' || excludeOthers) {
        setAllExceptCurrentTo(false);
        commitChange = true;
      }
      else if (!vm.variable.multi) {
        setAllExceptCurrentTo(false);
        commitChange = true;
      } else if (event.ctrlKey || event.metaKey || event.shiftKey) {
        commitChange = true;
        setAllExceptCurrentTo(false);
      }

      vm.selectionsChanged(commitChange);
    };

    vm.selectionsChanged = function(commitChange) {
      vm.selectedValues = _.filter(vm.options, {selected: true});

      if (vm.selectedValues.length > 1) {
        if (vm.selectedValues[0].text === 'All') {
          vm.selectedValues[0].selected = false;
          vm.selectedValues = vm.selectedValues.slice(1, vm.selectedValues.length);
        }
      }

      // validate selected tags
      _.each(vm.tags, function(tag) {
        if (tag.selected)  {
          _.each(tag.values, function(value) {
            if (!_.findWhere(vm.selectedValues, {value: value})) {
              tag.selected = false;
            }
          });
        }
      });

      vm.selectedTags = _.filter(vm.tags, {selected: true});
      vm.variable.current.value = _.pluck(vm.selectedValues, 'value');
      vm.variable.current.text = _.pluck(vm.selectedValues, 'text').join(' + ');
      vm.variable.current.tags = vm.selectedTags;

      if (!vm.variable.multi) {
        vm.variable.current.value = vm.selectedValues[0].value;
      }

      if (commitChange) {
        vm.commitChanges();
      }
    };

    vm.commitChanges = function() {
      // if we have a search query and no options use that
      if (vm.search.options.length === 0 && vm.search.query.length > 0) {
        vm.variable.current = {text: vm.search.query, value: vm.search.query};
      }
      else if (vm.selectedValues.length === 0) {
        // make sure one option is selected
        vm.options[0].selected = true;
        vm.selectionsChanged(false);
      }

      vm.dropdownVisible = false;
      vm.updateLinkText();

      if (vm.variable.current.text !== vm.oldVariableText) {
        vm.onUpdated();
      }
    };

    vm.queryChanged = function() {
      vm.highlightIndex = -1;
      vm.search.options = _.filter(vm.options, function(option) {
        return option.text.toLowerCase().indexOf(vm.search.query.toLowerCase()) !== -1;
      });

      vm.search.options = vm.search.options.slice(0, Math.min(vm.search.options.length, 1000));
    };

    vm.init = function() {
      vm.selectedTags = vm.variable.current.tags || [];
      vm.updateLinkText();
    };

  });

  coreModule.default.directive('valueSelectDropdown', function($compile, $window, $timeout, $rootScope) {
    return {
      scope: { variable: "=", onUpdated: "&", getValuesForTag: "&" },
      templateUrl: 'public/app/partials/valueSelectDropdown.html',
      controller: 'ValueSelectDropdownCtrl',
      controllerAs: 'vm',
      bindToController: true,
      link: function(scope, elem) {
        var bodyEl = angular.element($window.document.body);
        var linkEl = elem.find('.variable-value-link');
        var inputEl = elem.find('input');

        function openDropdown() {
          inputEl.css('width', Math.max(linkEl.width(), 30) + 'px');

          inputEl.show();
          linkEl.hide();

          inputEl.focus();
          $timeout(function() { bodyEl.on('click', bodyOnClick); }, 0, false);
        }

        function switchToLink() {
          inputEl.hide();
          linkEl.show();
          bodyEl.off('click', bodyOnClick);
        }

        function bodyOnClick (e) {
          if (elem.has(e.target).length === 0) {
            scope.$apply(function() {
              scope.vm.commitChanges();
            });
          }
        }

        scope.$watch('vm.dropdownVisible', function(newValue) {
          if (newValue) {
            openDropdown();
          } else {
            switchToLink();
          }
        });

        var cleanUp = $rootScope.$on('template-variable-value-updated', function() {
          scope.vm.updateLinkText();
        });

        scope.$on("$destroy", function() {
          cleanUp();
        });

        scope.vm.init();
      },
    };
  });

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 684:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_config__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_app_core_config__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_app_plugins_panel_unknown_module__ = __webpack_require__(685);
///<reference path="../../headers/common.d.ts" />





/** @ngInject **/
function pluginDirectiveLoader($compile, datasourceSrv, $rootScope, $q, $http, $templateCache) {
    function getTemplate(component) {
        if (component.template) {
            return $q.when(component.template);
        }
        var cached = $templateCache.get(component.templateUrl);
        if (cached) {
            return $q.when(cached);
        }
        return $http.get(component.templateUrl).then(function (res) {
            return res.data;
        });
    }
    function relativeTemplateUrlToAbs(templateUrl, baseUrl) {
        if (!templateUrl) {
            return undefined;
        }
        if (templateUrl.indexOf('public') === 0) {
            return templateUrl;
        }
        return baseUrl + '/' + templateUrl;
    }
    function getPluginComponentDirective(options) {
        // handle relative template urls for plugin templates
        options.Component.templateUrl = relativeTemplateUrlToAbs(options.Component.templateUrl, options.baseUrl);
        return function () {
            return {
                templateUrl: options.Component.templateUrl,
                template: options.Component.template,
                restrict: 'E',
                controller: options.Component,
                controllerAs: 'ctrl',
                bindToController: true,
                scope: options.bindings,
                link: function (scope, elem, attrs, ctrl) {
                    if (ctrl.link) {
                        ctrl.link(scope, elem, attrs, ctrl);
                    }
                    if (ctrl.init) {
                        ctrl.init();
                    }
                }
            };
        };
    }
    function loadPanelComponentInfo(scope, attrs) {
        var componentInfo = {
            name: 'panel-plugin-' + scope.panel.type,
            bindings: { dashboard: "=", panel: "=", row: "=" },
            attrs: { dashboard: "dashboard", panel: "panel", row: "row" },
        };
        var panelElemName = 'panel-' + scope.panel.type;
        var panelInfo = __WEBPACK_IMPORTED_MODULE_2_app_core_config___default.a.panels[scope.panel.type];
        var panelCtrlPromise = Promise.resolve(__WEBPACK_IMPORTED_MODULE_4_app_plugins_panel_unknown_module__["a" /* UnknownPanelCtrl */]);
        if (panelInfo) {
            panelCtrlPromise = __webpack_require__(63)(panelInfo.module).then(function (panelModule) {
                return panelModule.PanelCtrl;
            });
        }
        return panelCtrlPromise.then(function (PanelCtrl) {
            componentInfo.Component = PanelCtrl;
            if (!PanelCtrl || PanelCtrl.registered) {
                return componentInfo;
            }
            ;
            if (PanelCtrl.templatePromise) {
                return PanelCtrl.templatePromise.then(function (res) {
                    return componentInfo;
                });
            }
            if (panelInfo) {
                PanelCtrl.templateUrl = relativeTemplateUrlToAbs(PanelCtrl.templateUrl, panelInfo.baseUrl);
            }
            PanelCtrl.templatePromise = getTemplate(PanelCtrl).then(function (template) {
                PanelCtrl.templateUrl = null;
                PanelCtrl.template = "<grafana-panel ctrl=\"ctrl\">" + template + "</grafana-panel>";
                return componentInfo;
            });
            return PanelCtrl.templatePromise;
        });
    }
    function getModule(scope, attrs) {
        switch (attrs.type) {
            // QueryCtrl
            case "query-ctrl": {
                var datasource = scope.target.datasource || scope.ctrl.panel.datasource;
                return datasourceSrv.get(datasource).then(function (ds) {
                    scope.datasource = ds;
                    return __webpack_require__(63)(ds.meta.module).then(function (dsModule) {
                        return {
                            baseUrl: ds.meta.baseUrl,
                            name: 'query-ctrl-' + ds.meta.id,
                            bindings: { target: "=", panelCtrl: "=", datasource: "=" },
                            attrs: { "target": "target", "panel-ctrl": "ctrl", datasource: "datasource" },
                            Component: dsModule.QueryCtrl
                        };
                    });
                });
            }
            // QueryOptionsCtrl
            case "query-options-ctrl": {
                return datasourceSrv.get(scope.ctrl.panel.datasource).then(function (ds) {
                    return __webpack_require__(63)(ds.meta.module).then(function (dsModule) {
                        if (!dsModule.QueryOptionsCtrl) {
                            return { notFound: true };
                        }
                        return {
                            baseUrl: ds.meta.baseUrl,
                            name: 'query-options-ctrl-' + ds.meta.id,
                            bindings: { panelCtrl: "=" },
                            attrs: { "panel-ctrl": "ctrl" },
                            Component: dsModule.QueryOptionsCtrl
                        };
                    });
                });
            }
            // Annotations
            case "annotations-query-ctrl": {
                return __webpack_require__(63)(scope.ctrl.currentDatasource.meta.module).then(function (dsModule) {
                    return {
                        baseUrl: scope.ctrl.currentDatasource.meta.baseUrl,
                        name: 'annotations-query-ctrl-' + scope.ctrl.currentDatasource.meta.id,
                        bindings: { annotation: "=", datasource: "=" },
                        attrs: { "annotation": "ctrl.currentAnnotation", datasource: "ctrl.currentDatasource" },
                        Component: dsModule.AnnotationsQueryCtrl,
                    };
                });
            }
            // Datasource ConfigCtrl
            case 'datasource-config-ctrl': {
                var dsMeta = scope.ctrl.datasourceMeta;
                return __webpack_require__(63)(dsMeta.module).then(function (dsModule) {
                    if (!dsModule.ConfigCtrl) {
                        return { notFound: true };
                    }
                    return {
                        baseUrl: dsMeta.baseUrl,
                        name: 'ds-config-' + dsMeta.id,
                        bindings: { meta: "=", current: "=" },
                        attrs: { meta: "ctrl.datasourceMeta", current: "ctrl.current" },
                        Component: dsModule.ConfigCtrl,
                    };
                });
            }
            // AppConfigCtrl
            case 'app-config-ctrl': {
                var model_1 = scope.ctrl.model;
                return __webpack_require__(63)(model_1.module).then(function (appModule) {
                    return {
                        baseUrl: model_1.baseUrl,
                        name: 'app-config-' + model_1.id,
                        bindings: { appModel: "=", appEditCtrl: "=" },
                        attrs: { "app-model": "ctrl.model", "app-edit-ctrl": "ctrl" },
                        Component: appModule.ConfigCtrl,
                    };
                });
            }
            // App Page
            case 'app-page': {
                var appModel_1 = scope.ctrl.appModel;
                return __webpack_require__(63)(appModel_1.module).then(function (appModule) {
                    return {
                        baseUrl: appModel_1.baseUrl,
                        name: 'app-page-' + appModel_1.appId + '-' + scope.ctrl.page.slug,
                        bindings: { appModel: "=" },
                        attrs: { "app-model": "ctrl.appModel" },
                        Component: appModule[scope.ctrl.page.component],
                    };
                });
            }
            // Panel
            case 'panel': {
                return loadPanelComponentInfo(scope, attrs);
            }
            default: {
                return $q.reject({ message: "Could not find component type: " + attrs.type });
            }
        }
    }
    function appendAndCompile(scope, elem, componentInfo) {
        var child = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.element(document.createElement(componentInfo.name));
        __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.each(componentInfo.attrs, function (value, key) {
            child.attr(key, value);
        });
        $compile(child)(scope);
        elem.empty();
        // let a binding digest cycle complete before adding to dom
        setTimeout(function () {
            elem.append(child);
            scope.$apply(function () {
                scope.$broadcast('refresh');
            });
        });
    }
    function registerPluginComponent(scope, elem, attrs, componentInfo) {
        if (componentInfo.notFound) {
            elem.empty();
            return;
        }
        if (!componentInfo.Component) {
            throw { message: 'Failed to find exported plugin component for ' + componentInfo.name };
        }
        if (!componentInfo.Component.registered) {
            var directiveName = attrs.$normalize(componentInfo.name);
            var directiveFn = getPluginComponentDirective(componentInfo);
            __WEBPACK_IMPORTED_MODULE_3_app_core_core_module__["default"].directive(directiveName, directiveFn);
            componentInfo.Component.registered = true;
        }
        appendAndCompile(scope, elem, componentInfo);
    }
    return {
        restrict: 'E',
        link: function (scope, elem, attrs) {
            getModule(scope, attrs).then(function (componentInfo) {
                registerPluginComponent(scope, elem, attrs, componentInfo);
            }).catch(function (err) {
                $rootScope.appEvent('alert-error', ['Plugin Error', err.message || err]);
                console.log('Plugin componnet error', err);
            });
        }
    };
}
__WEBPACK_IMPORTED_MODULE_3_app_core_core_module__["default"].directive('pluginComponent', pluginDirectiveLoader);


/***/ }),

/***/ 685:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UnknownPanelCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_plugins_sdk__ = __webpack_require__(686);
///<reference path="../../../headers/common.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var UnknownPanelCtrl = /** @class */ (function (_super) {
    __extends(UnknownPanelCtrl, _super);
    /** @ngInject */
    function UnknownPanelCtrl($scope, $injector) {
        return _super.call(this, $scope, $injector) || this;
    }
    UnknownPanelCtrl.templateUrl = 'public/app/plugins/panel/unknown/module.html';
    return UnknownPanelCtrl;
}(__WEBPACK_IMPORTED_MODULE_0_app_plugins_sdk__["a" /* PanelCtrl */]));



/***/ }),

/***/ 686:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export loadPluginCss */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_features_panel_panel_ctrl__ = __webpack_require__(687);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_features_panel_metrics_panel_ctrl__ = __webpack_require__(688);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_features_panel_metrics_panel_ctrl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_app_features_panel_metrics_panel_ctrl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_features_panel_query_ctrl__ = __webpack_require__(456);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_config__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_app_core_config__);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0_app_features_panel_panel_ctrl__["a"]; });
/* unused harmony reexport MetricsPanelCtrl */
/* unused harmony reexport QueryCtrl */




function loadPluginCss(options) {
    if (__WEBPACK_IMPORTED_MODULE_3_app_core_config___default.a.bootData.user.userTheme) {
        __webpack_require__(361)(options[config.bootData.user.userTheme] + '!css');
    }
    else {
        __webpack_require__(361)(options.light + '!css');
    }
}



/***/ }),

/***/ 687:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PanelCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_config__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_app_core_config__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_app_core_core__ = __webpack_require__(200);
///<reference path="../../headers/common.d.ts" />




var TITLE_HEIGHT = 25;
var EMPTY_TITLE_HEIGHT = 9;
var PANEL_PADDING = 5;

var PanelCtrl = /** @class */ (function () {
    function PanelCtrl($scope, $injector) {
        var _this = this;
        this.$injector = $injector;
        this.$scope = $scope;
        this.$_location = $injector.get('$location');
        this.$timeout = $injector.get('$timeout');
        this.contextSrv = $injector.get('contextSrv');
        this.integrateSrv = $injector.get('integrateSrv');
        this.associationSrv = $injector.get('associationSrv');
        this.$translate = $injector.get('$translate');
        this.editorTabIndex = 0;
        this.events = new __WEBPACK_IMPORTED_MODULE_4_app_core_core__["a" /* Emitter */]();
        var plugin = __WEBPACK_IMPORTED_MODULE_0_app_core_config___default.a.panels[this.panel.type];
        if (plugin) {
            this.pluginId = plugin.id;
            this.pluginName = plugin.name;
        }
        $scope.$on("refresh", function (event, payload) { return _this.refresh(payload); });
        $scope.$on("render", function () { return _this.render(); });
        $scope.$on("$destroy", function () { return _this.events.emit('panel-teardown'); });
    }
    PanelCtrl.prototype.init = function () {
        this.calculatePanelHeight();
        this.publishAppEvent('panel-initialized', { scope: this.$scope });
        this.events.emit('panel-initialized');
    };
    PanelCtrl.prototype.renderingCompleted = function () {
        this.$scope.$root.performance.panelsRendered++;
    };
    PanelCtrl.prototype.refresh = function (payload) {
        // ignore if panel id is specified
        if (this.specifiedPanelId(payload)) {
            return;
        }
        this.events.emit('refresh', payload);
    };
    PanelCtrl.prototype.publishAppEvent = function (evtName, evt) {
        this.$scope.$root.appEvent(evtName, evt);
    };
    PanelCtrl.prototype.changeView = function (fullscreen, edit) {
        this.publishAppEvent('panel-change-view', {
            fullscreen: fullscreen, edit: edit, panelId: this.panel.id
        });
    };
    PanelCtrl.prototype.viewPanel = function () {
        this.changeView(true, false);
    };
    PanelCtrl.prototype.editPanel = function () {
        this.changeView(true, true);
    };
    PanelCtrl.prototype.exitFullscreen = function () {
        this.changeView(false, false);
    };
    PanelCtrl.prototype.initEditMode = function () {
        this.editorTabs = [];
        this.addEditorTab(this.$translate.i18n.i18n_general, 'public/app/partials/panelgeneral.html');
        this.editModeInitiated = true;
        this.events.emit('init-edit-mode', null);
    };
    PanelCtrl.prototype.addEditorTab = function (title, directiveFn, index) {
        var editorTab = { title: title, directiveFn: directiveFn };
        if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isString(directiveFn)) {
            editorTab.directiveFn = function () {
                return { templateUrl: directiveFn };
            };
        }
        if (index) {
            this.editorTabs.splice(index, 0, editorTab);
        }
        else {
            this.editorTabs.push(editorTab);
        }
    };
    PanelCtrl.prototype.getMenu = function () {
        var menu = [];
        menu.push({ text: this.$translate.i18n.i18n_enlarge, click: 'ctrl.updateColumnSpan(1); dismiss();', role: 'Editor', icon: 'fa-plus', hover: 'hover-show pull-left' });
        menu.push({ text: this.$translate.i18n.i18n_narrow, click: 'ctrl.updateColumnSpan(-1); dismiss();', role: 'Editor', icon: 'fa-minus', hover: 'hover-show pull-left' });
        menu.push({ text: this.$translate.i18n.i18n_delete, click: 'ctrl.removePanel(); dismiss();', role: 'Editor', icon: 'fa-trash-o', hover: 'hover-show  pull-left' });
        menu.push({ text: this.$translate.i18n.i18n_share, click: 'ctrl.sharePanel(); dismiss();', role: 'Editor', icon: 'fa-external-link' });
        menu.push({ text: this.$translate.i18n.i18n_edit, click: 'ctrl.editPanel(); dismiss();', role: 'Editor', icon: 'fa-pencil' });
        if (this.checkMenu('association')) {
            menu.push({ text: this.$translate.i18n.page_association_title, click: 'ctrl.associateLink();', icon: 'fa-line-chart' });
        }
        if (this.checkMenu('correlation')) {
            menu.push({ text: this.$translate.i18n.page_association_info5, click: 'ctrl.correlation();', icon: 'fa-clock-o' });
        }
        return menu;
    };
    PanelCtrl.prototype.checkMenu = function (menu) {
        var pathname = window.location.pathname;
        var show = false;
        var isGraph = this.panel.type === 'graph';
        var isLine = this.panel.lines;
        switch (menu) {
            case 'association':
                show = /^\/anomaly/.test(pathname);
                break;
            case 'list':
                show = !/^\/(association|anomaly|alert|logs)/.test(pathname);
                break;
            case 'correlation':
                show = /^\/association/.test(pathname);
        }
        return show && isGraph && isLine;
    };
    PanelCtrl.prototype.getExtendedMenu = function () {
        var actions = [];
        if (!this.fullscreen) {
            actions.push({ text: this.$translate.i18n.i18n_copy, click: 'ctrl.duplicate(); dismiss();', role: 'Editor' });
        }
        actions.push({ text: this.$translate.i18n.i18n_query, click: 'ctrl.viewPanel(); dismiss();', icon: 'icon-eye-open' });
        actions.push({ text: this.$translate.i18n.i18n_view_json, click: 'ctrl.editPanelJson(); dismiss();', role: 'Editor' });
        this.events.emit('init-panel-actions', actions);
        return actions;
    };
    PanelCtrl.prototype.otherPanelInFullscreenMode = function () {
        return this.dashboard.meta.fullscreen && !this.fullscreen;
    };
    PanelCtrl.prototype.specifiedPanelId = function (payload) {
        if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isNumber(payload) || __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isString(payload)) {
            return this.panel.id !== payload;
        }
        if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isArray(payload)) {
            return !~payload.indexOf(this.panel.id);
        }
        return false;
    };
    PanelCtrl.prototype.calculatePanelHeight = function () {
        if (this.fullscreen) {
            var docHeight = __WEBPACK_IMPORTED_MODULE_3_jquery___default()(window).height();
            var editHeight = Math.floor(docHeight * 0.3);
            var fullscreenHeight = Math.floor(docHeight * 0.7);
            this.containerHeight = this.editMode ? editHeight : fullscreenHeight;
        }
        else {
            this.containerHeight = this.panel.height || this.row.height;
            if (__WEBPACK_IMPORTED_MODULE_1_lodash___default.a.isString(this.containerHeight)) {
                this.containerHeight = parseInt(this.containerHeight.replace('px', ''), 10);
            }
        }
        this.height = this.containerHeight - (PANEL_PADDING + (this.panel.title ? TITLE_HEIGHT : EMPTY_TITLE_HEIGHT));
    };
    PanelCtrl.prototype.render = function (payload) {
        // ignore if other panel is in fullscreen mode
        if (this.otherPanelInFullscreenMode()) {
            return;
        }
        this.calculatePanelHeight();
        this.events.emit('render', payload);
    };
    PanelCtrl.prototype.toggleEditorHelp = function (index) {
        if (this.editorHelpIndex === index) {
            this.editorHelpIndex = null;
            return;
        }
        this.editorHelpIndex = index;
    };
    PanelCtrl.prototype.duplicate = function () {
        this.dashboard.duplicatePanel(this.panel, this.row);
    };
    PanelCtrl.prototype.updateColumnSpan = function (span) {
        var _this = this;
        this.panel.span = Math.min(Math.max(Math.floor(this.panel.span + span), 1), 12);
        this.$timeout(function () {
            _this.render();
        });
    };
    PanelCtrl.prototype.removePanel = function () {
        var _this = this;
        this.publishAppEvent('confirm-modal', {
            title: this.$translate.i18n.i18n_sure_operator,
            text: this.$translate.i18n.i18n_sure_operator,
            icon: 'fa-trash',
            yesText: this.$translate.i18n.i18n_delete,
            noText: this.$translate.i18n.i18n_cancel,
            onConfirm: function () {
                _this.row.panels = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.without(_this.row.panels, _this.panel);
            }
        });
    };
    PanelCtrl.prototype.editPanelJson = function () {
        this.publishAppEvent('show-json-editor', {
            object: this.panel,
            updateHandler: this.replacePanel.bind(this)
        });
    };
    PanelCtrl.prototype.replacePanel = function (newPanel, oldPanel) {
        var _this = this;
        var row = this.row;
        var index = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.indexOf(this.row.panels, oldPanel);
        this.row.panels.splice(index, 1);
        // adding it back needs to be done in next digest
        this.$timeout(function () {
            newPanel.id = oldPanel.id;
            newPanel.span = oldPanel.span;
            _this.row.panels.splice(index, 0, newPanel);
        });
    };
    PanelCtrl.prototype.sharePanel = function () {
        var shareScope = this.$scope.$new();
        shareScope.panel = this.panel;
        shareScope.dashboard = this.dashboard;
        this.publishAppEvent('show-modal', {
            src: 'public/app/features/dashboard/partials/shareModal.html',
            scope: shareScope
        });
    };
    PanelCtrl.prototype.openInspector = function () {
        var modalScope = this.$scope.$new();
        modalScope.panel = this.panel;
        modalScope.dashboard = this.dashboard;
        modalScope.inspector = __WEBPACK_IMPORTED_MODULE_2_angular___default.a.copy(this.inspector);
        this.publishAppEvent('show-modal', {
            src: 'public/app/partials/inspector.html',
            scope: modalScope
        });
    };
    PanelCtrl.prototype.associateLink = function () {
        try {
            var host = this.panel.targets[0].tags.host;
            var metric = this.panel.targets[0].metric;
            if (host && metric) {
                this.associationSrv.setSourceAssociation({
                    metric: metric,
                    host: host,
                    distance: 200,
                });
                this.$_location.url("/association");
            }
        }
        catch (err) {
            var reg = /\'(.*?)\'/g;
            var msg = this.$translate.i18n.i18n_param_miss + ": " + err.toString().match(reg)[0];
            this.publishAppEvent('alert-warning', [this.$translate.i18n.i18n_param_miss, msg]);
        }
    };
    PanelCtrl.prototype.getDownsamplesMenu = function () {
        var downsamples = [];
        __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.each(this.panel.downsamples, function (downsample) {
            downsamples.push({ text: downsample, click: 'ctrl.setDownsample(\'' + downsample + '\');dismiss();' });
        });
        return downsamples;
    };
    PanelCtrl.prototype.setDownsample = function (interval) {
        var _this = this;
        this.panel.downsample = interval;
        __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.each(this.panel.targets, function (target) {
            target.downsampleInterval = interval;
        });
        this.$timeout(function () {
            _this.$scope.$broadcast('refresh', _this.panel.id);
        });
    };
    PanelCtrl.prototype.correlation = function () {
        this.$scope.$emit('analysis', 'updateTime');
    };
    return PanelCtrl;
}());



/***/ }),

/***/ 688:
/***/ (function(module, exports) {

throw new Error("Module build failed: Error: Final loader didn't return a Buffer or String\n    at runLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/webpack/lib/NormalModule.js:204:46)\n    at /Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:370:3\n    at iterateNormalLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:211:10)\n    at iterateNormalLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:218:10)\n    at /Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:233:3\n    at context.callback (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:111:13)\n    at process._tickCallback (internal/process/next_tick.js:103:7)");

/***/ }),

/***/ 689:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />


function getBlockNodes(nodes) {
    var node = nodes[0];
    var endNode = nodes[nodes.length - 1];
    var blockNodes;
    for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
        if (blockNodes || nodes[i] !== node) {
            if (!blockNodes) {
                blockNodes = __WEBPACK_IMPORTED_MODULE_0_jquery___default()([].slice.call(nodes, 0, i));
            }
            blockNodes.push(node);
        }
    }
    return blockNodes || nodes;
}
function rebuildOnChange($animate) {
    return {
        multiElement: true,
        terminal: true,
        transclude: true,
        priority: 600,
        restrict: 'E',
        link: function (scope, elem, attrs, ctrl, transclude) {
            var block, childScope, previousElements;
            function cleanUp() {
                if (previousElements) {
                    previousElements.remove();
                    previousElements = null;
                }
                if (childScope) {
                    childScope.$destroy();
                    childScope = null;
                }
                if (block) {
                    previousElements = getBlockNodes(block.clone);
                    $animate.leave(previousElements).then(function () {
                        previousElements = null;
                    });
                    block = null;
                }
            }
            scope.$watch(attrs.property, function rebuildOnChangeAction(value, oldValue) {
                if (childScope && value !== oldValue) {
                    cleanUp();
                }
                if (!childScope && (value || attrs.showNull)) {
                    transclude(function (clone, newScope) {
                        childScope = newScope;
                        clone[clone.length++] = document.createComment(' end rebuild on change ');
                        block = { clone: clone };
                        $animate.enter(clone, elem.parent(), elem);
                    });
                }
                else {
                    cleanUp();
                }
            });
        }
    };
}
__WEBPACK_IMPORTED_MODULE_1__core_module__["default"].directive('rebuildOnChange', rebuildOnChange);


/***/ }),

/***/ 690:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />

__WEBPACK_IMPORTED_MODULE_0__core_module__["default"].directive('giveFocus', function () {
    return function (scope, element, attrs) {
        element.click(function (e) {
            e.stopPropagation();
        });
        scope.$watch(attrs.giveFocus, function (newValue) {
            if (!newValue) {
                return;
            }
            setTimeout(function () {
                element.focus();
                var domEl = element[0];
                if (domEl.setSelectionRange) {
                    var pos = element.val().length * 2;
                    domEl.setSelectionRange(pos, pos);
                }
            }, 200);
        }, true);
    };
});
/* unused harmony default export */ var _unused_webpack_default_export = ({});


/***/ }),

/***/ 691:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(16), __webpack_require__(7), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, angular, _) {
  'use strict';

  var $win = $(window);

  $.fn.place_tt = (function () {
    var defaults = {
      offset: 5,
    };

    return function (x, y, opts) {
      opts = $.extend(true, {}, defaults, opts);

      return this.each(function () {
        var $tooltip = $(this), width, height;

        $tooltip.addClass('grafana-tooltip');

        $("#tooltip").remove();
        $tooltip.appendTo(document.body);

        if (opts.compile) {
          angular.element(document).injector().invoke(["$compile", "$rootScope", function($compile, $rootScope) {
            var tmpScope = $rootScope.$new(true);
            _.extend(tmpScope, opts.scopeData);

            $compile($tooltip)(tmpScope);
            tmpScope.$digest();
            tmpScope.$destroy();
          }]);
        }

        width = $tooltip.outerWidth(true);
        height = $tooltip.outerHeight(true);

        $tooltip.css('left', x + opts.offset + width > $win.width() ? x - opts.offset - width : x + opts.offset);
        $tooltip.css('top', y + opts.offset + height > $win.height() ? y - opts.offset - height : y + opts.offset);
      });
    };
  })();

  $.escapeSelector = function (selector) {
    return selector.replace(/(:|\.|\[|\]|,|=|@)/g, "\\$1");
  };

  return $;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 692:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 693:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core_module__ = __webpack_require__(2);
throw new Error("Cannot find module \"jquery.flot\"");
throw new Error("Cannot find module \"jquery.flot.pie\"");





function systemPanel($parse, alertMgrSrv, healthSrv, datasourceSrv, contextSrv, backendSrv, $location, $q) {
    return {
        restrict: 'E',
        link: function (scope, elem, attr) {
            scope.enter = function (systemId) {
                contextSrv.user.systemId = systemId;
                contextSrv.hostNum = scope.hostList.length;
                backendSrv.post("/api/system/pick", { SystemId: systemId });
                if (contextSrv.hostNum) {
                    contextSrv.toggleSideMenu();
                    $location.url("/");
                }
                else {
                    $location.url("/setting/agent");
                }
            };
            scope.init = function () {
                scope.servies = [];
                scope.serviesStatus = { normal: 0, unnormal: 0 };
                scope.hostList = [];
                scope.hostStatus = { normal: 0, unnormal: 0 };
                scope.critical = 0;
                scope.warn = 0;
                scope.alertNum = 0;
            };
            var getter = $parse(attr.sys), system = getter(scope);
            contextSrv.user.systemId = system;
            var setPie = function (type, system, pieData) {
                var colors = [];
                if (pieData.length > 1) {
                    colors = ['rgb(61,183,121)', 'rgb(255,197,58)', 'rgb(224,76,65)'];
                }
                else {
                    colors = ['#555'];
                }
                __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.plot("[" + type + "='" + system + "']", pieData, {
                    series: {
                        pie: {
                            innerRadius: 0.5,
                            show: true,
                            label: {
                                show: false,
                            },
                            stroke: {
                                width: 0
                            }
                        }
                    },
                    legend: {
                        show: false
                    },
                    colors: colors
                });
            };
            var getPlatform = function () {
                backendSrv.get('/api/static/hosts').then(function (result) {
                    scope.platform = result.hosts;
                });
            };
            //------get service satatus
            var getService = backendSrv.getServices().then(function (response) {
                var count = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.countBy(response.data, { alive: 0 });
                scope.serviesStatus.normal = count.true || 0;
                scope.serviesStatus.unnormal = count.false || 0;
                scope.servies = response.data;
            });
            //------- get Alerts status
            var getAlertNum = alertMgrSrv.load().then(function (response) {
                return response.data.length;
            });
            var getAlertStatus = alertMgrSrv.loadTriggeredAlerts().then(function onSuccess(response) {
                var count = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.countBy(response.data, { level: 'CRITICAL' });
                return { critical: count.true || 0, warn: count.false || 0 };
            });
            //------- get health/anomaly status
            var getHealth = healthSrv.load().then(function (data) {
                scope.numMetrics = data.numMetrics;
                scope.numAnomalyMetrics = data.numAnomalyMetrics;
                scope.health = data.health;
                var annomalyPieData = [
                    { label: "", data: scope.numMetrics },
                    { label: "", data: scope.numAnomalyMetrics },
                ];
                setPie('sys_annomaly', system, annomalyPieData);
            });
            //-------- get host status
            var query = {
                "queries": [
                    {
                        "metric": "collector.state"
                    }
                ],
                "hostProperties": []
            };
            var getHostStatus = backendSrv.getHosts(query).then(function (response) {
                if (response.data.length) {
                    scope.hostList = response.data;
                    var count = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.countBy(scope.hostList, { "collector.state": 0 });
                    scope.hostStatus.unnormal = count.false || 0;
                    scope.hostStatus.normal = count.true || 0;
                    return scope.hostList.length;
                }
                else {
                    var d = $q.defer();
                    d.resolve();
                    return d.promise;
                }
            }, function () {
                getPlatform();
            });
            //------- alertNum = alertRules * hostNum;
            $q.all([getHostStatus, getAlertNum, getAlertStatus]).then(function (result) {
                var hostNum = result[0], alertRulesNum = result[1], alertStatus = result[2];
                if (typeof (hostNum) === "undefined") {
                    getPlatform();
                }
                else {
                    scope.alertNum = alertRulesNum * hostNum;
                    scope.warn = alertStatus.warn;
                    scope.critical = alertStatus.critical;
                    var alertPieData = [
                        { label: "", data: (scope.alertNum ? scope.alertNum : 1) - scope.warn - scope.critical },
                        { label: "", data: scope.warn },
                        { label: "", data: scope.critical }
                    ];
                    setPie('sys_alert', system, alertPieData);
                }
            }, function () {
                getPlatform();
            });
            scope.init();
        }
    };
}
__WEBPACK_IMPORTED_MODULE_2_app_core_core_module__["default"].directive('systemPanel', systemPanel);


/***/ }),

/***/ 694:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
    __webpack_require__(16),
    __webpack_require__(3),
    __webpack_require__(2)
  ], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, _, coreModule) {
    'use strict';

    coreModule.default.directive('node', function(jsPlumbFactory) {
      return jsPlumbFactory.node({
        templateUrl: "node_template.tpl",
        inherit:["remove", "edit"]
      });
    });

    // coreModule.directive('group', function(jsPlumbFactory) {
    //   return jsPlumbFactory.group({
    //     templateUrl: "group_template.tpl",
    //     inherit:["remove", "toggleGroup"]
    //   });
    // });
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ 695:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(16),
  __webpack_require__(3),
  __webpack_require__(2)
], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, _, coreModule) {
  'use strict';

  coreModule.default.directive('logTabpane', function ($parse, $compile, $http) {
    return {
      restrict: 'EA',
      link: function (scope, elem, attr) {
        var templateUrl = attr.template;

        var template = $http.get(templateUrl, { cache: true }).then(function (res) {
          return res.data;
        });

        template.then(function (response) {
          var $template = $(response);
          elem.html($template);

          $compile(elem.contents())(scope);
        });

        scope.$on('log-refresh', function () {
          template.then(function (response) {
            var $template = $(response);
            elem.html($template);

            $compile(elem.contents())(scope);
          });
        });

      }
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ 696:
/***/ (function(module, exports) {

throw new Error("Module build failed: Error: Final loader didn't return a Buffer or String\n    at runLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/webpack/lib/NormalModule.js:204:46)\n    at /Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:370:3\n    at iterateNormalLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:211:10)\n    at iterateNormalLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:218:10)\n    at /Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:233:3\n    at context.callback (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:111:13)\n    at process._tickCallback (internal/process/next_tick.js:103:7)");

/***/ }),

/***/ 697:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core_module__ = __webpack_require__(2);



var template = "\n<div class=\"load-wrapper\">\n  <div class=\"load\">\n    <div class=\"ring\">\n      <div class=\"ball-holder\">\n        <div class=\"ball\"></div>\n      </div>\n    </div>\n  </div>\n</div>\n";
function cwLoading($compile, $timeout) {
    return {
        multiElement: true,
        scope: true,
        restrict: 'EA',
        link: function ($scope, elem, attrs) {
            var $loading = __WEBPACK_IMPORTED_MODULE_1_jquery___default()(template);
            var duration = parseInt(attrs.duration);
            function show() {
                $loading.appendTo(elem);
                $compile(elem.contents())($scope);
            }
            function hide() {
                $loading.remove();
            }
            $scope.$watch(attrs.show, function (newValue, oldValue) {
                if (__WEBPACK_IMPORTED_MODULE_0_angular___default.a.isString(newValue)) {
                    newValue = !!newValue.match(/true|,?(show),?/i);
                }
                if (newValue === true) {
                    show();
                    if (!isNaN(duration)) {
                        $timeout(hide, duration);
                    }
                }
                else {
                    hide();
                }
            });
        }
    };
}
__WEBPACK_IMPORTED_MODULE_2_app_core_core_module__["default"].directive('cwLoading', cwLoading);


/***/ }),

/***/ 698:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_module__ = __webpack_require__(2);

__WEBPACK_IMPORTED_MODULE_0__core_module__["default"].directive('ngEnter', function () {
    return function (scope, elem, attrs) {
        elem.bind("keydown keypress", function (event) {
            if (event.which === 13) {
                scope.$apply(function () {
                    scope.$eval(attrs.ngEnter);
                });
                event.preventDefault();
            }
        });
    };
});


/***/ }),

/***/ 699:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export autoRefresh */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__ = __webpack_require__(93);


// Usage:
// html: <div auto-refresh></div>
// controller: $scope.refresh_interval = '30s', $scope.refresh_func = this.someFunction.bind(this)
function autoRefresh($timeout, timer) {
    'use strict';
    return {
        restrict: 'A',
        link: function (scope, elem, attr) {
            var refresh_timer;
            var interval = scope.refresh_interval;
            if (interval) {
                setAutoRefresh(interval);
            }
            function setAutoRefresh(interval) {
                var _i = __WEBPACK_IMPORTED_MODULE_1_app_core_utils_kbn__["default"].interval_to_ms(interval);
                var wait_ms = _i - (Date.now() % _i);
                $timeout(function () {
                    start_scheduled_refresh(_i);
                    // refreshView();
                }, wait_ms);
            }
            function start_scheduled_refresh(after_ms) {
                cancel_scheduled_refresh();
                refresh_timer = $timeout(function () {
                    start_scheduled_refresh(after_ms);
                    refreshView();
                }, after_ms);
            }
            function cancel_scheduled_refresh() {
                $timeout.cancel(refresh_timer);
                // timer.cancel(refresh_timer);
            }
            function refreshView() {
                scope.refresh_func();
            }
            scope.$on('$destroy', function () {
                cancel_scheduled_refresh();
            });
        }
    };
}
__WEBPACK_IMPORTED_MODULE_0__core_module__["default"].directive('autoRefresh', autoRefresh);


/***/ }),

/***/ 700:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export TopologyGraphCtrl */
/* unused harmony export topologyGraphDirective */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_core_module__ = __webpack_require__(2);
throw new Error("Cannot find module \"d3.graph\"");
///<reference path="../../headers/common.d.ts" />



var template = "\n  <div class=\"search\" ng-show=\"ctrl.search\">\n    <form class=\"gf-form-group tidy-form\">\n      <div>\n          <div class=\"gf-form\">\n              <ul class=\"gf-form-list tidy-form-list\" style=\"text-align:right; overflow: inherit; width: 100%;\">\n                  <li class=\"tidy-form-item\">\n                      <em translate=\"i18n_search\"></em> {{ ctrl.types[ctrl.type] }}\n                  </li>\n                  <li class=\"tidy-form-item tidy-form-item-dropdown\">\n                      <input type=\"text\" class=\"input-xlarge tidy-form-input last\"\n                            ng-model='ctrl.query'\n                            spellcheck='false'\n                            bs-typeahead-old=\"ctrl.searchList\"\n                            placeholder=\"{{ ctrl.$translate.i18n.page_topology_search_input }}\"\n                            ng-enter=\"ctrl.searchItem()\"\n                            ng-blur=\"ctrl.searchItem()\" />\n                  </li>\n                  <li class=\"tidy-form-item\" ng-hide=\"ctrl.type === 'service'\">\n                      <em translate=\"page_topology_group_tag\"></em>\n                  </li>\n                  <li class=\"tidy-form-item\" ng-hide=\"ctrl.type === 'service'\">\n                      <button type=\"button\" class=\"kpi-btn btn btn-default\" ng-model=\"ctrl.group\" data-placement=\"bottom-auto\"\n                              bs-options=\"f.value as f.text for f in ctrl.groupOptions\" bs-select ng-change=\"ctrl.getGraph();\" placeholder=\"{{ ctrl.$translate.i18n.i18n_select_choose }}\">\n                          <span class=\"caret\"></span>\n                      </button>\n                  </li>\n                  <li class=\"tidy-form-item\" translate=\"page_host_kpi_stat\"></li>\n                  <li class=\"tidy-form-item\">\n                      <button type=\"button\" class=\"kpi-btn btn btn-default\" ng-model=\"ctrl.filter\" data-placement=\"bottom-auto\"\n                              bs-options=\"f.value as f.text for f in ctrl.filterOptions\" bs-select ng-change=\"ctrl.filterBy();\" placeholder=\"{{ ctrl.$translate.i18n.i18n_select_choose }}\">\n                          <span class=\"caret\"></span>\n                      </button>\n                  </li>\n                  <li class=\"tidy-form-item pull-right\" ng-hide=\"ctrl.hideClear\">\n                      <button class=\"btn btn-primary\" style=\"padding: 0.4rem 1rem;\" ng-click=\"ctrl.clearSelected();\"><em translate=\"page_topology_clear_select\"></em> {{ ctrl.types[ctrl.type] }}</button>\n                  </li>\n              </ul>\n              <div class=\"clearfix\"></div>\n          </div>\n      </div>\n    </form>\n  </div>\n\n  <div class=\"heatmap\">\n    <div id=\"heatmap\"></div>\n    <div class=\"clearfix\"></div>\n  </div>\n";
var TopologyGraphCtrl = /** @class */ (function () {
    /** @ngInject */
    function TopologyGraphCtrl($scope, $location, $timeout, backendSrv, contextSrv, $rootScope, hostSrv, serviceDepSrv, alertSrv, $translate) {
        this.$scope = $scope;
        this.$location = $location;
        this.$timeout = $timeout;
        this.backendSrv = backendSrv;
        this.contextSrv = contextSrv;
        this.$rootScope = $rootScope;
        this.hostSrv = hostSrv;
        this.serviceDepSrv = serviceDepSrv;
        this.alertSrv = alertSrv;
        this.$translate = $translate;
        this.groupOptions = [{ 'text': $translate.i18n.i18n_empty, 'value': '' }];
        this.filterOptions = [
            { 'text': $translate.i18n.i18n_all, 'value': '' },
            { 'text': $translate.i18n.i18n_normal, 'value': 'GREEN' },
            { 'text': $translate.i18n.i18n_warning, 'value': 'YELLOW' },
            { 'text': $translate.i18n.i18n_critical, 'value': 'RED' },
            { 'text': $translate.i18n.i18n_breakdown, 'value': 'GREY' }
        ];
        this.heatmap = window.d3.select('#heatmap');
        this.types = {
            'host': $translate.i18n.i18n_host,
            'service': $translate.i18n.i18n_service
        };
        !this.$scope.ctrl.type && (this.$scope.ctrl.type = 'host');
        this.hideClear = (this.$location.path() === '/');
        this.getGraph();
        this.getAllTagsKey();
        this.$scope.$on('topology-update', this.updateTopology.bind(this));
    }
    TopologyGraphCtrl.prototype.getGraph = function () {
        var params = {};
        this.group && (params['groupby'] = this.group);
        // reset data empty
        this.data = [];
        // default: type === 'host'
        var type = this.$scope.ctrl.type;
        if (type === 'service') {
            this.serviceDepSrv.getServiceTopologyData().then(this.renderGraph.bind(this));
        }
        else {
            this.hostSrv.getHostTopologyData(params).then(this.renderGraph.bind(this));
        }
    };
    TopologyGraphCtrl.prototype.renderGraph = function (response) {
        this.searchList = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(response, 'name');
        this.searchList = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.uniq(this.searchList);
        this.data = response;
        !this.rendered && (this.heatmap = window.d3.select('#heatmap').relationshipGraph(this.$scope.ctrl.params));
        this.rendered = true;
        this.heatmap.data(this.data);
        //  query , groupby filter
        if (this.query && this.query !== '*') {
            this.searchItem();
        }
        this.$scope.$emit('topology-loaded', this.data);
    };
    TopologyGraphCtrl.prototype.openSearch = function () {
        this.search = true;
    };
    TopologyGraphCtrl.prototype.closeSearch = function () {
        this.search = false;
    };
    TopologyGraphCtrl.prototype.clearSelected = function () {
        this.query = '';
        this.currentItem = {};
        this.heatmap.data(this.data);
    };
    TopologyGraphCtrl.prototype.searchItem = function (event) {
        if (this.query === '' || this.query === '*') {
            this.clearSelected();
        }
        else if (!~this.searchList.indexOf(this.query)) {
            this.alertSrv.set(this.$translate.i18n.page_topology_search_invalid, '', "warning", 2000);
        }
        else {
            var searchResult = this.heatmap.search({ name: this.query });
            searchResult = !__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(searchResult) ? searchResult : __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(this.data, { name: this.query });
            this.heatmap.data(searchResult);
            this.currentItem = searchResult[0];
        }
    };
    TopologyGraphCtrl.prototype.getAllTagsKey = function () {
        var _this = this;
        // init, get all tags key for group-options
        this.hostSrv.getAllTagsKey().then(function (response) {
            response.data && response.data.forEach(function (item, index) {
                response.data[index] = { 'text': item, 'value': item };
            });
            _this.groupOptions = [_this.groupOptions[0]].concat(response.data);
        });
    };
    TopologyGraphCtrl.prototype.filterBy = function () {
        //  query , filterby 
        if (this.query && this.query !== '*') {
            return;
        }
        var filteredData = this.filter.toLowerCase() ? __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(this.data, { value: this.filter.toLowerCase() }) : this.data;
        this.heatmap.data(filteredData);
    };
    TopologyGraphCtrl.prototype.updateTopology = function (evt, payload) {
        this.data = payload || this.data;
        this.clearSelected();
    };
    return TopologyGraphCtrl;
}());

function topologyGraphDirective() {
    return {
        restrict: 'E',
        template: template,
        controller: TopologyGraphCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {
            type: "@",
            params: "=",
            currentItem: "="
        },
        link: function (scope, elem) {
        }
    };
}
__WEBPACK_IMPORTED_MODULE_1_app_core_core_module__["default"].directive('topologyGraph', topologyGraphDirective);


/***/ }),

/***/ 701:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export GuideCtrl */
/* unused harmony export guideDirective */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_module__ = __webpack_require__(2);
///<reference path="../../../headers/common.d.ts" />


var GuideCtrl = /** @class */ (function () {
    /** @ngInject */
    function GuideCtrl($rootScope, $scope, hostSrv, alertMgrSrv, $timeout, $q, $location, $controller, datasourceSrv) {
        var _this = this;
        this.$rootScope = $rootScope;
        this.$scope = $scope;
        this.hostSrv = hostSrv;
        this.alertMgrSrv = alertMgrSrv;
        this.$timeout = $timeout;
        this.$q = $q;
        this.$location = $location;
        this.$controller = $controller;
        this.datasourceSrv = datasourceSrv;
        this.exceptionMetrics = [];
        this.exceptionHosts = [];
        this.selected = {};
        this.stepIndex = 0;
        this.steps = [];
        $rootScope.onAppEvent('show-guide-book', this.showGuide.bind(this), $scope);
        // params: guide metric host start
        var searchParams = $location.search();
        searchParams.guide && (this.show = true);
        searchParams.host = searchParams.host || '*';
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.extend(this.selected, searchParams);
        // TO FIX: does not work sometimes
        $timeout(function () { _this.located(); }, 100);
        this.steps.push({
            title: 'i18n_guide_step1',
            cta: 'i18n_guide_step1',
            icon: 'icon-gf icon-gf-check',
            href: '/',
            note: '1) <br/>2) KPI<br/>3) KPI',
            check: function () { return $q.when(_this.$location.path() === '/'); },
            jumpTo: function () {
                _this.$location.url('/');
            }
        });
        this.steps.push({
            title: 'i18n_guide_step2',
            cta: 'i18n_guide_step2',
            icon: 'icon-gf icon-gf-apps',
            href: '/rca',
            note: '',
            check: function () { return $q.when(_this.$location.path() === '/rca'); },
            jumpTo: function () {
                _this.jump('/rca');
            }
        });
        this.steps.push({
            title: 'i18n_guide_step3',
            cta: 'i18n_guide_step3',
            icon: 'iconfont fa-association',
            href: '/association',
            note: '',
            check: function () { return $q.when(_this.$location.path() === '/association'); },
            jumpTo: function () {
                _this.jump('/association');
            }
        });
        this.steps.push({
            title: 'i18n_guide_step4',
            cta: 'i18n_guide_step4',
            icon: 'fa fa-fw fa-file-text-o',
            href: '/logs',
            note: '',
            check: function () { return $q.when(_this.$location.path() === '/logs'); },
            jumpTo: function () {
                var type = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.metricPrefix2Type(_this.selected.metric.split(".")[0]);
                var query = "type:" + type + " AND host:" + _this.selected.host;
                var path = '/logs';
                var url = path + "?guide&metric=" + _this.selected.metric + "&host=" + _this.selected.host + "&start=" + _this.selected.start + "&query=" + query;
                _this.$location.url(url);
            }
        });
        this.steps.push({
            title: 'i18n_guide_step5',
            cta: 'i18n_guide_step5',
            icon: 'iconfont fa-process',
            href: '/topn',
            note: '',
            check: function () { return $q.when(_this.$location.path() === '/topn'); },
            jumpTo: function () {
                _this.jump('/topn');
            }
        });
        $scope.$on('$routeUpdate', function () {
            var metric = _this.$location.search().metric;
            metric && !~_this.exceptionMetrics.indexOf(metric) && _this.exceptionMetrics.push(metric);
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.extend(_this.selected, _this.$location.search());
        });
        this.init();
    }
    GuideCtrl.prototype.init = function () {
        this.stepIndex = -1;
        this.getExceptionMetrics();
        this.getExceptionHost();
        return this.nextStep().then(function (res) {
        });
    };
    GuideCtrl.prototype.nextStep = function () {
        var _this = this;
        if (this.stepIndex === this.steps.length - 1) {
            return this.$q.when();
        }
        this.stepIndex += 1;
        var currentStep = this.steps[this.stepIndex];
        return currentStep.check().then(function (current) {
            if (current) {
                currentStep.cssClass = 'active';
                return _this.$q.when();
            }
            currentStep.cssClass = 'completed';
            return _this.nextStep();
        });
    };
    GuideCtrl.prototype.showGuide = function () {
        this.show = !this.show; // true;
    };
    GuideCtrl.prototype.dismiss = function () {
        this.show = false;
    };
    GuideCtrl.prototype.collapse = function () {
        this.collapsed = !this.collapsed;
    };
    GuideCtrl.prototype.located = function () {
        this.$rootScope.appEvent('exception-located', this.selected);
    };
    GuideCtrl.prototype.jump = function (path, hash) {
        var url = path + "?guide&metric=" + this.selected.metric + "&host=" + this.selected.host + "&start=" + this.selected.start;
        url += hash ? hash : '';
        this.$location.url(url);
    };
    GuideCtrl.prototype.onSelectChange = function () {
        var search = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.extend(this.$location.search(), this.selected);
        this.$location.search(search);
    };
    // TO IMPROVE: how to get all exception metrics? here are only alert metrics
    GuideCtrl.prototype.getExceptionMetrics = function () {
        var _this = this;
        this.exceptionMetrics = [];
        this.alertMgrSrv.loadTriggeredAlerts().then(function (response) {
            response.data && response.data.forEach(function (item) {
                _this.exceptionMetrics.push({
                    name: __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.getMetricName(item.metric),
                    time: item.status.levelChangedTime,
                    host: item.status.monitoredEntity
                });
            });
        });
    };
    GuideCtrl.prototype.getExceptionHost = function () {
        var _this = this;
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(this.hostSrv.hostInfo)) {
            this.hostSrv.getHostInfo().then(function (response) {
                _this.exceptionHosts = response;
            });
        }
        else {
            this.exceptionHosts = this.hostSrv.hostInfo;
        }
    };
    return GuideCtrl;
}());

function guideDirective() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/core/components/guide/guide.html',
        controller: GuideCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {
            needHost: '@',
            guideClass: '@',
            notMetric: '@'
        },
        link: function (scope, elem, attrs, ctrl) {
            var $scrollElement = elem.parent('.page-container');
            var scroll = function () {
                var scroll = $scrollElement.scrollTop();
                var shrinkHeader = ctrl.collapsed ? 90 : 230;
                ctrl.fixed = (scroll >= shrinkHeader) ? true : false;
                scope.$digest();
            };
            ctrl.show && $scrollElement.on('scroll', __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.throttle(scroll.bind(this), 100));
        }
    };
}
__WEBPACK_IMPORTED_MODULE_1__core_module__["default"].directive('guide', guideDirective);


/***/ }),

/***/ 702:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ToolbarCtrl */
/* unused harmony export toolbarDirective */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_module__ = __webpack_require__(2);
///<reference path="../../../headers/common.d.ts" />


var template = "\n  <div class=\"toolbar-content\">\n    <div class=\"popover-content\">\n      <a href=\"{{ item.href }}\" ng-repeat=\"item in toolbarItems\" class=\"toolbar-item {{ item.class }}\" ng-click=\"item.clickHandler()\">\n        <i class=\"{{ item.icon }}\"></i>\n        <p class=\"item-name\">{{ item.itemname }}</p>\n      </a>\n    </div>\n  </div>\n";
var ToolbarCtrl = /** @class */ (function () {
    /** @ngInject */
    function ToolbarCtrl($rootScope, $scope, popoverSrv, backendSrv, $q, $location, contextSrv, $translate) {
        this.$rootScope = $rootScope;
        this.$scope = $scope;
        this.popoverSrv = popoverSrv;
        this.backendSrv = backendSrv;
        this.$q = $q;
        this.$location = $location;
        this.contextSrv = contextSrv;
        this.$translate = $translate;
        this.toolbarItems = {};
        this.toolbarItems[1] = [];
        this.toolbarItems[1].push({
            class: '',
            icon: 'fa fa-fw fa-book',
            itemname: $translate.i18n.i18n_kb,
            href: '/knowledgebase',
            clickHandler: function () { },
        });
        this.toolbarItems[2] = [];
        if (!contextSrv.isViewer) {
            this.toolbarItems[2].push({
                class: '',
                icon: 'fa fa-fw fa-cloud-download',
                itemname: $translate.i18n.i18n_install_guide,
                href: '/setting/agent',
                clickHandler: function () { },
            });
        }
        this.toolbarItems[2].push({
            class: '',
            icon: 'fa fa-fw fa-info-circle',
            itemname: $translate.i18n.i18n_usage_guide,
            href: 'javascript:;',
            clickHandler: function () {
                $rootScope.appEvent('show-modal', {
                    src: 'public/app/core/components/toolbar/guide_use.html',
                    modalClass: 'guide_use',
                    scope: $scope.$new(),
                });
            }
        });
    }
    ToolbarCtrl.prototype.showPopover = function () {
        this.popoverSrv.show({
            element: __WEBPACK_IMPORTED_MODULE_0_jquery___default()(".toolbar-" + this.$scope.ctrl.id)[0],
            position: 'bottom center',
            template: template,
            classes: 'toolbar-popover',
            model: {
                toolbarItems: this.toolbarItems[+this.$scope.ctrl.id],
            },
        });
    };
    return ToolbarCtrl;
}());

function toolbarDirective() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/core/components/toolbar/toolbar.html',
        controller: ToolbarCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {
            icon: "@",
            tooltip: "@",
            id: "@"
        },
    };
}
__WEBPACK_IMPORTED_MODULE_1__core_module__["default"].directive('toolbar', toolbarDirective);


/***/ }),

/***/ 703:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CwizSwitchCtrl */
/* unused harmony export cwizSwitchDirective */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />

var template = "\n<span class=\"cwiz-switch {{ ctrl.switchClass }}\" ng-class=\"{ 'checked': ctrl.enabled }\">\n  <input type=\"checkbox\" id=\"check1\" ng-class=\"{ 'checked': ctrl.enabled }\" ng-model=\"ctrl.enabled\" ng-change=\"ctrl.internalOnChange();\" hidden />\n  <label for=\"check1\"></label>\n  <span class=\"switch-text\">\n    <span class=\"on\">{{ ctrl.textOn }}</span>\n    <span class=\"off\">{{ ctrl.textOff }}</span>\n  </span>\n</span>\n";
var CwizSwitchCtrl = /** @class */ (function () {
    /** @ngInject */
    function CwizSwitchCtrl($scope, $timeout) {
        this.$scope = $scope;
        this.$timeout = $timeout;
    }
    CwizSwitchCtrl.prototype.internalOnChange = function () {
        var _this = this;
        return this.$timeout(function () {
            return _this.onChange();
        });
    };
    return CwizSwitchCtrl;
}());

function cwizSwitchDirective() {
    return {
        restrict: 'AE',
        controller: CwizSwitchCtrl,
        controllerAs: 'ctrl',
        bindToController: true,
        scope: {
            switchClass: "@",
            textOn: "@",
            textOff: "@",
            enabled: "=",
            onChange: "&"
        },
        template: template,
    };
}
__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].directive('cwizSwitch', cwizSwitchDirective);


/***/ }),

/***/ 704:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export TreeMenuCtrl */
/* unused harmony export treeMenu */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_core_module__ = __webpack_require__(2);




var custom_metric;
var TreeMenuCtrl = /** @class */ (function () {
    /** @ngInject */
    function TreeMenuCtrl($scope, associationSrv, $rootScope, $timeout, $controller, backendSrv, contextSrv, healthSrv, alertMgrSrv, timeSrv, $translate) {
        var _this = this;
        this.$scope = $scope;
        this.associationSrv = associationSrv;
        this.$rootScope = $rootScope;
        this.$timeout = $timeout;
        this.$controller = $controller;
        this.backendSrv = backendSrv;
        this.contextSrv = contextSrv;
        this.healthSrv = healthSrv;
        this.alertMgrSrv = alertMgrSrv;
        this.timeSrv = timeSrv;
        this.$translate = $translate;
        custom_metric = this.$translate.i18n.page_metrics_custom;
        this.isOpen = false;
        this.isLoding = true;
        this.groupType = 'metrics';
        this.limitTime = 2;
        var analysis = this.$rootScope.$on('analysis', function (event, data) {
            switch (data) {
                case 'thresholdSlider':
                    _this.associationSrv.updateRang(_this.$scope.$parent.thresholdSlider.get());
                    _this.init();
                    _this.refresh();
                    break;
                case 'updateTime':
                    _this.initByTime();
                    break;
                default:
                    var association = _this.associationSrv.sourceAssociation;
                    _this.loadAssociatedPeriods({
                        metric: association.metric,
                        host: association.host
                    }).then(function (res) {
                        _this.init();
                    });
                    break;
            }
        });
        this.$scope.$on('$destroy', function () {
            analysis();
            _this.associationSrv.sourceAssociation = {};
        });
        this.yaxisNumber = 3;
        this.prox = this.contextSrv.user.orgId + '.' + this.contextSrv.user.systemId + '.';
        this.timeRange = {
            from: this.timeSrv.timeRange().from.unix(),
            to: this.timeSrv.timeRange().to.unix()
        };
        this.backendSrv.get('/api/static/config').then(function (res) {
            _this.limitTime = res.limit_association;
        });
    }
    TreeMenuCtrl.prototype.init = function (type) {
        var _this = this;
        this.groupType = type || this.groupType;
        this.isOpen = true;
        this.isLoding = true;
        this.isAssociation = false;
        var association = this.associationSrv.sourceAssociation;
        this.clearSelected();
        var params = {
            metric: association.metric,
            host: association.host,
            minDistance: 1000 - association.max,
            maxDistance: 1000 - association.min,
            group: this.groupType,
            startSec: this.timeRange.from,
            endSec: this.timeRange.to
        };
        if (!__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(association)) {
            if (this.periods) {
                this.loadAssociatedMetrics(params);
            }
            else {
                this.loadAssociatedPeriods({
                    metric: association.metric,
                    host: association.host
                }).then(function (res) {
                    params.startSec = res.from;
                    params.endSec = res.to;
                    _this.loadAssociatedMetrics(params);
                });
            }
        }
    };
    TreeMenuCtrl.prototype.loadAssociatedPeriods = function (params) {
        var _this = this;
        return this.alertMgrSrv.loadAssociatedPeriods(params).then(function (res) {
            _this.periods = res.data;
            if (_this.periods.length) {
                _this.updateTimeRange(_this.periods[0]);
            }
            else {
                _this.periods = [];
                _this.periods.push({
                    o1: _this.timeRange.from,
                    o2: _this.timeRange.to,
                });
            }
            return _this.timeRange;
        });
    };
    TreeMenuCtrl.prototype.loadAssociatedMetrics = function (params) {
        var _this = this;
        this.alertMgrSrv.loadAssociatedMetrics(params)
            .then(function (res) {
            if (_this.groupType === 'metrics') {
                _this.correlationMetrics = res.data;
            }
            else {
                _this.correlationHosts = res.data;
            }
            if (!__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(res.data)) {
                _this.isAssociation = true;
            }
            _this.isLoding = false;
        }, function () {
            _this.isLoding = false;
        });
    };
    TreeMenuCtrl.prototype.showTree = function () {
        var _this = this;
        this.isOpen = !this.isOpen;
        this.$timeout(function () {
            _this.$rootScope.$broadcast('render');
        });
    };
    TreeMenuCtrl.prototype.showNewAssociationManual = function () {
        var _this = this;
        var newScope = this.$scope.$new();
        newScope.datasource = this.$scope.datasource;
        newScope.addManualMetric = this.addManualMetric.bind(this);
        this.$controller('OpenTSDBQueryCtrl', { $scope: newScope });
        this.backendSrv.getHosts({
            "queries": [],
            "hostProperties": ["id"]
        }).then(function (response) {
            _this.$scope.suggestTagHost = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(response.data, 'hostname');
        });
        this.$scope.appEvent('show-modal', {
            src: 'public/app/partials/manual_association.html',
            modalClass: 'modal-no-header confirm-modal',
            scope: newScope
        });
    };
    TreeMenuCtrl.prototype.addManualMetric = function (target) {
        target.metric = this.prox + target.metric;
        var custom = null;
        if (this.groupType === 'metrics') {
            (!this.correlationMetrics[custom_metric]) && (this.correlationMetrics[custom_metric] = {});
            custom = this.correlationMetrics[custom_metric];
            var key = target.metric;
            var value = target.host;
            var type = 'hosts';
        }
        else {
            (!this.correlationHosts['']) && (this.correlationHosts[custom_metric] = {});
            custom = this.correlationHosts[custom_metric];
            key = target.host;
            value = target.metric;
            type = 'metrics';
        }
        (!custom[key]) && (custom[key] = {});
        custom[key][type] = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.union(custom[key][type], [value]);
        this.isAssociation = true;
    };
    TreeMenuCtrl.prototype.clearSelected = function () {
        var _this = this;
        if (this.panel) {
            var sourceMetric = this.associationSrv.sourceAssociation;
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(this.panel.targets, function (target) {
                if (!_this.checkSource(_this.prox + target.metric, target.tags.host)) {
                    target.hide = true;
                }
            });
        }
        __WEBPACK_IMPORTED_MODULE_1_jquery___default()('[type="checkbox"]').prop({ checked: false });
        __WEBPACK_IMPORTED_MODULE_1_jquery___default()('[disabled="disabled"]').prop({ checked: true });
    };
    TreeMenuCtrl.prototype.addQuery = function (event, metric, host, otherMetric) {
        var _this = this;
        if (host === custom_metric && this.groupType === 'hosts') {
            host = otherMetric;
        }
        if (this.checkSource(this.prox + metric, host)) {
            return;
        }
        else {
            var $currentTarget = __WEBPACK_IMPORTED_MODULE_1_jquery___default()(event.currentTarget);
            var $target = __WEBPACK_IMPORTED_MODULE_1_jquery___default()(event.target);
            if (!$target.is('input')) {
                var $input = $currentTarget.find('input');
                var checked = $input.prop('checked');
                $input.prop({ checked: !checked });
            }
            var targets = this.panel.targets;
            var isHidden = true;
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(targets, function (target) {
                if (target.metric === metric && target.tags.host === host) {
                    isHidden = false;
                    target.hide = !target.hide;
                }
            });
            if (isHidden) {
                var target = {
                    "aggregator": "avg",
                    "currentTagKey": "",
                    "currentTagValue": "",
                    "downsampleAggregator": "avg",
                    "downsampleInterval": this.panel.downsample,
                    "errors": {},
                    "hide": false,
                    "isCounter": false,
                    "metric": metric,
                    "shouldComputeRate": false,
                    "tags": { "host": host }
                };
                targets.push(target);
                var seriesOverride = {
                    "alias": metric + "{host" + "=" + host + "}",
                    "yaxis": this.yaxisNumber++
                };
                this.panel.seriesOverrides.push(seriesOverride);
            }
            this.healthSrv.transformPanelMetricType(this.panel).then(function () {
                _this.refresh();
            });
        }
    };
    TreeMenuCtrl.prototype.toggleClass = function (event, metric, host) {
        var _i = __WEBPACK_IMPORTED_MODULE_1_jquery___default()(event.target);
        var _is = __WEBPACK_IMPORTED_MODULE_1_jquery___default()(event.currentTarget).find('i');
        if (_i.hasClass('add-rca')) {
            _is[1].className = 'fa fa-thumbs-o-down';
            _i.hasClass('fa-thumbs-o-up')
                ? (_i.removeClass('fa-thumbs-o-up').addClass('fa-thumbs-up') && this.addRCA(metric, host))
                : _i.removeClass('fa-thumbs-up').addClass('fa-thumbs-o-up');
        }
        else {
            _is[0].className = 'fa fa-thumbs-o-up add-rca';
            _i.hasClass('fa-thumbs-o-down')
                ? _i.removeClass('fa-thumbs-o-down').addClass('fa-thumbs-down')
                : _i.removeClass('fa-thumbs-down').addClass('fa-thumbs-o-down');
        }
    };
    TreeMenuCtrl.prototype.addRCA = function (metric, host) {
        if (!this.contextSrv.isViewer) {
            var rcaFeedback = {
                alertIds: [],
                timestampInSec: Math.round(new Date().getTime() / 1000),
                triggerMetric: {
                    name: this.associationSrv.sourceAssociation.metric,
                    host: this.associationSrv.sourceAssociation.host,
                },
                rootCauseMetrics: [{
                        name: this.prox + metric,
                        host: host,
                        confidenceLevel: 100
                    }],
                relatedMetrics: [],
                org: this.contextSrv.user.orgId,
                sys: this.contextSrv.user.systemId
            };
            this.alertMgrSrv.rcaFeedback(rcaFeedback);
        }
    };
    TreeMenuCtrl.prototype.toggleAccordion = function (event) {
        var _i = __WEBPACK_IMPORTED_MODULE_1_jquery___default()(event.currentTarget).find('i');
        _i.hasClass('fa-plus-square-o')
            ? _i.removeClass('fa-plus-square-o').addClass('fa-minus-square-o')
            : _i.removeClass('fa-minus-square-o').addClass('fa-plus-square-o');
    };
    TreeMenuCtrl.prototype.checkSource = function (metric, host) {
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEqual(metric, this.associationSrv.sourceAssociation.metric) &&
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEqual(host, this.associationSrv.sourceAssociation.host);
    };
    TreeMenuCtrl.prototype.initByTime = function () {
        var _this = this;
        var start = this.timeSrv.timeRange().from.unix();
        var from = __WEBPACK_IMPORTED_MODULE_2_moment___default()(start * 1000);
        var end = this.timeSrv.timeRange().to.unix();
        var diff = __WEBPACK_IMPORTED_MODULE_2_moment___default()().diff(from, 'days', true);
        if (diff > this.limitTime) {
            this.$scope.appEvent('alert-warning', ['' + this.limitTime + '', '' + this.limitTime + '']);
            return;
        }
        diff = __WEBPACK_IMPORTED_MODULE_2_moment___default()(end * 1000).diff(from, 'minutes');
        if (diff < 20) {
            this.$scope.appEvent('alert-warning', ['20', '20']);
            return;
        }
        this.$scope.appEvent('confirm-modal', {
            title: this.$translate.i18n.i18n_confirm,
            text: this.$translate.i18n.page_association_info4,
            yesText: this.$translate.i18n.i18n_confirm,
            noText: this.$translate.i18n.i18n_cancel,
            onConfirm: function () {
                _this.timeRange.from = start;
                _this.timeRange.to = end;
                _this.periods.push({
                    o1: start,
                    o2: end
                });
                _this.init();
            }
        });
    };
    TreeMenuCtrl.prototype.updateTimeRange = function (period) {
        this.timeRange.from = period.o1;
        this.timeRange.to = period.o2;
        this.timeSrv.setTime({ from: __WEBPACK_IMPORTED_MODULE_2_moment___default()(this.timeRange.from * 1000), to: __WEBPACK_IMPORTED_MODULE_2_moment___default()(this.timeRange.to * 1000) }, false);
    };
    TreeMenuCtrl.prototype.refresh = function () {
        this.$rootScope.$broadcast('refresh', this.panel.id);
    };
    return TreeMenuCtrl;
}());

function treeMenu() {
    return {
        restrict: 'E',
        controller: TreeMenuCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        templateUrl: 'public/app/core/components/tree_menu/tree_menu.html',
        link: function (scope, elem, attrs, ctrl) {
            ctrl.panel = scope.$parent.panel;
        }
    };
}
__WEBPACK_IMPORTED_MODULE_3_app_core_core_module__["default"].directive('cwTreeMenu', treeMenu);


/***/ }),

/***/ 705:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export KnowledgeBaseCtrl */
/* unused harmony export knowledgeBaseDirective */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
throw new Error("Cannot find module \"ng-quill\"");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_module__ = __webpack_require__(2);
///<reference path="../../../headers/common.d.ts" />



var KnowledgeBaseCtrl = /** @class */ (function () {
    /** @ngInject */
    function KnowledgeBaseCtrl($scope, $rootScope, backendSrv, contextSrv, $translate) {
        var _this = this;
        this.$scope = $scope;
        this.$rootScope = $rootScope;
        this.backendSrv = backendSrv;
        this.contextSrv = contextSrv;
        this.$translate = $translate;
        this.q = "*";
        this.service = "*";
        this.services = ["*", "system", "hadoop", "hbase", "kafka", "mysql", "spark", "storm", "yarn", "zookeeper", "tomcat", "opentsdb", "mongo3", "nginx", "windows", "exchange"];
        this.fullText = [];
        this.readOnly = true;
        $scope.$on("$destroy", function () {
            window.removeEventListener('popstate', _this.pushState);
        });
    }
    KnowledgeBaseCtrl.prototype.query = function () {
        var _this = this;
        this.showList = true;
        this.showCreatForm = false;
        var params = {
            q: this.q
        };
        if (this.service !== "*") {
            params['service'] = this.service;
        }
        this.backendSrv.knowledge({
            method: "GET",
            url: "/search",
            params: params,
        }).then(function (result) {
            _this.knowledge = result.data;
            _this.knowledgeCopy = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.cloneDeep(result.data);
        });
    };
    KnowledgeBaseCtrl.prototype.initNewKnows = function () {
        this.showCreatForm = true;
        this.newKnowledge = {
            solution: "",
            service: ""
        };
    };
    KnowledgeBaseCtrl.prototype.newKnowsByLog = function () {
        var _this = this;
        this.newKnowledge.symptom = this.q;
        this.newKnowledge.org_id = this.contextSrv.user.orgId;
        this.newKnowledge.system_id = this.contextSrv.user.systemId;
        this.backendSrv.knowledge({
            method: "PUT",
            url: "",
            data: this.newKnowledge
        }).then(function (res) {
            res.data.isSuccessful && _this.$scope.appEvent('alert-success', [_this.$translate.i18n.i18n_success]);
        });
        this.showCreatForm = false;
    };
    KnowledgeBaseCtrl.prototype.cancelCreate = function () {
        this.showCreatForm = false;
    };
    KnowledgeBaseCtrl.prototype.textOverflow = function (index) {
        this.fullText[index] = !this.fullText[index];
    };
    KnowledgeBaseCtrl.prototype.editorCreated = function (editor, knowledge, isDetail) {
        if (isDetail) {
            editor.root.innerHTML = knowledge;
        }
        else {
            var tmp = knowledge.trim();
            tmp = tmp.replace(/[\r]?\n/g, '');
            tmp = tmp.replace(/<\/?[ol|li|blockquote|pre]+>/g, '');
            tmp = tmp.replace(/<.*\b">/g, '');
            tmp = tmp.replace(/<\/?.*\b>/g, '');
            var length = tmp.length > 100 ? 100 : tmp.length;
            var end = tmp.length > 100 ? '...' : '';
            editor.root.innerHTML = tmp.substring(0, length) + end;
        }
    };
    KnowledgeBaseCtrl.prototype.getDetail = function (knowledge) {
        this.showList = false;
        this.detailKnowledge = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(this.knowledgeCopy, { id: knowledge.id });
        history.pushState(null, null, document.URL);
        window.addEventListener('popstate', this.pushState);
    };
    KnowledgeBaseCtrl.prototype.getList = function () {
        this.showList = true;
    };
    // 
    KnowledgeBaseCtrl.prototype.pushState = function () {
        history.pushState(null, null, document.URL);
    };
    return KnowledgeBaseCtrl;
}());

function knowledgeBaseDirective() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/core/components/knowledge_base/knowledge_body.html',
        controller: KnowledgeBaseCtrl,
        bindToController: true,
        transclude: true,
        controllerAs: 'ctrl',
        scope: {},
        link: function (scope, elem, attrs, ctrl) {
        }
    };
}
__WEBPACK_IMPORTED_MODULE_2__core_module__["default"].directive('knowledgeBase', knowledgeBaseDirective);


/***/ }),

/***/ 706:
/***/ (function(module, exports) {

throw new Error("Module build failed: Error: Final loader didn't return a Buffer or String\n    at runLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/webpack/lib/NormalModule.js:204:46)\n    at /Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:370:3\n    at iterateNormalLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:211:10)\n    at iterateNormalLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:218:10)\n    at /Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:233:3\n    at context.callback (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:111:13)\n    at process._tickCallback (internal/process/next_tick.js:103:7)");

/***/ }),

/***/ 707:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export GrafanaCtrl */
/* unused harmony export grafanaAppDirective */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_config__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_app_core_config__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_store__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_store___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_app_core_store__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_jquery__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />






var locale = 'zh-CN';
var GrafanaCtrl = /** @class */ (function () {
    /** @ngInject */
    function GrafanaCtrl($scope, alertSrv, utilSrv, $rootScope, $controller, contextSrv, $location, healthSrv, backendSrv) {
        $scope.init = function () {
            $scope.contextSrv = contextSrv;
            $scope._ = __WEBPACK_IMPORTED_MODULE_2_lodash___default.a;
            $rootScope.profilingEnabled = __WEBPACK_IMPORTED_MODULE_1_app_core_store___default.a.getBool('profilingEnabled');
            $rootScope.performance = { loadStart: new Date().getTime() };
            $rootScope.appSubUrl = __WEBPACK_IMPORTED_MODULE_0_app_core_config___default.a.appSubUrl;
            if ($rootScope.profilingEnabled) {
                $scope.initProfiling();
            }
            alertSrv.init();
            utilSrv.init();
            if (!($location.path() === '/login' || $location.path() === '/signupfree')) {
                backendSrv.initCustomizedSources();
                backendSrv.updateTokens();
            }
            $scope.dashAlerts = alertSrv;
        };
        $scope.initDashboard = function (dashboardData, viewScope) {
            $rootScope.mainScope = viewScope;
            dashboardData.dashboard.system = contextSrv.user.systemId;
            healthSrv.transformMetricType(dashboardData.dashboard).then(function () {
                $controller('DashboardCtrl', { $scope: viewScope }).init(dashboardData);
                contextSrv.user.systemId = dashboardData.dashboard.system || 0;
            });
        };
        $rootScope.onAppEvent = function (name, callback, localScope) {
            var unbind = $rootScope.$on(name, callback);
            var callerScope = this;
            if (callerScope.$id === 1 && !localScope) {
                console.log('warning rootScope onAppEvent called without localscope');
            }
            if (localScope) {
                callerScope = localScope;
            }
            callerScope.$on('$destroy', unbind);
        };
        $rootScope.appEvent = function (name, payload) {
            $rootScope.$emit(name, payload);
        };
        $rootScope.colors = [
            "#7EB26D", "#EAB839", "#6ED0E0", "#EF843C", "#E24D42", "#1F78C1", "#BA43A9", "#705DA0",
            "#508642", "#CCA300", "#447EBC", "#C15C17", "#890F02", "#0A437C", "#6D1F62", "#584477",
            "#B7DBAB", "#F4D598", "#70DBED", "#F9BA8F", "#F29191", "#82B5D8", "#E5A8E2", "#AEA2E0",
            "#629E51", "#E5AC0E", "#64B0C8", "#E0752D", "#BF1B00", "#0A50A1", "#962D82", "#614D93",
            "#9AC48A", "#F2C96D", "#65C5DB", "#F9934E", "#EA6460", "#5195CE", "#D683CE", "#806EB7",
            "#3F6833", "#967302", "#2F575E", "#99440A", "#58140C", "#052B51", "#511749", "#3F2B5B",
            "#E0F9D7", "#FCEACA", "#CFFAFF", "#F9E2D2", "#FCE2DE", "#BADFF4", "#F9D9F9", "#DEDAF7"
        ];
        $scope.getTotalWatcherCount = function () {
            var count = 0;
            var scopes = 0;
            var root = __WEBPACK_IMPORTED_MODULE_4_jquery___default()(document.getElementsByTagName('body'));
            var f = function (element) {
                if (element.data().hasOwnProperty('$scope')) {
                    scopes++;
                    __WEBPACK_IMPORTED_MODULE_3_angular___default.a.forEach(element.data().$scope.$$watchers, function () {
                        count++;
                    });
                }
                __WEBPACK_IMPORTED_MODULE_3_angular___default.a.forEach(element.children(), function (childElement) {
                    f(__WEBPACK_IMPORTED_MODULE_4_jquery___default()(childElement));
                });
            };
            f(root);
            $rootScope.performance.scopeCount = scopes;
            return count;
        };
        $scope.initProfiling = function () {
            var count = 0;
            $scope.$watch(function digestCounter() {
                count++;
            }, function () {
                // something
            });
            $rootScope.performance.panels = [];
            $scope.$on('refresh', function () {
                if ($rootScope.performance.panels.length > 0) {
                    var totalRender = 0;
                    var totalQuery = 0;
                    __WEBPACK_IMPORTED_MODULE_2_lodash___default.a.each($rootScope.performance.panels, function (panelTiming) {
                        totalRender += panelTiming.render;
                        totalQuery += panelTiming.query;
                    });
                    console.log('total query: ' + totalQuery);
                    console.log('total render: ' + totalRender);
                    console.log('avg render: ' + totalRender / $rootScope.performance.panels.length);
                }
                $rootScope.performance.panels = [];
            });
            $scope.onAppEvent('dashboard-loaded', function () {
                count = 0;
                setTimeout(function () {
                    console.log("Dashboard::Performance Total Digests: " + count);
                    console.log("Dashboard::Performance Total Watchers: " + $scope.getTotalWatcherCount());
                    console.log("Dashboard::Performance Total ScopeCount: " + $rootScope.performance.scopeCount);
                    var timeTaken = $rootScope.performance.allPanelsInitialized - $rootScope.performance.dashboardLoadStart;
                    console.log("Dashboard::Performance - All panels initialized in " + timeTaken + " ms");
                    // measure digest performance
                    var rootDigestStart = window.performance.now();
                    for (var i = 0; i < 30; i++) {
                        $rootScope.$apply();
                    }
                    console.log("Dashboard::Performance Root Digest " + ((window.performance.now() - rootDigestStart) / 30));
                }, 3000);
            });
        };
        $scope.init();
    }
    return GrafanaCtrl;
}());

/** @ngInject */
function grafanaAppDirective(playlistSrv, contextSrv, $translate) {
    return {
        restrict: 'E',
        controller: GrafanaCtrl,
        link: function (scope, elem, attr) {
            var ignoreSideMenuHide;
            var body = __WEBPACK_IMPORTED_MODULE_4_jquery___default()('body');
            locale = attr.locale;
            // handle sidemenu open state
            scope.$watch('contextSrv.sidemenu', function (newVal) {
                if (newVal !== undefined) {
                    body.toggleClass('sidemenu-open', scope.contextSrv.sidemenu);
                    if (!newVal) {
                        contextSrv.setPinnedState(false);
                    }
                }
                if (contextSrv.sidemenu) {
                    ignoreSideMenuHide = true;
                    setTimeout(function () {
                        ignoreSideMenuHide = false;
                    }, 300);
                }
            });
            scope.$watch('contextSrv.pinned', function (newVal) {
                if (newVal !== undefined) {
                    body.toggleClass('sidemenu-pinned', newVal);
                }
            });
            // tooltip removal fix
            // manage page classes
            var pageClass;
            scope.$on("$routeChangeSuccess", function (evt, data) {
                if (pageClass) {
                    body.removeClass(pageClass);
                }
                pageClass = data.$$route.pageClass;
                if (pageClass) {
                    body.addClass(pageClass);
                }
                __WEBPACK_IMPORTED_MODULE_4_jquery___default()("#tooltip, .tooltip").remove();
            });
            // handle document clicks that should hide things
            body.click(function (evt) {
                var target = __WEBPACK_IMPORTED_MODULE_4_jquery___default()(evt.target);
                if (target.parents().length === 0) {
                    return;
                }
                if (target.parents('.dash-playlist-actions').length === 0) {
                    playlistSrv.stop();
                }
                // hide search
                if (body.find('.search-container').length > 0) {
                    if (target.parents('.search-container').length === 0) {
                        scope.$apply(function () {
                            scope.appEvent('hide-dash-search');
                        });
                    }
                }
                // hide sidemenu
                if (!ignoreSideMenuHide && !contextSrv.pinned && body.find('.sidemenu').length > 0) {
                    if (target.parents('.sidemenu').length === 0) {
                        scope.$apply(function () {
                            scope.contextSrv.toggleSideMenu();
                        });
                    }
                }
                // hide popovers
                var popover = elem.find('.popover');
                if (popover.length > 0 && target.parents('.graph-legend').length === 0) {
                    popover.hide();
                }
            });
        }
    };
}
__WEBPACK_IMPORTED_MODULE_5_app_core_core_module__["default"].directive('grafanaApp', grafanaAppDirective);
// coreModule.config(['$translateProvider', ($translateProvider) => {
//   $translateProvider.useStaticFilesLoader({
//     prefix: 'public/app/core/i18n/',
//     suffix: '.json'
//   });
//   $translateProvider.preferredLanguage('zh_CN');
// }]);


/***/ }),

/***/ 708:
/***/ (function(module, exports) {

throw new Error("Module build failed: Error: Final loader didn't return a Buffer or String\n    at runLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/webpack/lib/NormalModule.js:204:46)\n    at /Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:370:3\n    at iterateNormalLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:211:10)\n    at iterateNormalLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:218:10)\n    at /Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:233:3\n    at context.callback (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:111:13)\n    at process._tickCallback (internal/process/next_tick.js:103:7)");

/***/ }),

/***/ 709:
/***/ (function(module, exports) {

throw new Error("Module build failed: Error: Final loader didn't return a Buffer or String\n    at runLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/webpack/lib/NormalModule.js:204:46)\n    at /Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:370:3\n    at iterateNormalLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:211:10)\n    at iterateNormalLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:218:10)\n    at /Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:233:3\n    at context.callback (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:111:13)\n    at process._tickCallback (internal/process/next_tick.js:103:7)");

/***/ }),

/***/ 710:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export infoPopover */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_tether_drop__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_tether_drop___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_tether_drop__);
///<reference path="../../headers/common.d.ts" />



function infoPopover() {
    return {
        restrict: 'E',
        template: '<i class="fa fa-info-circle"></i>',
        transclude: true,
        link: function (scope, elem, attrs, ctrl, transclude) {
            var offset = attrs.offset || '0 -10px';
            var position = attrs.position || 'right middle';
            var classes = 'drop-help drop-hide-out-of-bounds';
            var openOn = 'hover';
            elem.addClass('gf-form-help-icon');
            if (attrs.wide) {
                classes += ' drop-wide';
            }
            if (attrs.mode) {
                elem.addClass('gf-form-help-icon--' + attrs.mode);
            }
            transclude(function (clone, newScope) {
                var content = document.createElement("div");
                __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(clone, function (node) {
                    content.appendChild(node);
                });
                var drop = new __WEBPACK_IMPORTED_MODULE_2_tether_drop___default.a({
                    target: elem[0],
                    content: content,
                    position: position,
                    classes: classes,
                    openOn: openOn,
                    hoverOpenDelay: 400,
                    tetherOptions: {
                        offset: offset
                    }
                });
                scope.$on('$destroy', function () {
                    drop.destroy();
                });
            });
        }
    };
}
__WEBPACK_IMPORTED_MODULE_1_app_core_core_module__["default"].directive('infoPopover', infoPopover);


/***/ }),

/***/ 711:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ColorPickerCtrl */
/* unused harmony export colorPicker */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />

var template = "\n<div class=\"graph-legend-popover\">\n  <div ng-show=\"ctrl.series\" class=\"p-b-1\">\n    <label>Y Axis:</label>\n    <button ng-click=\"ctrl.toggleAxis(yaxis);\" class=\"btn btn-small\"\n            ng-class=\"{'btn-success': ctrl.series.yaxis === 1,\n                       'btn-inverse': ctrl.series.yaxis === 2}\">\n      Left\n    </button>\n    <button ng-click=\"ctrl.toggleAxis(yaxis);\"\n      class=\"btn btn-small\"\n      ng-class=\"{'btn-success': ctrl.series.yaxis === 2,\n                 'btn-inverse': ctrl.series.yaxis === 1}\">\n      Right\n    </button>\n  </div>\n\n  <p class=\"m-b-0\">\n   <i ng-repeat=\"color in ctrl.colors\" class=\"pointer fa fa-circle\"\n    ng-style=\"{color:color}\"\n    ng-click=\"ctrl.colorSelected(color);\">&nbsp;</i>\n  </p>\n</div>\n";
var ColorPickerCtrl = /** @class */ (function () {
    /** @ngInject */
    function ColorPickerCtrl($scope, $rootScope) {
        this.$scope = $scope;
        this.$rootScope = $rootScope;
        this.colors = $rootScope.colors;
        this.autoClose = $scope.autoClose;
        this.series = $scope.series;
    }
    ColorPickerCtrl.prototype.toggleAxis = function (yaxis) {
        this.$scope.toggleAxis();
        if (this.$scope.autoClose) {
            this.$scope.dismiss();
        }
    };
    ColorPickerCtrl.prototype.colorSelected = function (color) {
        this.$scope.colorSelected(color);
        if (this.$scope.autoClose) {
            this.$scope.dismiss();
        }
    };
    return ColorPickerCtrl;
}());

function colorPicker() {
    return {
        restrict: 'E',
        controller: ColorPickerCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        template: template,
    };
}
__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].directive('gfColorPicker', colorPicker);


/***/ }),

/***/ 712:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export NavbarCtrl */
/* unused harmony export navbarDirective */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_config__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_app_core_config__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_module__ = __webpack_require__(2);
///<reference path="../../../headers/common.d.ts" />



var NavbarCtrl = /** @class */ (function () {
    /** @ngInject */
    function NavbarCtrl($scope, $rootScope, $location, contextSrv) {
        this.$scope = $scope;
        this.$rootScope = $rootScope;
        this.$location = $location;
        this.contextSrv = contextSrv;
        !!~['/rca', '/association', '/logs', '/topn'].indexOf(this.$location.path()) && (this.showGuideNav = true);
        this.showNavbarPageBtn = (this.$location.path() === '/');
        this.deadline = __WEBPACK_IMPORTED_MODULE_1_moment___default()(contextSrv.user.deadline).diff(__WEBPACK_IMPORTED_MODULE_1_moment___default()(), 'days');
        this.priceUrl = '//cloudwiz.cn/product_price.html';
    }
    NavbarCtrl.prototype.showGuide = function () {
        this.$rootScope.appEvent('show-guide-book');
    };
    NavbarCtrl.prototype.updateIndex = function () {
        if (this.$location.path() === '/') {
            window.location.href = __WEBPACK_IMPORTED_MODULE_0_app_core_config___default.a.appSubUrl + '/';
        }
        else {
            this.$location.url('/');
        }
    };
    return NavbarCtrl;
}());

function navbarDirective() {
    return {
        restrict: 'E',
        templateUrl: 'public/app/core/components/navbar/navbar.html',
        controller: NavbarCtrl,
        bindToController: true,
        transclude: true,
        controllerAs: 'ctrl',
        scope: {
            text: "@",
            titleUrl: "@",
            iconUrl: "@",
        },
        link: function (scope, elem, attrs, ctrl) {
            ctrl.icon = attrs.icon;
            elem.addClass('navbar');
        }
    };
}
__WEBPACK_IMPORTED_MODULE_2__core_module__["default"].directive('navbar', navbarDirective);


/***/ }),

/***/ 713:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export arrayJoin */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />


function arrayJoin() {
    'use strict';
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function (scope, element, attr, ngModel) {
            function split_array(text) {
                return (text || '').split(',');
            }
            function join_array(text) {
                if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(text)) {
                    return (text || '').join(',');
                }
                else {
                    return text;
                }
            }
            ngModel.$parsers.push(split_array);
            ngModel.$formatters.push(join_array);
        }
    };
}
__WEBPACK_IMPORTED_MODULE_1__core_module__["default"].directive('arrayJoin', arrayJoin);


/***/ }),

/***/ 714:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export LiveSrv */
/* unused harmony export liveSrv */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_config__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_app_core_config__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vendor_npm_rxjs_Observable__ = __webpack_require__(715);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vendor_npm_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_vendor_npm_rxjs_Observable__);
///<reference path="../../headers/common.d.ts" />



var LiveSrv = /** @class */ (function () {
    function LiveSrv() {
        this.observers = {};
    }
    LiveSrv.prototype.getWebSocketUrl = function () {
        var l = window.location;
        return ((l.protocol === "https:") ? "wss://" : "ws://") + l.host + __WEBPACK_IMPORTED_MODULE_1_app_core_config___default.a.appSubUrl + '/ws';
    };
    LiveSrv.prototype.getConnection = function () {
        var _this = this;
        if (this.initPromise) {
            return this.initPromise;
        }
        if (this.conn && this.conn.readyState === 1) {
            return Promise.resolve(this.conn);
        }
        this.initPromise = new Promise(function (resolve, reject) {
            console.log('Live: connecting...');
            _this.conn = new WebSocket(_this.getWebSocketUrl());
            _this.conn.onclose = function (evt) {
                console.log("Live: websocket onclose", evt);
                reject({ message: 'Connection closed' });
                _this.initPromise = null;
                setTimeout(_this.reconnect.bind(_this), 2000);
            };
            _this.conn.onmessage = function (evt) {
                _this.handleMessage(evt.data);
            };
            _this.conn.onerror = function (evt) {
                _this.initPromise = null;
                reject({ message: 'Connection error' });
                console.log("Live: websocket error", evt);
            };
            _this.conn.onopen = function (evt) {
                console.log('opened');
                _this.initPromise = null;
                resolve(_this.conn);
            };
        });
        return this.initPromise;
    };
    LiveSrv.prototype.handleMessage = function (message) {
        message = JSON.parse(message);
        if (!message.stream) {
            console.log("Error: stream message without stream!", message);
            return;
        }
        var observer = this.observers[message.stream];
        if (!observer) {
            this.removeObserver(message.stream, null);
            return;
        }
        observer.next(message);
    };
    LiveSrv.prototype.reconnect = function () {
        var _this = this;
        // no need to reconnect if no one cares
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.keys(this.observers).length === 0) {
            return;
        }
        console.log('LiveSrv: Reconnecting');
        this.getConnection().then(function (conn) {
            __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(_this.observers, function (value, key) {
                _this.send({ action: 'subscribe', stream: key });
            });
        });
    };
    LiveSrv.prototype.send = function (data) {
        this.conn.send(JSON.stringify(data));
    };
    LiveSrv.prototype.addObserver = function (stream, observer) {
        var _this = this;
        this.observers[stream] = observer;
        this.getConnection().then(function (conn) {
            _this.send({ action: 'subscribe', stream: stream });
        });
    };
    LiveSrv.prototype.removeObserver = function (stream, observer) {
        var _this = this;
        console.log('unsubscribe', stream);
        delete this.observers[stream];
        this.getConnection().then(function (conn) {
            _this.send({ action: 'unsubscribe', stream: stream });
        });
    };
    LiveSrv.prototype.subscribe = function (streamName) {
        var _this = this;
        console.log('LiveSrv.subscribe: ' + streamName);
        return __WEBPACK_IMPORTED_MODULE_2_vendor_npm_rxjs_Observable__["Observable"].create(function (observer) {
            _this.addObserver(streamName, observer);
            return function () {
                _this.removeObserver(streamName, observer);
            };
        });
    };
    return LiveSrv;
}());

var instance = new LiveSrv();



/***/ }),

/***/ 715:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(158);
var observable_1 = __webpack_require__(716);
var toSubscriber_1 = __webpack_require__(717);
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    /**
     * Registers handlers for handling emitted values, error and completions from the observable, and
     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
     * @method subscribe
     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled
     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     */
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var target = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        var transformer = operator && operator.call(target) || target;
        if (transformer !== target) {
            target.add(transformer);
        }
        var subscription = this._subscribe(transformer);
        if (subscription !== target) {
            target.add(subscription);
        }
        if (target.syncErrorThrowable) {
            target.syncErrorThrowable = false;
            if (target.syncErrorThrown) {
                throw target.syncErrorValue;
            }
        }
        return target;
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                }
                else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` imple will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.$$observable] = function () {
        return this;
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
//# sourceMappingURL=Observable.js.map

/***/ }),

/***/ 716:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(158);
var Symbol = root_1.root.Symbol;
if (typeof Symbol === 'function') {
    if (Symbol.observable) {
        exports.$$observable = Symbol.observable;
    }
    else {
        if (typeof Symbol.for === 'function') {
            exports.$$observable = Symbol.for('observable');
        }
        else {
            exports.$$observable = Symbol('observable');
        }
        Symbol.observable = exports.$$observable;
    }
}
else {
    exports.$$observable = '@@observable';
}
//# sourceMappingURL=observable.js.map

/***/ }),

/***/ 717:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Subscriber_1 = __webpack_require__(718);
var rxSubscriber_1 = __webpack_require__(364);
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver === 'object') {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        else if (typeof nextOrObserver[rxSubscriber_1.$$rxSubscriber] === 'function') {
            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
        }
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;
//# sourceMappingURL=toSubscriber.js.map

/***/ }),

/***/ 718:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = __webpack_require__(362);
var Subscription_1 = __webpack_require__(719);
var rxSubscriber_1 = __webpack_require__(364);
var Observer_1 = __webpack_require__(723);
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.isUnsubscribed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parent, observerOrNext, error, complete) {
        _super.call(this);
        this._parent = _parent;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            context = observerOrNext;
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (isFunction_1.isFunction(context.unsubscribe)) {
                this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = this.unsubscribe.bind(this);
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parent = this._parent;
            if (!_parent.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parent, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parent = this._parent;
            if (this._error) {
                if (!_parent.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parent, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parent.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parent.syncErrorValue = err;
                _parent.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _parent = this._parent;
            if (this._complete) {
                if (!_parent.syncErrorThrowable) {
                    this.__tryOrUnsub(this._complete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parent, this._complete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parent = this._parent;
        this._context = null;
        this._parent = null;
        _parent.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
//# sourceMappingURL=Subscriber.js.map

/***/ }),

/***/ 719:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1 = __webpack_require__(720);
var isObject_1 = __webpack_require__(721);
var isFunction_1 = __webpack_require__(362);
var tryCatch_1 = __webpack_require__(722);
var errorObject_1 = __webpack_require__(363);
var Subscription = (function () {
    function Subscription(_unsubscribe) {
        this.isUnsubscribed = false;
        if (_unsubscribe) {
            this._unsubscribe = _unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.isUnsubscribed) {
            return;
        }
        this.isUnsubscribed = true;
        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this._subscriptions = null;
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                (errors = errors || []).push(errorObject_1.errorObject.e);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError) {
                            errors = errors.concat(err.errors);
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this subscription.
     *
     * If the tear down being added is a subscription that is already unsubscribed,
     * is the same reference `add` is being called on, or is `Subscription.EMPTY`,
     * it will not be added.
     *
     * If this subscription is already in an `isUnsubscribed` state, the passed tear down logic
     * will be executed immediately
     *
     * @param {TeardownLogic} teardown the additional logic to execute on teardown.
     * @returns {Subscription} returns the subscription used or created to be added to the inner
     *  subscriptions list. This subscription can be used with `remove()` to remove the passed teardown
     *  logic from the inner subscriptions list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {
            return;
        }
        var sub = teardown;
        switch (typeof teardown) {
            case 'function':
                sub = new Subscription(teardown);
            case 'object':
                if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {
                    break;
                }
                else if (this.isUnsubscribed) {
                    sub.unsubscribe();
                }
                else {
                    (this._subscriptions || (this._subscriptions = [])).push(sub);
                }
                break;
            default:
                throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        return sub;
    };
    /**
     * removes a subscription from the internal list of subscriptions that will unsubscribe
     * during unsubscribe process of this subscription.
     * @param {Subscription} subscription the subscription to remove
     */
    Subscription.prototype.remove = function (subscription) {
        // HACK: This might be redundant because of the logic in `add()`
        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
            return;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.isUnsubscribed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
var UnsubscriptionError = (function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this, 'unsubscriptoin error(s)');
        this.errors = errors;
        this.name = 'UnsubscriptionError';
    }
    return UnsubscriptionError;
}(Error));
exports.UnsubscriptionError = UnsubscriptionError;
//# sourceMappingURL=Subscription.js.map

/***/ }),

/***/ 720:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
//# sourceMappingURL=isArray.js.map

/***/ }),

/***/ 721:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;
//# sourceMappingURL=isObject.js.map

/***/ }),

/***/ 722:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var errorObject_1 = __webpack_require__(363);
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;
//# sourceMappingURL=tryCatch.js.map

/***/ }),

/***/ 723:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.empty = {
    isUnsubscribed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};
//# sourceMappingURL=Observer.js.map

/***/ }),

/***/ 724:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export LayoutSelectorCtrl */
/* unused harmony export layoutSelector */
/* unused harmony export layoutMode */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_store__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_store___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_app_core_store__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../../headers/common.d.ts" />


var template = "\n<div class=\"layout-selector\">\n  <button ng-click=\"ctrl.listView()\" ng-class=\"{active: ctrl.mode === 'list'}\">\n    <i class=\"fa fa-list\"></i>\n  </button>\n  <button ng-click=\"ctrl.gridView()\" ng-class=\"{active: ctrl.mode === 'grid'}\">\n    <i class=\"fa fa-th\"></i>\n  </button>\n</div>\n";
var LayoutSelectorCtrl = /** @class */ (function () {
    /** @ngInject **/
    function LayoutSelectorCtrl($rootScope) {
        this.$rootScope = $rootScope;
        this.mode = __WEBPACK_IMPORTED_MODULE_0_app_core_store___default.a.get('grafana.list.layout.mode') || 'grid';
    }
    LayoutSelectorCtrl.prototype.listView = function () {
        this.mode = 'list';
        __WEBPACK_IMPORTED_MODULE_0_app_core_store___default.a.set('grafana.list.layout.mode', 'list');
        this.$rootScope.appEvent('layout-mode-changed', 'list');
    };
    LayoutSelectorCtrl.prototype.gridView = function () {
        this.mode = 'grid';
        __WEBPACK_IMPORTED_MODULE_0_app_core_store___default.a.set('grafana.list.layout.mode', 'grid');
        this.$rootScope.appEvent('layout-mode-changed', 'grid');
    };
    return LayoutSelectorCtrl;
}());

/** @ngInject **/
function layoutSelector() {
    return {
        restrict: 'E',
        controller: LayoutSelectorCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        scope: {},
        template: template,
    };
}
/** @ngInject **/
function layoutMode($rootScope) {
    return {
        restrict: 'A',
        scope: {},
        link: function (scope, elem) {
            var layout = __WEBPACK_IMPORTED_MODULE_0_app_core_store___default.a.get('grafana.list.layout.mode') || 'grid';
            var className = 'card-list-layout-' + layout;
            elem.addClass(className);
            $rootScope.onAppEvent('layout-mode-changed', function (evt, newLayout) {
                elem.removeClass(className);
                className = 'card-list-layout-' + newLayout;
                elem.addClass(className);
            }, scope);
        }
    };
}
__WEBPACK_IMPORTED_MODULE_1_app_core_core_module__["default"].directive('layoutSelector', layoutSelector);
__WEBPACK_IMPORTED_MODULE_1_app_core_core_module__["default"].directive('layoutMode', layoutMode);


/***/ }),

/***/ 725:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export SwitchCtrl */
/* unused harmony export switchDirective */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />

var template = "\n<label for=\"check-{{ctrl.id}}\" class=\"gf-form-label {{ctrl.labelClass}} pointer\">\n  {{ctrl.label}}\n  <info-popover mode=\"right-normal\" ng-if=\"ctrl.tooltip\">\n    {{ctrl.tooltip}}\n  </info-popover>\n</label>\n<div class=\"gf-form-switch {{ctrl.switchClass}}\" ng-if=\"ctrl.show\">\n  <input id=\"check-{{ctrl.id}}\" type=\"checkbox\" ng-model=\"ctrl.checked\" ng-change=\"ctrl.internalOnChange()\">\n  <label for=\"check-{{ctrl.id}}\" data-on=\"Yes\" data-off=\"No\"></label>\n</div>\n";
var SwitchCtrl = /** @class */ (function () {
    /** @ngInject */
    function SwitchCtrl($scope, $timeout) {
        this.$timeout = $timeout;
        this.show = true;
        this.id = $scope.$id;
    }
    SwitchCtrl.prototype.internalOnChange = function () {
        var _this = this;
        return this.$timeout(function () {
            return _this.onChange();
        });
    };
    return SwitchCtrl;
}());

function switchDirective() {
    return {
        restrict: 'E',
        controller: SwitchCtrl,
        controllerAs: 'ctrl',
        bindToController: true,
        scope: {
            checked: "=",
            label: "@",
            labelClass: "@",
            tooltip: "@",
            switchClass: "@",
            onChange: "&",
        },
        template: template,
    };
}
__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].directive('gfFormSwitch', switchDirective);


/***/ }),

/***/ 726:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DashboardSelectorCtrl */
/* unused harmony export dashboardSelector */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />

var template = "\n<select class=\"gf-form-input\" ng-model=\"ctrl.model\" ng-options=\"f.value as f.text for f in ctrl.options\"></select>\n<info-popover mode=\"right-absolute\">\n  Not finding dashboard you want? Star it first, then it should appear in this select box.\n</info-popover>\n";
var DashboardSelectorCtrl = /** @class */ (function () {
    /** @ngInject */
    function DashboardSelectorCtrl(backendSrv) {
        this.backendSrv = backendSrv;
    }
    DashboardSelectorCtrl.prototype.$onInit = function () {
        var _this = this;
        this.options = [{ value: 0, text: 'Default' }];
        return this.backendSrv.search({ starred: true }).then(function (res) {
            res.forEach(function (dash) {
                _this.options.push({ value: dash.id, text: dash.title });
            });
        });
    };
    return DashboardSelectorCtrl;
}());

function dashboardSelector() {
    return {
        restrict: 'E',
        controller: DashboardSelectorCtrl,
        bindToController: true,
        controllerAs: 'ctrl',
        template: template,
        scope: {
            model: '='
        }
    };
}
__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].directive('dashboardSelector', dashboardSelector);


/***/ }),

/***/ 727:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(729),
  __webpack_require__(734),
  __webpack_require__(730),
  __webpack_require__(731),
  __webpack_require__(732),
  __webpack_require__(733),
  __webpack_require__(728),
  __webpack_require__(735),
  __webpack_require__(736),
  __webpack_require__(737),
  __webpack_require__(738)
], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 728:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, coreModule) {
  'use strict';

  coreModule.default.controller('ErrorCtrl', function($scope, contextSrv) {

    var showSideMenu = contextSrv.sidemenu;
    contextSrv.sidemenu = false;

    $scope.$on('$destroy', function() {
      $scope.contextSrv.sidemenu = showSideMenu;
    });

  });

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 729:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(3),
  __webpack_require__(16),
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, _, $, coreModule) {
  'use strict';

  coreModule.default.controller('InspectCtrl', function($scope) {
    var model = $scope.inspector;

    function getParametersFromQueryString(queryString) {
      var result = [];
      var parameters = queryString.split("&");
      for (var i = 0; i < parameters.length; i++) {
        var keyValue = parameters[i].split("=");
        if (keyValue[1].length > 0) {
          result.push({ key: keyValue[0], value: window.unescape(keyValue[1]) });
        }
      }
      return result;
    }

    $scope.init = function () {
      $scope.editor = { index: 0 };

      if (!model.error)  {
        return;
      }

      if (_.isString(model.error.data)) {
        $scope.response = $("<div>" + model.error.data + "</div>").text();
      } else if (model.error.data) {
        $scope.response = angular.toJson(model.error.data, true);
      } else if (model.error.message) {
        $scope.message = model.error.message;
      }

      if (model.error.config && model.error.config.params) {
        $scope.request_parameters = _.map(model.error.config.params, function(value, key) {
          return { key: key, value: value};
        });
      }

      if (model.error.stack) {
        $scope.editor.index = 2;
        $scope.stack_trace = model.error.stack;
        $scope.message = model.error.message;
      }

      if (model.error.config && model.error.config.data) {
        $scope.editor.index = 1;

        if (_.isString(model.error.config.data)) {
          $scope.request_parameters = getParametersFromQueryString(model.error.config.data);
        } else  {
          $scope.request_parameters = _.map(model.error.config.data, function(value, key) {
            return {key: key, value: angular.toJson(value, true)};
          });
        }
      }
    };

  });

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 730:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(2),
  __webpack_require__(24),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, coreModule, config) {
  'use strict';

  coreModule.default.controller('LoginCtrl', function($scope, backendSrv, contextSrv, $location) {
    $scope.formModel = {
      user: '',
      email: '',
      password: '',
    };

    contextSrv.sidemenu = false;

    $scope.googleAuthEnabled = config.googleAuthEnabled;
    $scope.githubAuthEnabled = config.githubAuthEnabled;
    $scope.oauthEnabled = config.githubAuthEnabled || config.googleAuthEnabled;
    $scope.disableUserSignUp = config.disableUserSignUp;
    $scope.loginHint     = config.loginHint;

    $scope.loginMode = true;
    $scope.submitBtnText = ' ';

    $scope.init = function() {
      $scope.$watch("loginMode", $scope.loginModeChanged);

      var params = $location.search();
      if (params.failedMsg) {
        $scope.appEvent('alert-warning', [' ', params.failedMsg]);
        delete params.failedMsg;
        $location.search(params);
      }
    };

    // build info view model
    $scope.buildInfo = {
      version: config.buildInfo.version,
      commit: config.buildInfo.commit,
      buildstamp: new Date(config.buildInfo.buildstamp * 1000),
      latestVersion: config.buildInfo.latestVersion,
      hasUpdate: config.buildInfo.hasUpdate,
    };

    $scope.submit = function() {
      $scope.login();
    };

    $scope.loginModeChanged = function(newValue) {
      $scope.submitBtnText = newValue ? ' ' : ' ';
    };

    $scope.signUp = function() {
      if (!$scope.loginForm.$valid) {
        return;
      }

      backendSrv.post('/api/user/signup', $scope.formModel).then(function(result) {
        if (result.status === 'SignUpCreated') {
          $location.path('/signup').search({email: $scope.formModel.email});
        } else {
          window.location.href = config.appSubUrl + '/';
        }
      });
    };

    $scope.login = function() {
      delete $scope.loginError;

      if (!$scope.loginForm.$valid) {
        return;
      }

      backendSrv.post('/login', $scope.formModel).then(function(result) {
        if (result.redirectUrl) {
          window.location.href = result.redirectUrl;
        } else {
          window.location.href = config.appSubUrl + '/systems';
        }
      });
    };

    $scope.contactUs = function() {
      $scope.appEvent('confirm-modal', {
        title: '',
        text: '17070866703 <br/> service@cloudwiz.cn',
        icon: 'fa-bell',
        yesText: '',
        noText: '',
        modalClass : 'contact-us',
      });
    };

    $scope.init();
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 731:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(2),
  __webpack_require__(24),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, coreModule, config) {
  'use strict';

  coreModule.default.controller('InvitedCtrl', function($scope, $routeParams, contextSrv, backendSrv) {
    contextSrv.sidemenu = false;
    $scope.formModel = {};

    $scope.init = function() {
      backendSrv.get('/api/user/invite/' + $routeParams.code).then(function(invite) {
        $scope.formModel.name = invite.name;
        $scope.formModel.email = invite.email;
        $scope.formModel.username = invite.email;
        $scope.formModel.inviteCode =  $routeParams.code;

        $scope.greeting = invite.name || invite.email || invite.username;
        $scope.invitedBy = invite.invitedBy;
      });
    };

    $scope.submit = function() {
      if (!$scope.inviteForm.$valid) {
        return;
      }

      backendSrv.post('/api/user/invite/complete', $scope.formModel).then(function() {
        window.location.href = config.appSubUrl + '/';
      });
    };

    $scope.init();

  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 732:
/***/ (function(module, exports) {

throw new Error("Module build failed: Error: Final loader didn't return a Buffer or String\n    at runLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/webpack/lib/NormalModule.js:204:46)\n    at /Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:370:3\n    at iterateNormalLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:211:10)\n    at iterateNormalLoaders (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:218:10)\n    at /Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:233:3\n    at context.callback (/Users/yuyu/webapp/cloudwiz/src/github.com/wangy1931/grafana/node_modules/loader-runner/lib/LoaderRunner.js:111:13)\n    at process._tickCallback (internal/process/next_tick.js:103:7)");

/***/ }),

/***/ 733:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, coreModule) {
  'use strict';

  coreModule.default.controller('ResetPasswordCtrl', function($scope, contextSrv, backendSrv, $location) {
    contextSrv.sidemenu = false;
    $scope.formModel = {};
    $scope.mode = 'send';

    var params = $location.search();
    if (params.code) {
      $scope.mode = 'reset';
      $scope.formModel.code = params.code;
    }

    $scope.sendResetEmail = function() {
      if (!$scope.sendResetForm.$valid) {
        return;
      }
      backendSrv.post('/api/user/password/send-reset-email', $scope.formModel).then(function() {
        $scope.mode = 'email-sent';
      });
    };

    $scope.submitReset = function() {
      if (!$scope.resetForm.$valid) { return; }

      if ($scope.formModel.newPassword !== $scope.formModel.confirmPassword) {
        $scope.appEvent('alert-warning', [',', '']);
        return;
      }

      backendSrv.post('/api/user/password/reset', $scope.formModel).then(function() {
        $location.path('login');
      });
    };

  });

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 734:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, coreModule) {
  'use strict';

  coreModule.default.controller('JsonEditorCtrl', function($scope) {

    $scope.json = angular.toJson($scope.object, true);
    $scope.canUpdate = $scope.updateHandler !== void 0 && $scope.contextSrv.isEditor;

    $scope.update = function () {
      var newObject = angular.fromJson($scope.json);
      $scope.updateHandler(newObject, $scope.object);
    };

  });

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 735:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
    __webpack_require__(7),
    __webpack_require__(3),
    __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, _,coreModule) {
    'use strict';

    coreModule.default.controller('InstallCtrl', function ($scope, backendSrv, datasourceSrv, contextSrv) {
      $scope.installSelect = {
        system: 0,
        service: ""
      };
      //would be hard code for a while
      $scope.services = ["Hadoop", "zookeeper", "JMX", "Mysql"];
      $scope.platform = ["Window", "Linux"];
      $scope.orgId = contextSrv.user.orgId;
      $scope.alertServer = backendSrv.alertDUrl;
      datasourceSrv.get("opentsdb").then(function (ds) {
        var url = document.createElement('a');
        url.href = ds.url;
        $scope.metricsServer = url.hostname;
      });
      $scope.changeToken = function () {
        _.each(backendSrv.tokens, function (token) {
          if (token.name === $scope.installSelect.system) {
            $scope.token = token.key;
          }
        });
      };
    });

  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 736:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SignupFreeCtrl", function() { return SignupFreeCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_config__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_app_core_config__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_module__ = __webpack_require__(2);



var SignupFreeCtrl = /** @class */ (function () {
    /** @ngInject */
    function SignupFreeCtrl($scope, $location, backendSrv, contextSrv) {
        $scope.formModel = {
            email: "",
            name: "",
            orgName: "",
            phone: "",
            scale: ""
        };
        contextSrv.sidemenu = false;
        $scope.submit = function () {
            if (!$scope.signUpFrom.$valid) {
                return;
            }
            if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.excludeEmail($scope.formModel.email)) {
                $scope.appEvent('alert-warning', ['']);
                return;
            }
            contextSrv.signupUser.orgName = $scope.formModel.orgName;
            contextSrv.signupUser.name = $scope.formModel.name;
            backendSrv.post('/api/user/signup', $scope.formModel).then(function (result) {
                if (result.status === 'SignUpCreated') {
                    $location.path('/signup').search({ email: $scope.formModel.email });
                }
                else {
                    window.location.href = __WEBPACK_IMPORTED_MODULE_1_app_core_config___default.a.appSubUrl + '/';
                }
            });
            backendSrv.post('/api/user/signup/propose', $scope.formModel).then(function () { });
        };
    }
    return SignupFreeCtrl;
}());

__WEBPACK_IMPORTED_MODULE_2__core_module__["default"].controller('SignupFreeCtrl', SignupFreeCtrl);


/***/ }),

/***/ 737:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
    __webpack_require__(7),
    __webpack_require__(2),
    __webpack_require__(3),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, coreModule, _) {
    'use strict';

    coreModule.default.controller('SystemCtrl', function ($scope, backendSrv, $location, contextSrv) {

      $scope.dashboardSetting = {title: "new dashboard", system: contextSrv.user.systemId};
      $scope.init = function () {
        $scope.getCurrentUserSystem();
      };

      $scope.getCurrentUserSystem = function () {
        backendSrv.get("/api/user/system").then(function (system) {
          $scope.system = _.find(system, {Id: contextSrv.user.systemId});
        });
      };

      $scope.addSystem = function () {
        if (!$scope.systemForm.$valid) {
          return;
        }
        $scope.dismiss();
        $location.url('dashboard/new?system=' + $scope.dashboardSetting.system + "&title=" + $scope.dashboardSetting.title);
      };

      $scope.init_system_choice = function () {
        backendSrv.get("/api/user/system").then(function (system) {
          $scope.systems = system;
        });
      };

      $scope.newSystem = function() {
        $location.url('/org');
      };
    });
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 738:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GuideUseCtrl", function() { return GuideUseCtrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />


var GuideUseCtrl = /** @class */ (function () {
    /** @ngInject */
    function GuideUseCtrl($scope, $rootScope, $location, $sce) {
        this.$sce = $sce;
        var path = $location.path();
        path = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.replace(path, /\//g, '_');
        path = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.guideMap()[path] || 'ui_summary';
        this.guidePath = $sce.trustAsResourceUrl("https://cloudwiz.cn/document/part4/" + path + ".html");
    }
    return GuideUseCtrl;
}());

__WEBPACK_IMPORTED_MODULE_1__core_module__["default"].controller('GuideUseCtrl', GuideUseCtrl);


/***/ }),

/***/ 739:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(741),
  __webpack_require__(752),
  __webpack_require__(742),
  __webpack_require__(744),
  __webpack_require__(745),
  __webpack_require__(746),
  __webpack_require__(747),
  __webpack_require__(748),
  __webpack_require__(749),
  __webpack_require__(750),
  __webpack_require__(751),
  __webpack_require__(740),
  __webpack_require__(753),
  __webpack_require__(754),
  __webpack_require__(755),
  __webpack_require__(756),
  __webpack_require__(757),
  __webpack_require__(758),
  __webpack_require__(759),
  __webpack_require__(760),
  __webpack_require__(761),
  __webpack_require__(762)
], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 740:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
    __webpack_require__(7),
    __webpack_require__(3),
    __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, _, coreModule) {
  'use strict';
  coreModule.default.service('alertMgrSrv', function(alertSrv, backendSrv) {
    this.alertDefMap = {};
    var self = this;
    var alertDefUrl = "/alert/definition";
    var alertStatusUrl = "/alert/status";
    var alertAssociationUrl = "/alert/correlation";
    var alertHistoryUrl = "/alert/history";
    var closeAlertUrl = "/alert/status/close";
    var checkNameUrl = "/alert/definition/check";
    var rcaFeedbackUrl = "/rca/feedback/json";
    var associationPeriodsUrl = "/alert/correlation/periods";

    this.currentCritialThreshold = 0;
    this.currentWarningThreshold = 0;

    this.load = function() {
      return backendSrv.alertD({
        method: "get",
        url: alertDefUrl,
      }).then(function onSuccess(response) {
        for (var i = 0; i < response.data.length; i++) {
          var theAlertDef = response.data[i];
          self.alertDefMap[theAlertDef.id] = theAlertDef;
        }
        return response;
      }, function onFailed(response) {
        alertSrv.set("error", response.status + " " + (response.data || "Request failed"), response.severity, 5000);
        return response;
      });
    };

    this.save = function(alertDef) {
      return backendSrv.alertD({
        method: "post",
        url: alertDefUrl,
        data: angular.toJson(alertDef),
        headers: {'Content-Type': 'text/plain;application/json;charset=UTF-8'},
      });
    };

    this.remove = function(alertId) {
      return backendSrv.alertD({
        method: "delete",
        url: alertDefUrl,
        params: {id: alertId},
        headers: {'Content-Type': 'text/plain'},
      });
    };

    this.get = function(id) {
      return self.alertDefMap[id];
    };

    this.loadTriggeredAlerts = function(options) {
      var params = {};
      _.extend(params, options);
      return backendSrv.alertD({
        method: "get",
        url: alertStatusUrl,
        params: params
      });
    };

    this.loadAssociatedMetrics = function(params) {
      return backendSrv.alertD({
        method: "get",
        url: alertAssociationUrl,
        params: params
      });
    };

    this.resetCorrelation = function(alertMetric, alertHost, backtrackSteps, advancedSteps) {
      return backendSrv.alertD({
        method: "post",
        url: alertAssociationUrl,
        params: {
          metric: alertMetric,
          host: alertHost,
          backtrackSteps: backtrackSteps,
          advancedSteps: advancedSteps,
          reset: true
        },
        headers: {'Content-Type': 'text/plain'},
      });
    };

    this.loadAssociatedPeriods = function(params) {
      return backendSrv.alertD({
        method: "get",
        url: associationPeriodsUrl,
        params: params
      });
    };

    this.resetCurrentThreshold = function (threshold) {
      self.currentWarningThreshold = threshold.warn;
      self.currentCritialThreshold = threshold.crit;
    };

    this.loadAlertHistory = function(fromTime, host) {
      var params = { from: fromTime };
      host && (params['host'] = host);

      return backendSrv.alertD({
        method: "get",
        url: alertHistoryUrl,
        params: params
      });
    };

    this.closeAlert = function(alertId, host, alertReason, userName) {
      return backendSrv.alertD({
        method: "post",
        url: closeAlertUrl,
        params: {
          id: alertId,
          host: host,
        },
        data:{
          reason: alertReason,
          closeBy: userName
        },
        headers: {'Content-Type': 'text/plain;application/json;charset=UTF-8'},
      });
    };

    this.rcaFeedback = function(rcaFeedback) {
      return backendSrv.alertD({
        method: "post",
        url: rcaFeedbackUrl,
        data:rcaFeedback,
        headers: {'Content-Type': 'text/plain;application/json;charset=UTF-8'},
      });
    };

    this.checkName = function(ruleName) {
      return backendSrv.alertD({
        method: 'get',
        url: checkNameUrl,
        params: {
          name: ruleName,
        }
      });
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 741:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlertSrv", function() { return AlertSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_app_events__ = __webpack_require__(367);
///<reference path="../../headers/common.d.ts" />




var AlertSrv = /** @class */ (function () {
    /** @ngInject */
    function AlertSrv($timeout, $sce, $rootScope, $_modal) {
        this.$timeout = $timeout;
        this.$sce = $sce;
        this.$rootScope = $rootScope;
        this.$_modal = $_modal;
        this.list = [];
    }
    AlertSrv.prototype.init = function () {
        var _this = this;
        this.$rootScope.onAppEvent('alert-error', function (e, alert) {
            _this.set(alert[0], alert[1], 'error', 0);
        }, this.$rootScope);
        this.$rootScope.onAppEvent('alert-warning', function (e, alert) {
            _this.set(alert[0], alert[1], 'warning', 5000);
        }, this.$rootScope);
        this.$rootScope.onAppEvent('alert-success', function (e, alert) {
            _this.set(alert[0], alert[1], 'success', 3000);
        }, this.$rootScope);
        __WEBPACK_IMPORTED_MODULE_3_app_core_app_events__["a" /* default */].on('confirm-modal', this.showConfirmModal.bind(this));
        this.$rootScope.onAppEvent('confirm-modal', function (e, data) {
            _this.showConfirmModal(data);
        }, this.$rootScope);
    };
    AlertSrv.prototype.set = function (title, text, severity, timeout) {
        var _this = this;
        var newAlert = {
            title: title || '',
            text: text || '',
            severity: severity || 'info',
        };
        var newAlertJson = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.toJson(newAlert);
        // remove same alert if it already exists
        __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.remove(this.list, function (value) {
            return __WEBPACK_IMPORTED_MODULE_0_angular___default.a.toJson(value) === newAlertJson;
        });
        this.list.push(newAlert);
        if (timeout > 0) {
            this.$timeout(function () {
                _this.list = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.without(_this.list, newAlert);
            }, timeout);
        }
        if (!this.$rootScope.$$phase) {
            this.$rootScope.$digest();
        }
        return (newAlert);
    };
    AlertSrv.prototype.clear = function (alert) {
        this.list = __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.without(this.list, alert);
    };
    AlertSrv.prototype.clearAll = function () {
        this.list = [];
    };
    AlertSrv.prototype.showConfirmModal = function (payload) {
        var scope = this.$rootScope.$new();
        scope.title = payload.title;
        scope.text = payload.text;
        scope.text2 = payload.text2;
        scope.onConfirm = payload.onConfirm;
        scope.icon = payload.icon || "fa-check";
        scope.yesText = payload.yesText || "Yes";
        scope.noText = payload.noText || "Cancel";
        var confirmModal = this.$_modal({
            template: 'public/app/partials/confirm_modal.html',
            persist: false,
            modalClass: 'confirm-modal',
            show: false,
            scope: scope,
            keyboard: false
        });
        confirmModal.then(function (modalEl) {
            modalEl.modal('show');
        });
    };
    return AlertSrv;
}());

__WEBPACK_IMPORTED_MODULE_2_app_core_core_module__["default"].service('alertSrv', AlertSrv);


/***/ }),

/***/ 742:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(3),
  __webpack_require__(2),
  __webpack_require__(24),
  __webpack_require__(128),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, _, coreModule, config, dateMath) {
  'use strict';

  coreModule.default.service('datasourceSrv', function($q, $injector, $rootScope, templateSrv) {
    var self = this;

    this.init = function() {
      this.datasources = {};
    };

    this.get = function(name) {
      if (!name) {
        return this.get(config.defaultDatasource);
      }

      name = templateSrv.replace(name);

      if (this.datasources[name]) {
        return $q.when(this.datasources[name]);
      }

      return this.loadDatasource(name);
    };

    this.loadDatasource = function(name) {
      var dsConfig = config.datasources[name];
      if (!dsConfig) {
        return $q.reject({message: "Datasource named " + name + " was not found"});
      }

      var deferred = $q.defer();
      var pluginDef = dsConfig.meta;

      __webpack_require__(743)(pluginDef.module).then(function(plugin) {
        // check if its in cache now
        if (self.datasources[name]) {
          deferred.resolve(self.datasources[name]);
          return;
        }

        // plugin module needs to export a constructor function named Datasource
        if (!plugin.Datasource) {
          throw "Plugin module is missing Datasource constructor";
        }

        var instance = $injector.instantiate(plugin.Datasource, {instanceSettings: dsConfig});
        instance.meta = pluginDef;
        instance.name = name;
        self.datasources[name] = instance;
        deferred.resolve(instance);
      }).catch(function(err) {
        $rootScope.appEvent('alert-error', [dsConfig.name + ' plugin failed', err.toString()]);
      });

      return deferred.promise;
    };

    this.getAll = function() {
      return config.datasources;
    };

    this.getAnnotationSources = function() {
      return _.reduce(config.datasources, function(memo, value) {

        if (value.meta && value.meta.annotations) {
          memo.push(value);
        }

        return memo;
      }, []);
    };

    this.getMetricSources = function(options) {
      var metricSources = [];

      _.each(config.datasources, function(value, key) {
        if (value.meta && value.meta.metrics) {
          metricSources.push({
            value: key === config.defaultDatasource ? null : key,
            name: key,
            meta: value.meta,
          });
        }
      });

      if (!options || !options.skipVariables) {
        // look for data source variables
        for (var i = 0; i < templateSrv.variables.length; i++) {
          var variable = templateSrv.variables[i];
          if (variable.type !== 'datasource') {
            continue;
          }

          var first = variable.current.value;
          var ds = config.datasources[first];

          if (ds) {
            metricSources.push({
              name: '$' + variable.name,
              value: '$' + variable.name,
              meta: ds.meta,
            });
          }
        }
      }

      metricSources.sort(function(a, b) {
        if (a.meta.builtIn || a.name > b.name) {
          return 1;
        }
        if (a.name < b.name) {
          return -1;
        }
        return 0;
      });

      return metricSources;
    };

    this.getStatus = function(query, startTime, endTime) {
      var end = endTime ? dateMath.parse(endTime, false).valueOf() : null;
      return this.get('opentsdb').then(function(datasource) {
        return datasource.performTimeSeriesQuery(query, dateMath.parse(startTime, false).valueOf(), end).then(function(response) {
          if (_.isEmpty(response.data)) {
            throw Error;
          }
          return response.data;
        });
      });
    };

    this.getHostStatus = function(query, startTime, endTime) {
      return this.getStatus(query, startTime, endTime).then(function (response) {
        var service = _.getMetricName(query[0].metric);
        var status = null;
        var host = null;
        _.each(response, function (metricData) {
          host = metricData.tags.host;
          if (_.isObject(metricData)) {
            status = metricData.dps[Object.keys(metricData.dps)[0]];
            if(typeof(status) !== "number") {
              throw Error;
            }
          }
        });
        return {name: service, status: status, host: host};
      });
    };

    this.getHostResource = function (query, startTime, endTime) {
      return this.getStatus(query, startTime, endTime).then(function (response) {
        var service = _.getMetricName(query[0].metric);
        var value = null;
        var host = null;
        var time = null;
        var result = [];
        _.each(response, function (metricData) {
          host = metricData.tags.host;
          if (_.isObject(metricData)) {
            time = _.last(Object.keys(metricData.dps));
            value = metricData.dps[time];
            // if (typeof(value) !== "number") { throw Error; }
          }
          result.push({ name: service, value: value, host: host, time: time, tags: metricData.tags });
        });
        return result;
      });
    };

    this.init();
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 743:
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() {
		throw new Error("Cannot find module '" + req + "'.");
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 743;

/***/ }),

/***/ 744:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "User", function() { return User; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SignupUser", function() { return SignupUser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContextSrv", function() { return ContextSrv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "contextSrv", function() { return contextSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_config__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_app_core_config__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_store__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_store___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_app_core_store__);
///<reference path="../../headers/common.d.ts" />




var User = /** @class */ (function () {
    function User() {
        if (__WEBPACK_IMPORTED_MODULE_0_app_core_config___default.a.bootData.user) {
            __WEBPACK_IMPORTED_MODULE_1_lodash___default.a.extend(this, __WEBPACK_IMPORTED_MODULE_0_app_core_config___default.a.bootData.user);
        }
    }
    return User;
}());

var SignupUser = /** @class */ (function () {
    function SignupUser() {
    }
    return SignupUser;
}());

var ContextSrv = /** @class */ (function () {
    function ContextSrv() {
        this.pinned = __WEBPACK_IMPORTED_MODULE_3_app_core_store___default.a.getBool('grafana.sidemenu.pinned', false);
        this.sidemenu = this.pinned ? true : false;
        if (!__WEBPACK_IMPORTED_MODULE_0_app_core_config___default.a.buildInfo) {
            __WEBPACK_IMPORTED_MODULE_0_app_core_config___default.a.buildInfo = {};
        }
        if (!__WEBPACK_IMPORTED_MODULE_0_app_core_config___default.a.bootData) {
            __WEBPACK_IMPORTED_MODULE_0_app_core_config___default.a.bootData = { user: {}, settings: {} };
        }
        this.version = __WEBPACK_IMPORTED_MODULE_0_app_core_config___default.a.buildInfo.version;
        this.user = new User();
        this.isSignedIn = this.user.isSignedIn;
        this.isGrafanaAdmin = this.user.isGrafanaAdmin;
        this.isEditor = this.hasRole('Editor') || this.hasRole('Admin');
        this.isOrgAdmin = this.hasRole('Admin');
        this.dashboardLink = "";
        this.systemsMap = __WEBPACK_IMPORTED_MODULE_0_app_core_config___default.a.bootData.systems;
        this.hostNum = 0;
        this.isViewer = this.hasRole('Viewer');
        this.signupUser = new SignupUser();
    }
    ContextSrv.prototype.hasRole = function (role) {
        return this.user.orgRole === role;
    };
    ContextSrv.prototype.setPinnedState = function (val) {
        this.pinned = val;
        __WEBPACK_IMPORTED_MODULE_3_app_core_store___default.a.set('grafana.sidemenu.pinned', val);
    };
    ContextSrv.prototype.toggleSideMenu = function ($event) {
        $event && $event.preventDefault();
        this.sidemenu = !this.sidemenu;
        this.setPinnedState(true);
    };
    return ContextSrv;
}());

var contextSrv = new ContextSrv();

__WEBPACK_IMPORTED_MODULE_2_app_core_core_module__["default"].factory('contextSrv', function () {
    return contextSrv;
});


/***/ }),

/***/ 745:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(3),
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, _, coreModule) {
  'use strict';

  coreModule.default.service('timer', function($timeout) {
    // This service really just tracks a list of $timeout promises to give us a
    // method for cancelling them all when we need to

    var timers = [];

    this.register = function(promise) {
      timers.push(promise);
      return promise;
    };

    this.cancel = function(promise) {
      timers = _.without(timers,promise);
      $timeout.cancel(promise);
    };

    this.cancel_all = function() {
      _.each(timers, function(t) {
        $timeout.cancel(t);
      });
      timers = [];
    };
  });

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 746:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(3),
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, _, coreModule) {
  'use strict';

  // This service was based on OpenJS library available in BSD License
  // http://www.openjs.com/scripts/events/keyboard_shortcuts/index.php
  coreModule.default.factory('keyboardManager', ['$window', '$timeout', function ($window, $timeout) {
    var keyboardManagerService = {};

    var defaultOpt = {
      'type':             'keydown',
      'propagate':        false,
      'inputDisabled':    false,
      'target':           $window.document,
      'keyCode':          false
    };
    // Store all keyboard combination shortcuts
    keyboardManagerService.keyboardEvent = {};
    // Add a new keyboard combination shortcut
    keyboardManagerService.bind = function (label, callback, opt) {
      var fct, elt, code, k;
      // Initialize opt object
      opt   = angular.extend({}, defaultOpt, opt);
      label = label.toLowerCase();
      elt   = opt.target;

      if (typeof opt.target === 'string') {
        elt = document.getElementById(opt.target);
      }

      fct = function (e) {
        e = e || $window.event;

        // Disable event handler when focus input and textarea
        if (opt['inputDisabled']) {
          var elt;
          if (e.target) {
            elt = e.target;
          }
          else if (e.srcElement) {
            elt = e.srcElement;
          }

          if (elt.nodeType === 3) {
            elt = elt.parentNode;
          }

          if (elt.tagName === 'INPUT' || elt.tagName === 'TEXTAREA') {
            return;
          }
        }

        // Find out which key is pressed
        if (e.keyCode) {
          code = e.keyCode;
        }
        else if (e.which) {
          code = e.which;
        }

        var character = String.fromCharCode(code).toLowerCase();

        if (code === 188) {
          character = ","; // If the user presses , when the type is onkeydown
        }
        if (code === 190) {
          character = "."; // If the user presses , when the type is onkeydown
        }

        var keys = label.split("+");
        // Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
        var kp = 0;
        // Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
        var shift_nums = {
          "`": "~",
          "1": "!",
          "2": "@",
          "3": "#",
          "4": "$",
          "5": "%",
          "6": "^",
          "7": "&",
          "8": "*",
          "9": "(",
          "0": ")",
          "-": "_",
          "=": "+",
          ";": ":",
          "'": "\"",
          ",": "<",
          ".": ">",
          "/": "?",
          "": "?",
          "": "?",
          "": "?",
          "\\": "|"
        };
        // Special Keys - and their codes
        var special_keys = {
          'esc': 27,
          'escape': 27,
          'tab': 9,
          'space': 32,
          'return': 13,
          'enter': 13,
          'backspace': 8,

          'scrolllock': 145,
          'scroll_lock': 145,
          'scroll': 145,
          'capslock': 20,
          'caps_lock': 20,
          'caps': 20,
          'numlock': 144,
          'num_lock': 144,
          'num': 144,

          'pause': 19,
          'break': 19,

          'insert': 45,
          'home': 36,
          'delete': 46,
          'end': 35,

          'pageup': 33,
          'page_up': 33,
          'pu': 33,

          'pagedown': 34,
          'page_down': 34,
          'pd': 34,

          'left': 37,
          'up': 38,
          'right': 39,
          'down': 40,

          'f1': 112,
          'f2': 113,
          'f3': 114,
          'f4': 115,
          'f5': 116,
          'f6': 117,
          'f7': 118,
          'f8': 119,
          'f9': 120,
          'f10': 121,
          'f11': 122,
          'f12': 123
        };
        // Some modifiers key
        var modifiers = {
          shift: {
            wanted:   false,
            pressed:  e.shiftKey ? true : false
          },
          ctrl : {
            wanted:   false,
            pressed:  e.ctrlKey ? true : false
          },
          alt  : {
            wanted:   false,
            pressed:  e.altKey ? true : false
          },
          meta : { //Meta is Mac specific
            wanted:   false,
            pressed:  e.metaKey ? true : false
          }
        };
        // Foreach keys in label (split on +)
        for (var i = 0, l = keys.length; k = keys[i], i < l; i++) {
          switch (k) {
          case 'ctrl':
          case 'control':
            kp++;
            modifiers.ctrl.wanted = true;
            break;
          case 'shift':
          case 'alt':
          case 'meta':
            kp++;
            modifiers[k].wanted = true;
            break;
          }

          if (k.length > 1) { // If it is a special key
            if (special_keys[k] === code) {
              kp++;
            }
          } else if (opt['keyCode']) { // If a specific key is set into the config
            if (opt['keyCode'] === code) {
              kp++;
            }
          } else { // The special keys did not match
            if (character === k) {
              kp++;
            }
            else {
              if (shift_nums[character] && e.shiftKey) { // Stupid Shift key bug created by using lowercase
                character = shift_nums[character];
                if (character === k) {
                  kp++;
                }
              }
            }
          }
        }

        if (kp === keys.length &&
          modifiers.ctrl.pressed === modifiers.ctrl.wanted &&
          modifiers.shift.pressed === modifiers.shift.wanted &&
          modifiers.alt.pressed === modifiers.alt.wanted &&
          modifiers.meta.pressed === modifiers.meta.wanted) {
          $timeout(function() {
            callback(e);
          }, 1);

          if (!opt['propagate']) { // Stop the event
            // e.cancelBubble is supported by IE - this will kill the bubbling process.
            e.cancelBubble = true;
            e.returnValue = false;

            // e.stopPropagation works in Firefox.
            if (e.stopPropagation) {
              e.stopPropagation();
              e.preventDefault();
            }
            return false;
          }
        }

      };
      // Store shortcut
      keyboardManagerService.keyboardEvent[label] = {
        'callback': fct,
        'target':   elt,
        'event':    opt['type']
      };
      //Attach the function with the event
      if (elt.addEventListener) {
        elt.addEventListener(opt['type'], fct, false);
      }
      else if (elt.attachEvent) {
        elt.attachEvent('on' + opt['type'], fct);
      }
      else {
        elt['on' + opt['type']] = fct;
      }
    };

    keyboardManagerService.unbindAll = function() {
      _.each(keyboardManagerService.keyboardEvent, function(value, key) {
        keyboardManagerService.unbind(key);
      });
    };

    // Remove the shortcut - just specify the shortcut and I will remove the binding
    keyboardManagerService.unbind = function (label) {
      label = label.toLowerCase();

      var binding = keyboardManagerService.keyboardEvent[label];
      delete(keyboardManagerService.keyboardEvent[label]);

      if (!binding) {
        return;
      }

      var type    = binding['event'],
      elt     = binding['target'],
      callback  = binding['callback'];

      if (elt.detachEvent) {
        elt.detachEvent('on' + type, callback);
      }
      else if (elt.removeEventListener) {
        elt.removeEventListener(type, callback, false);
      }
      else {
        elt['on' + type] = false;
      }
    };
    //
    return keyboardManagerService;
  }]);

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 747:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(angular, coreModule) {
  'use strict';

  coreModule.default.service('googleAnalyticsSrv', function($rootScope, $location) {
    var first = true;

    this.init = function() {
      $rootScope.$on('$viewContentLoaded', function() {
        // skip first
        if (first) {
          first = false;
          return;
        }
        window.ga('send', 'pageview', { page: $location.url() });
      });
    };

  }).run(function(googleAnalyticsSrv) {
    if (window.ga) {
      googleAnalyticsSrv.init();
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 748:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_tether_drop__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_tether_drop___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_tether_drop__);
///<reference path="../../headers/common.d.ts" />



/** @ngInject **/
function popoverSrv($compile, $rootScope) {
    this.show = function (options) {
        var popoverScope = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.extend($rootScope.$new(true), options.model);
        var drop;
        function destroyDrop() {
            setTimeout(function () {
                if (drop.tether) {
                    drop.destroy();
                }
            });
        }
        popoverScope.dismiss = function () {
            popoverScope.$destroy();
            destroyDrop();
        };
        var contentElement = document.createElement('div');
        contentElement.innerHTML = options.template;
        $compile(contentElement)(popoverScope);
        drop = new __WEBPACK_IMPORTED_MODULE_2_tether_drop___default.a({
            target: options.element,
            content: contentElement,
            position: options.position,
            classes: options.classes + ' drop-popover',
            openOn: options.openOn || 'hover',
            hoverCloseDelay: 200,
            tetherOptions: {
                constraints: [{ to: 'window', pin: true, attachment: "both" }]
            }
        });
        drop.on('close', function () {
            popoverScope.dismiss({ fromDropClose: true });
            destroyDrop();
            if (options.onClose) {
                options.onClose();
            }
        });
        setTimeout(function () { drop.open(); }, 10);
    };
}
__WEBPACK_IMPORTED_MODULE_1_app_core_core_module__["default"].service('popoverSrv', popoverSrv);


/***/ }),

/***/ 749:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(3),
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, _, coreModule) {
  'use strict';

  coreModule.default.service('uiSegmentSrv', function($sce, templateSrv) {
    var self = this;

    function MetricSegment(options) {
      if (options === '*' || options.value === '*') {
        this.value = '*';
        this.html = $sce.trustAsHtml('<i class="fa fa-asterisk"><i>');
        this.expandable = true;
        return;
      }

      if (_.isString(options)) {
        this.value = options;
        this.html = $sce.trustAsHtml(templateSrv.highlightVariablesAsHtml(this.value));
        return;
      }

      this.cssClass = options.cssClass;
      this.custom = options.custom;
      this.type = options.type;
      this.fake = options.fake;
      this.value = options.value;
      this.type = options.type;
      this.expandable = options.expandable;
      this.html = options.html || $sce.trustAsHtml(templateSrv.highlightVariablesAsHtml(this.value));
    }

    this.getSegmentForValue = function(value, fallbackText) {
      if (value) {
        return this.newSegment(value);
      } else {
        return this.newSegment({value: fallbackText, fake: true});
      }
    };

    this.newSelectMeasurement = function() {
      return new MetricSegment({value: 'select measurement', fake: true});
    };

    this.newFake = function(text, type, cssClass) {
      return new MetricSegment({value: text, fake: true, type: type, cssClass: cssClass});
    };

    this.newSegment = function(options) {
      return new MetricSegment(options);
    };

    this.newKey = function(key) {
      return new MetricSegment({value: key, type: 'key', cssClass: 'query-segment-key' });
    };

    this.newKeyValue = function(value) {
      return new MetricSegment({value: value, type: 'value', cssClass: 'query-segment-value' });
    };

    this.newCondition = function(condition) {
      return new MetricSegment({value: condition, type: 'condition', cssClass: 'query-keyword' });
    };

    this.newOperator = function(op) {
      return new MetricSegment({value: op, type: 'operator', cssClass: 'query-segment-operator' });
    };

    this.newOperators = function(ops) {
      return _.map(ops, function(op) {
        return new MetricSegment({value: op, type: 'operator', cssClass: 'query-segment-operator' });
      });
    };

    this.transformToSegments = function(addTemplateVars, variableTypeFilter) {
      return function(results) {
        var segments = _.map(results, function(segment) {
          return self.newSegment({ value: segment.text, expandable: segment.expandable });
        });

        if (addTemplateVars) {
          _.each(templateSrv.variables, function(variable) {
            if (variableTypeFilter === void 0 || variableTypeFilter === variable.type) {
              segments.unshift(self.newSegment({ type: 'template', value: '$' + variable.name, expandable: true }));
            }
          });
        }

        return segments;
      };
    };

    this.newSelectMetric = function() {
      return new MetricSegment({value: 'select metric', fake: true});
    };

    this.newPlusButton = function() {
      return new MetricSegment({fake: true, html: '<i class="fa fa-plus "></i>', type: 'plus-button' });
    };

    this.newSelectTagValue = function() {
      return new MetricSegment({value: 'select tag value', fake: true});
    };

  });

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 750:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(3),
  __webpack_require__(2),
  __webpack_require__(24),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, _, coreModule, config) {
  'use strict';

  coreModule.default.service('backendSrv', function($http, alertSrv, $timeout, contextSrv, $q) {
    var self = this;
    this.alertDUrl;
    this.downloadUrl;
    this.tokens = null;

    this.get = function(url, params) {
      return this.request({ method: 'GET', url: url, params: params });
    };

    this.delete = function(url) {
      return this.request({ method: 'DELETE', url: url });
    };

    this.post = function(url, data) {
      return this.request({ method: 'POST', url: url, data: data });
    };

    this.patch = function(url, data) {
      return this.request({ method: 'PATCH', url: url, data: data });
    };

    this.put = function(url, data) {
      return this.request({ method: 'PUT', url: url, data: data });
    };

    this._handleError = function(err) {
      return function() {
        if (err.isHandled) {
          return;
        }

        var data = err.data || { message: 'Unexpected error' };
        if (_.isString(data)) {
          data = { message: data };
        }

        if (err.status === 422) {
          alertSrv.set("Validation failed", data.message, "warning", 4000);
          throw data;
        }

        data.severity = 'error';

        if (err.status < 500) {
          data.severity = "warning";
        }

        if (data.message) {
          alertSrv.set("Problem!", data.message, data.severity, 10000);
        }

        throw data;
      };
    };

    this.request = function(options) {
      options.retry = options.retry || 0;
      var requestIsLocal = options.url.indexOf('/') === 0;
      var firstAttempt = options.retry === 0;

      if (requestIsLocal && !options.hasSubUrl) {
        options.url = config.appSubUrl + options.url;
        options.hasSubUrl = true;
      }

      if (self.isIE()) {
        var bust = Date.now();
        options.params ? options.params.bust = bust : options.params = {'bust': bust};
      }

      return $http(options).then(function(results) {
        if (options.method !== 'GET') {
          if (results && results.data.message) {
            alertSrv.set(results.data.message, '', 'success', 3000);
          }
        }
        return results.data;
      }, function(err) {
        // handle unauthorized
        if (err.status === 401 && firstAttempt) {
          return self.loginPing().then(function() {
            options.retry = 1;
            return self.request(options);
          });
        }

        $timeout(self._handleError(err), 50);
        throw err;
      });
    };

    this.datasourceRequest = function(options) {
      options.retry = options.retry || 0;
      var requestIsLocal = options.url.indexOf('/') === 0;
      var firstAttempt = options.retry === 0;

      if (self.isIE()) {
        var bust = Date.now();
        options.params ? options.params.bust = bust : options.params = {'bust': bust};
      }

      return $http(options).then(null, function(err) {
        // handle unauthorized for backend requests
        if (requestIsLocal && firstAttempt  && err.status === 401) {
          return self.loginPing().then(function() {
            options.retry = 1;
            return self.datasourceRequest(options);
          });
        }

        //populate error obj on Internal Error
        if (_.isString(err.data) && err.status === 500) {
          err.data = {
            error: err.statusText,
            response: err.data,
          };
        }

        // for Prometheus
        // if (!err.data.message && _.isString(err.data.error)) {
        //   err.data.message = err.data.error;
        // }

        throw err;
      });
    };

    this.loginPing = function() {
      return this.request({url: '/api/login/ping', method: 'GET', retry: 1 });
    };

    this.search = function(query) {
      return this.get('/api/search', query);
    };

    this.getDashboard = function(type, slug) {
      return this.get('/api/dashboards/' + type + '/' + slug);
    };

    this.saveDashboard = function(dash, options) {
      options = (options || {});
      return this.post('/api/dashboards/db/', {dashboard: dash, overwrite: options.overwrite === true});
    };

    this.getSystemById = function (id) {
      var sys = '';
      _.each(contextSrv.systemsMap, function (system) {
        if (system.Id === parseInt(id)) {
          sys = system.SystemsName;
        }
      });
      return sys;
    };

    //update system cache when systems change
    this.updateSystemsMap = function () {
      var getTokens = this.updateTokens();

      var getSystems = this.get("/api/user/system").then(function (systems) {
        contextSrv.systemsMap = systems;
      });
      return $q.all([getTokens, getSystems]);
    };

    this.updateTokens = function () {
      var updateToken = this.get('/api/auth/keys').then(function (tokens) {
        self.tokens = tokens;
      });
      return $q.all([updateToken, this.initCustomizedSources()]);
    };

    this.updateSystemId = function(id) {
      contextSrv.user.systemId = id;
    };

    this.initCustomizedSources = function () {
      return this.get('/api/customized_sources').then(function (result) {
        self.alertDUrl = result.alert;
        self.downloadUrl = result.download;
        contextSrv.elkUrl = result.elk;
      });
    };

    this.getToken = function () {
      return _.chain(self.tokens).filter({'name': contextSrv.user.systemId.toString()}).first().pick('key').values().first().value();
    };

    this.alertD = function (options) {
      if (_.isEmpty(options.params)) {
        options.params = {};
      }
      if (self.tokens) {
        options.url = self.alertDUrl + options.url;
        options.params.token = this.getToken();
        return this.datasourceRequest(options);
      }
      return self.updateTokens().then(function () {
        options.url = self.alertDUrl + options.url;
        options.params.token = self.getToken();
      }).then(function () {
        if (_.isEmpty(options.params.token)) {
          alertSrv.set(",TOKEN", "service@cloudwiz.cn", "warning", 4000);
          var d = $q.defer();
          d.resolve({});
          return d.promise;
        }
        return self.datasourceRequest(options);
      });
    };

    this.logCluster = function (options) {
      if (_.isEmpty(options.params)) {
        options.params = {};
      }
      options.withCredentials = true;
      options.url = contextSrv.elkUrl + options.url;
      return this.datasourceRequest(options);
    };

    this.knowledge = function (options) {
      if (_.isEmpty(options.params)) {
        options.params = {};
      }
      options.withCredentials = true;
      options.url = contextSrv.elkUrl + "/knowledgebase/article" + options.url;
      return this.datasourceRequest(options);
    };

    this.suggestTagHost = function (query, callback) {
      self.alertD({
        method: "get",
        url: "/summary",
        params: {metrics: "collector.summary"},
        headers: {'Content-Type': 'text/plain'},
      }).then(function (response) {
        var hosts = [];
        _.each(response.data, function (summary) {
          hosts.push(summary.tag.host);
        });
        return hosts;
      }).then(callback);
    };

    this.getPrediction = function(params) {
      return self.alertD({
        method: "get",
        url: "/anomaly/prediction",
        params: params,
        headers: {'Content-Type': 'application/json;'},
      });
    };

    this.getPredictionPercentage = function (params) {
      return self.alertD({
        method: "get",
        url   : "/anomaly/prediction/usages",
        params: params,
        headers: {'Content-Type': 'application/json;'}
      });
    };

    this.getHostsNum = function () {
      return this.alertD({
        method: "get",
        url: "/cmdb/host"
      }).then(function (response) {
        return response.data.length;
      });
    };

    this.saveCustomSoftware = function(params, url) {
      return this.alertD({
        method: "post",
        url: url,
        data: angular.toJson(params),
        headers: {'Content-Type': 'application/json;'},
      });
    };

    this.editServiceHost = function(params) {
      return this.alertD({
        method: "post",
        url: "/cmdb/relationship/overwrite",
        data: angular.toJson(params),
        headers: {'Content-Type': 'application/json;'},
      });
    };

    this.readMetricHelpMessage = function (key) {
      !_.metricMessage[key] && this.get('/api/static/metric/' + key).then(function (result) {
        _.metricMessage[key] = result;
        _.extend(_.metricHelpMessage, result);
      })
      .catch(function (err) {
        // set isHandled true, then alertSrv won't show
        err.isHandled = true;
      });
    };

    this.getHosts = function (query) {
      return this.alertD({
        method: "POST",
        url   : "/host/metrics",
        data  : query
      });
    };

    this.getServices = function() {
      return this.alertD({
        method: 'get',
        url   : "/cmdb/service/metrics"
      });
    }

    this.getKpi = function(params) {
      return this.alertD({
        method: 'get',
        url   : '/service/kpi',
        params: params
      });
    }

    this.editKpi = function(params) {
      return this.alertD({
        method: 'post',
        url   : '/service/kpi',
        params: params
      });
    }

    this.importMetricsKpi = function() {
      return this.get('/api/static/metric/kpi');
    }

    this.isIE = function() {
      var userAgent = navigator.userAgent;
      return userAgent.indexOf("MSIE ") > -1 || userAgent.indexOf("Trident/") > -1 || userAgent.indexOf("Edge/") > -1;
    }

    this.getOpentsdbExpressionQuery = function (query, opentsdbUrl) {
      var tags = query.tags || [
        {
          "type": "wildcard",
          "tagk": "host",
          "filter": "*",
          "groupBy": true
        }
      ];
      var tmpl = {
        "time": {
          "start": query.timeRange.from,
          "end": query.timeRange.to,
          "aggregator": "sum",
          "downsampler": {
            "interval": "1m",
            "aggregator": "avg"
          }
        },
        "filters": [
          {
            "tags": tags,
            "id": "f1"
          }
        ],
        "metrics": query.metrics,
        "expressions": [
          {
            "id": "aa",
            "expr": query.metricExpression, // "a + b"
            "join": {
              "operator": "intersection",
              "useQueryTags": true,
              "includeAggTags": false
            }
          }
        ],
        "outputs": [
          { "id": "aa", "alias": "Mega expression" }
        ]
      };

      return this.datasourceRequest({
        method: 'POST',
        url: opentsdbUrl + '/api/query/exp',
        data: tmpl
      });
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 751:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />


var DynamicDirectiveSrv = /** @class */ (function () {
    /** @ngInject */
    function DynamicDirectiveSrv($compile, $parse, $rootScope) {
        this.$compile = $compile;
        this.$parse = $parse;
        this.$rootScope = $rootScope;
    }
    DynamicDirectiveSrv.prototype.addDirective = function (element, name, scope) {
        var child = __WEBPACK_IMPORTED_MODULE_0_angular___default.a.element(document.createElement(name));
        this.$compile(child)(scope);
        element.empty();
        element.append(child);
    };
    DynamicDirectiveSrv.prototype.link = function (scope, elem, attrs, options) {
        var _this = this;
        options.directive(scope).then(function (directiveInfo) {
            if (!directiveInfo || !directiveInfo.fn) {
                elem.empty();
                return;
            }
            if (!directiveInfo.fn.registered) {
                __WEBPACK_IMPORTED_MODULE_1__core_module__["default"].directive(attrs.$normalize(directiveInfo.name), directiveInfo.fn);
                directiveInfo.fn.registered = true;
            }
            _this.addDirective(elem, directiveInfo.name, scope);
        }).catch(function (err) {
            console.log('Plugin load:', err);
            _this.$rootScope.appEvent('alert-error', ['Plugin error', err.toString()]);
        });
    };
    DynamicDirectiveSrv.prototype.create = function (options) {
        var _this = this;
        var directiveDef = {
            restrict: 'E',
            scope: options.scope,
            link: function (scope, elem, attrs) {
                if (options.watchPath) {
                    var childScope_1 = null;
                    scope.$watch(options.watchPath, function () {
                        if (childScope_1) {
                            childScope_1.$destroy();
                        }
                        childScope_1 = scope.$new();
                        _this.link(childScope_1, elem, attrs, options);
                    });
                }
                else {
                    _this.link(scope, elem, attrs, options);
                }
            }
        };
        return directiveDef;
    };
    return DynamicDirectiveSrv;
}());
__WEBPACK_IMPORTED_MODULE_1__core_module__["default"].service('dynamicDirectiveSrv', DynamicDirectiveSrv);


/***/ }),

/***/ 752:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(7),
  __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, coreModule) {
  'use strict';

  coreModule.default.service('utilSrv', function($rootScope, $_modal, $q) {

    this.init = function() {
      $rootScope.onAppEvent('show-modal', this.showModal, $rootScope);
    };

    this.showModal = function(e, options) {
      var modal = $_modal({
        modalClass: options.modalClass,
        template: options.src,
        persist: false,
        show: false,
        scope: options.scope,
        keyboard: false,
        placement: "center"
      });

      $q.when(modal).then(function(modalEl) {
        modalEl.modal('show');
      });
    };

    this.setPie = function (element, pieData, colors, innerRadius) {
      $.plot(element, pieData, {
        series: {
          pie: {
            innerRadius: innerRadius || 0.7,
            show: true,
            stroke: {
              width: 0
            }
          }
        },
        colors: colors
      });
    }

  });

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 753:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
    __webpack_require__(7),
    __webpack_require__(3),
    __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, _, coreModule) {
    'use strict';
    coreModule.default.service('healthSrv', function ($http, backendSrv, $location, $q) {
      var anomalyListUrl = "/anomaly?by_groups=true";
      var excludeAnomaly = "/anomaly/exclude";
      var includeAnomaly = "/anomaly/include";
      var metricsType = "/metrictype";
      var anomalyHistory = "/anomaly";
      this.anomalyMetricsData = [];
      var _this = this;
      this.load = function () {
        return backendSrv.alertD({
          method: "get",
          url: anomalyListUrl
        }).then(function onSuccess(response) {
          return response.data;
        }, function onFailed(response) {
          return response;
        });
      };

      this.exclude = function (metricName, host) {
        return backendSrv.alertD({
          method: "post",
          url: excludeAnomaly,
          params: {
            metric: metricName,
            host: host
          }
        });
      };

      this.aggregateHealths = function (metricHostClusters) {
        _.each(metricHostClusters, function (cluster, index) {
          cluster.health = 0;
          for (var i = 0; i < cluster.elements.length; i++) {
            cluster.health += cluster.elements[i].health;
          }
          var divisor = cluster.numElements || 1;
          var health = cluster.numElements ? cluster.health : 100;
          cluster.health = Math.floor(health / divisor);
          cluster.index = index;
        });
        return metricHostClusters;
      };

      this.include = function (metricName, host) {
        return backendSrv.alertD({
          method: "post",
          url: includeAnomaly,
          params: {
            metric: metricName,
            host: host
          }
        });
      };

      this.getMetricType = function (metric) {
        return this.getMetricsType([metric]);
      };

      this.getMetricsType = function (metrics) {
        return backendSrv.alertD({
          method: 'GET', url: metricsType, timeout: 2000,
          params: {
            names: metrics.join()
          }
        });
      };

      this.floor = function (metrics) {
        _.each(metrics, function (metric) {
          metric.health = Math.floor(metric.health);
        });
        return metrics;
      };

      this.transformPanelMetricType = function (panel) {
        var targets = {};
        var metricsTypeQueries = [];

        _.forEach(panel.targets, function (target) {
          if (_.excludeMetricSuffix(target.metric)) {
            targets[target.metric] = target;
          }
        });

        if(!Object.keys(targets).length) return;

        var q = _this.getMetricsType(Object.keys(targets)).then(function onSuccess(response) {
          var types = response.data;
          _.each(Object.keys(targets), function (key) {
            if (types[key] === "counter") {
              targets[key].shouldComputeRate = true;
              targets[key].downsampleAggregator = "max";
            } else if (types[key] === "increment") {
              targets[key].shouldComputeRate = false;
              targets[key].downsampleAggregator = "sum";
            }
          });
        });
        metricsTypeQueries.push(q);

        return $q.all(metricsTypeQueries);
      };

      this.transformMetricType = function (dashboard) {
        var targets = {};
        var metricsTypeQueries = [];
        _.forEach(["/association", "/anomaly"], function (uri) {
          if ($location.path().indexOf(uri) > -1) {
            _.forEach(dashboard.rows, function (row) {
              _.forEach(row.panels, function (panel) {
                _.forEach(panel.targets, function (target) {
                  if (_.excludeMetricSuffix(target.metric)) {
                    if (!_.isUndefined(target.metric)) {
                      targets[target.metric] = target;
                    }
                  }
                });
              });
            });

            if(!Object.keys(targets).length) {
              return;
            }
            var q = _this.getMetricsType(Object.keys(targets)).then(function onSuccess(response) {
              var types = response.data;
              _.each(Object.keys(targets), function (key) {
                if (types[key] === "counter") {
                  targets[key].shouldComputeRate = true;
                  targets[key].downsampleAggregator = "max";
                } else if (types[key] === "increment") {
                  targets[key].shouldComputeRate = false;
                  targets[key].downsampleAggregator = "sum";
                }
              });
            });
            metricsTypeQueries.push(q);
          }
        });
        return $q.all(metricsTypeQueries);
      };

      this.loadHistory = function(options, host) {
        var params = {
          from: options.from,
          to: options.to
        };
        host && (params['host'] = host);
        return backendSrv.alertD({
          method: "get",
          params: params,
          url: anomalyHistory
        }).then(function onSuccess(response) {
          return response.data;
        }, function onFailed(response) {
          return response;
        });
      };
    });
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 754:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
    __webpack_require__(7),
    __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular,coreModule) {
  'use strict';
  coreModule.default.service('integrateSrv',function () {
    return {
        options : {}
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ 755:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
    __webpack_require__(7),
    __webpack_require__(3),
    __webpack_require__(2),
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (angular, _, coreModule) {
  'use strict';
  coreModule.default.service('oncallerMgrSrv', function($http, alertSrv, backendSrv, contextSrv) {
    this.oncallerDefMap = {};
    this.currentEditUser = {};
    var self = this;
    var oncallerUrl = "/oncaller/definition";
    var oncallerScheduleUrl = "/oncaller/schedule";

    this.load = function() {
      return backendSrv.alertD({
        method: "get",
        url: oncallerUrl,
      }).then(function onSuccess(response) {
        for (var i = 0; i < response.data.length; i++) {
          var theoncallerDef = response.data[i];
          self.oncallerDefMap[theoncallerDef.id] = theoncallerDef;
        }
        return response;
      }, function onFailed(response) {
        alertSrv.set("error", response.status + " " + (response.data || "Request failed"), response.severity, 5000);
        return response;
      });
    };

    this.save = function(oncallerDef) {
      oncallerDef.org = contextSrv.user.orgId;
      return backendSrv.alertD({
        method: "post",
        url: oncallerUrl,
        data: angular.toJson(oncallerDef),
        headers: {'Content-Type': 'text/plain'},
      });
    };

    this.remove = function(oncallerOrg, oncallerService, oncallerId) {
      return backendSrv.alertD({
        method: "delete",
        url: oncallerUrl,
        params: {org: oncallerOrg, service: oncallerService, id: oncallerId},
        headers: {'Content-Type': 'text/plain'},
      });
    };

    //id is in the form of id
    this.get = function(id) {
      return self.oncallerDefMap[id];
    };

    this.loadSchedule = function (start, end) {
      return backendSrv.alertD({
        method: "get",
        url: oncallerScheduleUrl,
        params: {
          startSec: start,
          endSec: end
        }
      }).then(function onSuccess(response) {
        return response;
      }, function onFailed(response) {
        return response;
      });
    };

    this.updateSchedule = function (data) {
      return backendSrv.alertD({
        method: "post",
        url: oncallerScheduleUrl,
        data: angular.toJson(data),
        headers: {'Content-Type': 'text/plain'},
      });
    };

  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ 756:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ServiceDepSrv", function() { return ServiceDepSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />


var ServiceDepSrv = /** @class */ (function () {
    /** @ngInject */
    function ServiceDepSrv($http, $timeout, $q, alertSrv, backendSrv) {
        this.$http = $http;
        this.$timeout = $timeout;
        this.$q = $q;
        this.alertSrv = alertSrv;
        this.backendSrv = backendSrv;
    }
    // All Services
    ServiceDepSrv.prototype.readInstalledService = function () {
        return this.backendSrv.alertD({
            url: "/cmdb/service"
        });
    };
    // Service Dependency
    ServiceDepSrv.prototype.createServiceDependency = function (graph) {
        return this.backendSrv.alertD({
            method: "post",
            url: "/cmdb/service/depend",
            data: graph,
            headers: { 'Content-Type': 'text/plain' }
        });
    };
    ServiceDepSrv.prototype.updateServiceDependency = function (graph, updateId, graphId) {
        return this.backendSrv.alertD({
            method: "PUT",
            url: "/cmdb/service/depend?id=" + updateId + "&aid=" + graphId,
            data: graph,
            headers: { 'Content-Type': 'text/plain' }
        });
    };
    ServiceDepSrv.prototype.readServiceDependency = function () {
        return this.backendSrv.alertD({
            url: "/cmdb/service/depend"
        });
    };
    // Kpi
    ServiceDepSrv.prototype.readServiceStatus = function (serviceId, serviceName) {
        return this.backendSrv.alertD({
            url: "/service/status?hostStatusIncluded=false&service=" + serviceName + "&serviceId=" + serviceId
        });
    };
    ServiceDepSrv.prototype.readHostStatus = function (serviceId, serviceName) {
        return this.backendSrv.alertD({
            url: "/service/status?healthItemType=ServiceState&service=" + serviceName + "&serviceId=" + serviceId
        });
    };
    ServiceDepSrv.prototype.readMetricStatus = function (serviceId, serviceName) {
        return this.backendSrv.alertD({
            url: "/service/status?service=" + serviceName + "&serviceId=" + serviceId
        });
    };
    // Service Topology
    ServiceDepSrv.prototype.getServiceTopologyData = function (params) {
        var _this = this;
        return this.readInstalledService().then(function (response) {
            var promiseList = [];
            _this.topology = [];
            response.data.forEach(function (item) {
                var q = _this.readServiceStatus(item.id, item.name).then(function (response) {
                    _this.topology.push({
                        parent: 'All',
                        name: item.name,
                        value: response.data.healthStatusType.toLowerCase(),
                        _private_: item
                    });
                }, function (err) {
                    _this.topology.push({
                        parent: 'All',
                        name: item.name,
                        value: 'grey',
                        _private_: item
                    });
                });
                promiseList.push(q);
            });
            return _this.$q.all(promiseList).then(function () {
                _this.topology = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.orderBy(_this.topology, ['name'], ['asc']);
                return _this.topology;
            });
        });
    };
    return ServiceDepSrv;
}());

__WEBPACK_IMPORTED_MODULE_1_app_core_core_module__["default"].service('serviceDepSrv', ServiceDepSrv);


/***/ }),

/***/ 757:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HostSrv", function() { return HostSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />


var HostSrv = /** @class */ (function () {
    /** @ngInject */
    function HostSrv($http, backendSrv, $translate) {
        this.$http = $http;
        this.backendSrv = backendSrv;
        this.$translate = $translate;
    }
    // Host Tags
    /**
     * Get the specific host information in cmdb.
     * @param hostId.
     * @returns {Array} Host information.
     */
    HostSrv.prototype.getCmdbHostInfo = function (hostId) {
        return this.backendSrv.alertD({
            method: 'GET',
            url: '/cmdb/host',
            params: { 'id': hostId }
        });
    };
    /**
     * Get all tags key in this system.
     * @returns {Array} Tags key in this system.
     */
    HostSrv.prototype.getAllTagsKey = function () {
        return this.backendSrv.alertD({
            method: 'GET',
            url: '/host/tag/key'
        });
    };
    /**
     * Get the specific tag's value.
     * @returns {Array} Tag's value.
     */
    HostSrv.prototype.getTagValue = function (key) {
        return this.backendSrv.alertD({
            method: 'GET',
            url: '/host/tag/value',
            params: { 'key': key }
        });
    };
    /**
     * Post a tag.
     * @returns {String|Null} If the tag was added, return the tag key. Otherwise, none.
     */
    HostSrv.prototype.postTag = function (_a) {
        var key = _a.key, value = _a.value, hostId = _a.hostId;
        return this.backendSrv.alertD({
            method: 'POST',
            url: '/host/tag',
            params: { 'hostId': hostId },
            data: { 'key': key, 'value': value }
        });
    };
    /**
     * Delete a tag.
     * @returns {Null}
     */
    HostSrv.prototype.deleteTag = function (_a) {
        var hostId = _a.hostId, key = _a.key, value = _a.value;
        return this.backendSrv.alertD({
            method: 'DELETE',
            url: '/host/tag',
            params: { 'hostId': hostId, 'key': key, 'value': value }
        });
    };
    // Host Topology
    /**
     * Get the host topology graph with given params.
     * @param groupBy group rule.
     * @param colorBy filter rule.
     * @returns {Array|Object}
     */
    HostSrv.prototype.getHostTopology = function (params) {
        return this.backendSrv.alertD({
            method: 'GET',
            url: '/host/topology',
            params: params
        });
    };
    HostSrv.prototype.getHostTopologyData = function (params) {
        var _this = this;
        return this.backendSrv.alertD({
            method: 'GET',
            url: '/host/topology',
            params: params
        }).then(function (response) {
            _this.topology = [];
            if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(response.data)) {
                response.data.forEach(function (item) {
                    _this.topology.push({
                        parent: 'All',
                        name: item.hostname,
                        value: item.healthStatusType.toLowerCase(),
                        ip: item.defaultIp,
                        _private_: item
                    });
                });
            }
            else {
                for (var prop in response.data) {
                    response.data[prop].forEach(function (item) {
                        _this.topology.push({
                            parent: prop,
                            name: item.hostname,
                            value: item.healthStatusType.toLowerCase(),
                            ip: item.defaultIp,
                            _private_: item
                        });
                    });
                }
            }
            _this.topology = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.orderBy(_this.topology, ['name'], ['asc']);
            return _this.topology;
        });
    };
    // Host Process
    /**
     * Get the specific host's process.
     * @param Object include hostId(or hostname) & from & to
     * @returns {Array} host's process information.
     */
    HostSrv.prototype.getHostProcess = function (hostId) {
        return this.backendSrv.alertD({
            method: 'GET',
            url: '/host/state',
            params: { 'hostId': hostId }
        });
    };
    HostSrv.prototype.getProcess = function (params) {
        return this.backendSrv.alertD({
            method: 'GET',
            url: '/host/state',
            params: params
        });
    };
    // Host Information
    /**
     * Get host's information.
     * @return {Array} host's information: cpu, mem, disk, state, version, startTime, commitId, id.
     */
    HostSrv.prototype.getHostInfo = function () {
        var _this = this;
        var query = {
            "queries": [
                {
                    "metric": "cpu.usr"
                },
                {
                    "metric": "collector.state"
                },
                {
                    "metric": "proc.meminfo.percentused"
                },
                {
                    "metric": "df.bytes.percentused",
                    "tags": [
                        {
                            "name": "mount",
                            "value": "/"
                        }
                    ]
                }
            ],
            "hostProperties": ["version", "startTime", "commit", "id", "defaultIp"]
        };
        this.hostInfo = [];
        return this.backendSrv.alertD({
            method: "POST",
            url: "/host/metrics",
            data: query
        }).then(function (response) {
            response.data && response.data.forEach(function (item) {
                _this.hostInfo.push({
                    "host": item.hostname,
                    "id": item.id,
                    "status": _this.$translate.i18n[__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.statusFormatter(item["collector.state"])],
                    "disk": __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.percentFormatter(item["df.bytes.percentused"]),
                    "cpu": __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.percentFormatter(item["cpu.usr"]),
                    "mem": __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.percentFormatter(item["proc.meminfo.percentused"]),
                    "commit": item.commit,
                    "startTime": item.startTime,
                    "version": item.version,
                    "defaultIp": item.defaultIp
                });
            });
            _this.hostInfo = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.orderBy(_this.hostInfo, ['host'], ['asc']);
            return _this.hostInfo;
        });
    };
    // Host KPI
    /**
     * Get host's kpi.
     * @return {Array} host's kpi.
     */
    HostSrv.prototype.getHostKpi = function (_a) {
        var hostname = _a.hostname;
        return this.backendSrv.alertD({
            method: "GET",
            url: "/service/hostStatus",
            params: { host: hostname }
        });
    };
    return HostSrv;
}());

__WEBPACK_IMPORTED_MODULE_1_app_core_core_module__["default"].service('hostSrv', HostSrv);


/***/ }),

/***/ 758:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssociationSrv", function() { return AssociationSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);

var AssociationSrv = /** @class */ (function () {
    /** @ngInject */
    function AssociationSrv(alertMgrSrv) {
        this.alertMgrSrv = alertMgrSrv;
    }
    AssociationSrv.prototype.setSourceAssociation = function (_a) {
        var metric = _a.metric, host = _a.host, min = _a.min, max = _a.max, start = _a.start;
        this.sourceAssociation = {
            metric: metric,
            host: host,
            start: start,
            min: min,
            max: max
        };
    };
    AssociationSrv.prototype.updateRang = function (range) {
        this.sourceAssociation.min = range[0];
        this.sourceAssociation.max = range[1];
    };
    return AssociationSrv;
}());

__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].service('associationSrv', AssociationSrv);


/***/ }),

/***/ 759:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GuideSrv", function() { return GuideSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);

var GuideSrv = /** @class */ (function () {
    /** @ngInject */
    function GuideSrv(alertMgrSrv, associationSrv) {
        this.alertMgrSrv = alertMgrSrv;
        this.associationSrv = associationSrv;
    }
    return GuideSrv;
}());

__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].service('guideSrv', GuideSrv);


/***/ }),

/***/ 760:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogParseSrv", function() { return LogParseSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />

var LogParseSrv = /** @class */ (function () {
    /** @ngInject */
    function LogParseSrv(backendSrv) {
        this.backendSrv = backendSrv;
    }
    LogParseSrv.prototype.getListRule = function (orgId, sysId) {
        return this.backendSrv.alertD({
            url: '/cmdb/pattern/list',
            params: {
                orgId: orgId,
                sysId: sysId
            }
        });
    };
    LogParseSrv.prototype.getTemplate = function (params) {
        return this.backendSrv.alertD({
            url: '/cmdb/pattern/template',
            params: params
        });
    };
    LogParseSrv.prototype.getRuleById = function (id) {
        return this.backendSrv.alertD({
            url: '/cmdb/pattern/getById',
            params: {
                ruleId: id
            }
        });
    };
    LogParseSrv.prototype.getServiceList = function () {
        return this.backendSrv.alertD({ url: '/cmdb/service' });
    };
    LogParseSrv.prototype.getHostList = function () {
        return this.backendSrv.alertD({ url: '/cmdb/host' });
    };
    LogParseSrv.prototype.validatePattern = function (pattern) {
        return this.backendSrv.alertD({
            url: '/cmdb/pattern/validate',
            method: 'post',
            data: {
                log: pattern.log,
                pattern: pattern.pattern,
                type: pattern.type,
                namedCaptureOnly: true,
                isMetric: pattern.isMetric
            }
        });
    };
    LogParseSrv.prototype.savePattern = function (userId, data) {
        return this.backendSrv.alertD({
            url: '/cmdb/pattern/save',
            method: 'post',
            params: {
                userId: userId
            },
            data: data
        });
    };
    LogParseSrv.prototype.deletePattern = function (ruleId, userId) {
        return this.backendSrv.alertD({
            url: '/cmdb/pattern/delete',
            method: 'delete',
            params: {
                ruleId: ruleId,
                userId: userId
            }
        });
    };
    LogParseSrv.prototype.checktask = function (data) {
        return this.backendSrv.alertD({
            url: '/cmdb/log/checktask',
            method: 'post',
            data: data
        });
    };
    LogParseSrv.prototype.getChecktask = function (params) {
        return this.backendSrv.alertD({
            url: '/cmdb/log/check',
            params: params
        });
    };
    return LogParseSrv;
}());

__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].service('logParseSrv', LogParseSrv);


/***/ }),

/***/ 761:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MetricSrv", function() { return MetricSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />

var MetricSrv = /** @class */ (function () {
    /** @ngInject */
    function MetricSrv(backendSrv) {
        this.backendSrv = backendSrv;
    }
    MetricSrv.prototype.getSubtype = function () {
        return this.backendSrv.alertD({
            url: '/metric/subtype'
        });
    };
    MetricSrv.prototype.getSuggest = function (query) {
        return this.backendSrv.alertD({
            url: '/metric/suggest',
            params: {
                q: query
            }
        });
    };
    /**
     * getMetricInfo params
     *  @param {size} number The page size.
     *  @param {page} number The page number
     *  @param {id} number The metric id
     *  @param {name} string The metric name
     *  @param {type} string /
     *  @param {subtype} string serviceName/CPU/IO/JVM////
     */
    MetricSrv.prototype.getMetricInfo = function (params) {
        return this.backendSrv.alertD({
            url: '/metric/info',
            params: params
        });
    };
    /**
     * updateMetricInfo params
     *  @param {id} number metricId
     *  @param {userId} number userId
     */
    MetricSrv.prototype.updateMetricInfo = function (params, data) {
        return this.backendSrv.alertD({
            method: 'post',
            url: '/metric/info',
            params: params,
            data: data
        });
    };
    return MetricSrv;
}());

__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].service('metricSrv', MetricSrv);


/***/ }),

/***/ 762:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReportSrv", function() { return ReportSrv; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />

var ReportSrv = /** @class */ (function () {
    /** @ngInject */
    function ReportSrv(backendSrv, contextSrv) {
        this.backendSrv = backendSrv;
        this.contextSrv = contextSrv;
    }
    ReportSrv.prototype.getExpertReports = function () {
        var _this = this;
        return this.backendSrv.get('/api/static/template/' + this.contextSrv.user.orgId).then(function (res) {
            return { reports: res.reports, url: _this.backendSrv.downloadUrl + '/report' };
        });
    };
    ReportSrv.prototype.getReportConfig = function () {
        return this.backendSrv.alertD({
            url: '/reporting/config'
        });
    };
    /**
     * saveReportConfig data
     * @param {enabled} boolean 
     * @param {recipients} arrary 
     * @param {delieverHour} number 
     * @param {sections} array 
     */
    ReportSrv.prototype.saveReportConfig = function (data) {
        return this.backendSrv.alertD({
            url: '/reporting/config',
            method: 'post',
            data: data
        });
    };
    /**
     * getMetricInfo params
     */
    ReportSrv.prototype.getReportList = function () {
        return this.backendSrv.alertD({
            url: '/reporting',
        });
    };
    /**
     * getReportById params
     */
    ReportSrv.prototype.getReportById = function (id) {
        return this.backendSrv.alertD({
            url: '/reporting',
            responseType: 'arraybuffer',
            params: {
                id: id
            }
        });
    };
    return ReportSrv;
}());

__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].service('reportSrv', ReportSrv);


/***/ }),

/***/ 763:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__dashboard_loaders__ = __webpack_require__(764);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_app_core_core_module__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__bundle_loader__ = __webpack_require__(765);
///<reference path="../../headers/common.d.ts" />



/** @ngInject **/
function setupAngularRoutes($routeProvider, $locationProvider) {
    $locationProvider.html5Mode(true);
    var loadPluginsBundle = new __WEBPACK_IMPORTED_MODULE_2__bundle_loader__["a" /* BundleLoader */]('app/features/plugins/all');
    var loadAdminBundle = new __WEBPACK_IMPORTED_MODULE_2__bundle_loader__["a" /* BundleLoader */]('app/features/admin/admin');
    var loadOrgBundle = new __WEBPACK_IMPORTED_MODULE_2__bundle_loader__["a" /* BundleLoader */]('app/features/org/all');
    var loadOncallerBundle = new __WEBPACK_IMPORTED_MODULE_2__bundle_loader__["a" /* BundleLoader */]('app/features/oncaller/all');
    var loadCMDBBundle = new __WEBPACK_IMPORTED_MODULE_2__bundle_loader__["a" /* BundleLoader */]('app/features/cmdb/all');
    var loadSetupBundle = new __WEBPACK_IMPORTED_MODULE_2__bundle_loader__["a" /* BundleLoader */]('app/features/setup/all');
    var loadSummaryBundle = new __WEBPACK_IMPORTED_MODULE_2__bundle_loader__["a" /* BundleLoader */]('app/features/summary/all');
    var loadAnomalyBundle = new __WEBPACK_IMPORTED_MODULE_2__bundle_loader__["a" /* BundleLoader */]('app/features/anomaly/all');
    var loadServiceBundle = new __WEBPACK_IMPORTED_MODULE_2__bundle_loader__["a" /* BundleLoader */]('app/features/service/all');
    var loadAnalysisBundle = new __WEBPACK_IMPORTED_MODULE_2__bundle_loader__["a" /* BundleLoader */]('app/features/analysis/all');
    var loadLogsBundle = new __WEBPACK_IMPORTED_MODULE_2__bundle_loader__["a" /* BundleLoader */]('app/features/logs/all');
    var loadReportBundle = new __WEBPACK_IMPORTED_MODULE_2__bundle_loader__["a" /* BundleLoader */]('app/features/report/reportCtrl');
    var loadRcaBundle = new __WEBPACK_IMPORTED_MODULE_2__bundle_loader__["a" /* BundleLoader */]('app/features/rca/all');
    var loadHostBundle = new __WEBPACK_IMPORTED_MODULE_2__bundle_loader__["a" /* BundleLoader */]('app/features/host/all');
    var loadKnowledgeBundle = new __WEBPACK_IMPORTED_MODULE_2__bundle_loader__["a" /* BundleLoader */]('app/features/knowledge/all');
    $routeProvider
        .when('/', {
        templateUrl: 'public/app/features/systemoverview/partials/system_overview.html',
        controller: 'SystemOverviewCtrl',
        reloadOnSearch: false,
    })
        .when('/dashboardlist', {
        templateUrl: 'public/app/partials/dashboard.html',
        controller: 'LoadDashboardCtrl',
        reloadOnSearch: false,
        pageClass: 'page-dashboard',
    })
        .when('/systems', {
        templateUrl: 'public/app/partials/systems.html',
        reloadOnSearch: false,
    })
        .when('/dashboard/:type/:slug', {
        templateUrl: 'public/app/partials/dashboard.html',
        controller: 'LoadDashboardCtrl',
        reloadOnSearch: false,
        pageClass: 'page-dashboard',
    })
        .when('/dashboard-solo/:type/:slug', {
        templateUrl: 'public/app/features/panel/partials/soloPanel.html',
        controller: 'SoloPanelCtrl',
        pageClass: 'page-dashboard',
    })
        .when('/dashboard-import/:file', {
        templateUrl: 'public/app/partials/dashboard.html',
        controller: 'DashFromImportCtrl',
        reloadOnSearch: false,
        pageClass: 'page-dashboard',
    })
        .when('/dashboard/new', {
        templateUrl: 'public/app/partials/dashboard.html',
        controller: 'NewDashboardCtrl',
        reloadOnSearch: false,
        pageClass: 'page-dashboard',
    })
        .when('/import/dashboard', {
        templateUrl: 'public/app/features/dashboard/partials/import.html',
        controller: 'DashboardImportCtrl',
    })
        .when('/datasources', {
        templateUrl: 'public/app/features/plugins/partials/ds_list.html',
        controller: 'DataSourcesCtrl',
        controllerAs: 'ctrl',
        resolve: loadPluginsBundle,
    })
        .when('/datasources/edit/:id', {
        templateUrl: 'public/app/features/plugins/partials/ds_edit.html',
        controller: 'DataSourceEditCtrl',
        controllerAs: 'ctrl',
        resolve: loadPluginsBundle,
    })
        .when('/datasources/new', {
        templateUrl: 'public/app/features/plugins/partials/ds_edit.html',
        controller: 'DataSourceEditCtrl',
        controllerAs: 'ctrl',
        resolve: loadPluginsBundle,
    })
        .when('/alerts', {
        templateUrl: 'public/app/features/org/partials/alerts.html',
        controller: 'AlertsCtrl',
        controllerAs: 'ctrl',
        resolve: loadOrgBundle,
    })
        .when('/alerts/edit/:id', {
        templateUrl: 'public/app/features/org/partials/alertEdit.html',
        controller: 'AlertEditCtrl',
        controllerAs: 'ctrl',
        resolve: loadOrgBundle,
    })
        .when('/alerts/new', {
        templateUrl: 'public/app/features/org/partials/alertEdit.html',
        controller: 'AlertEditCtrl',
        controllerAs: 'ctrl',
        resolve: loadOrgBundle,
    })
        .when('/alerts/status', {
        templateUrl: 'public/app/features/org/partials/alertStatus.html',
        controller: 'AlertStatusCtrl',
        controllerAs: 'ctrl',
        resolve: loadOrgBundle,
    })
        .when('/oncallerschedule', {
        templateUrl: 'public/app/features/oncaller/partials/oncallerSchedule.html',
        controller: 'OnCallerScheduleCtrl',
        resolve: loadOncallerBundle,
    })
        .when('/oncallers', {
        templateUrl: 'public/app/features/oncaller/partials/oncallers.html',
        controller: 'OnCallersCtrl',
        controllerAs: 'ctrl',
        resolve: loadOncallerBundle,
    })
        .when('/oncallers/edit/:id', {
        templateUrl: 'public/app/features/oncaller/partials/oncallerEdit.html',
        controller: 'OnCallerEditCtrl',
        controllerAs: 'ctrl',
        resolve: loadOncallerBundle,
    })
        .when('/oncallers/new', {
        templateUrl: 'public/app/features/oncaller/partials/oncallerEdit.html',
        controller: 'OnCallerEditCtrl',
        controllerAs: 'ctrl',
        resolve: loadOncallerBundle,
    })
        .when('/anomaly', {
        templateUrl: 'public/app/features/anomaly/partials/anomaly.html',
        controller: 'AnomalyCtrl',
        resolve: loadAnomalyBundle,
    })
        .when('/anomaly/history', {
        templateUrl: 'public/app/features/anomaly/partials/anomalyHistory.html',
        controller: 'AnomalyHistory',
        resolve: loadAnomalyBundle,
    })
        .when('/anomaly/:clusterId', {
        templateUrl: 'public/app/features/anomaly/partials/anomalyMetric.html',
        controller: 'AnomalyMetric',
        reloadOnSearch: true,
        resolve: loadAnomalyBundle,
    })
        .when('/decompose', {
        templateUrl: 'public/app/features/decompose/partials/compose.html',
        controller: 'DecomposeMetricCtrl'
    })
        .when('/org', {
        templateUrl: 'public/app/features/org/partials/orgDetails.html',
        controller: 'OrgDetailsCtrl',
        resolve: loadOrgBundle,
    })
        .when('/org/new', {
        templateUrl: 'public/app/features/org/partials/newOrg.html',
        controller: 'NewOrgCtrl',
        resolve: loadOrgBundle,
    })
        .when('/org/users', {
        templateUrl: 'public/app/features/org/partials/orgUsers.html',
        controller: 'OrgUsersCtrl',
        controllerAs: 'ctrl',
        resolve: loadOrgBundle,
    })
        .when('/org/apikeys', {
        templateUrl: 'public/app/features/org/partials/orgApiKeys.html',
        controller: 'OrgApiKeysCtrl',
        resolve: loadOrgBundle,
    })
        .when('/profile', {
        templateUrl: 'public/app/features/org/partials/profile.html',
        controller: 'ProfileCtrl',
        controllerAs: 'ctrl',
        resolve: loadOrgBundle,
    })
        .when('/profile/password', {
        templateUrl: 'public/app/features/org/partials/change_password.html',
        controller: 'ChangePasswordCtrl',
        resolve: loadOrgBundle,
    })
        .when('/profile/select-org', {
        templateUrl: 'public/app/features/org/partials/select_org.html',
        controller: 'SelectOrgCtrl',
        resolve: loadOrgBundle,
    })
        .when('/admin', {
        templateUrl: 'public/app/features/admin/partials/admin_home.html',
        controller: 'AdminHomeCtrl',
        resolve: loadAdminBundle,
    })
        .when('/admin/settings', {
        templateUrl: 'public/app/features/admin/partials/settings.html',
        controller: 'AdminSettingsCtrl',
        resolve: loadAdminBundle,
    })
        .when('/admin/stats', {
        templateUrl: 'public/app/features/admin/partials/stats.html',
        controller: 'AdminStatsCtrl',
        controllerAs: 'ctrl',
        resolve: loadAdminBundle,
    })
        .when('/admin/users', {
        templateUrl: 'public/app/features/admin/partials/users.html',
        controller: 'AdminListUsersCtrl',
        resolve: loadAdminBundle,
    })
        .when('/admin/users/create', {
        templateUrl: 'public/app/features/admin/partials/new_user.html',
        controller: 'AdminEditUserCtrl',
        resolve: loadAdminBundle,
    })
        .when('/admin/users/edit/:id', {
        templateUrl: 'public/app/features/admin/partials/edit_user.html',
        controller: 'AdminEditUserCtrl',
        resolve: loadAdminBundle,
    })
        .when('/admin/orgs', {
        templateUrl: 'public/app/features/admin/partials/orgs.html',
        controller: 'AdminListOrgsCtrl',
        resolve: loadAdminBundle,
    })
        .when('/admin/orgs/edit/:id', {
        templateUrl: 'public/app/features/admin/partials/edit_org.html',
        controller: 'AdminEditOrgCtrl',
        resolve: loadAdminBundle,
    })
        .when('/login', {
        templateUrl: 'public/app/partials/login.html',
        controller: 'LoginCtrl',
    })
        .when('/signupfree', {
        templateUrl: 'public/app/partials/signup.html',
        controller: 'SignupFreeCtrl',
    })
        .when('/invite/:code', {
        templateUrl: 'public/app/partials/signup_invited.html',
        controller: 'InvitedCtrl',
    })
        .when('/signup', {
        templateUrl: 'public/app/partials/signup_step2.html',
        controller: 'SignUpCtrl',
    })
        .when('/user/password/send-reset-email', {
        templateUrl: 'public/app/partials/reset_password.html',
        controller: 'ResetPasswordCtrl',
    })
        .when('/user/password/reset', {
        templateUrl: 'public/app/partials/reset_password.html',
        controller: 'ResetPasswordCtrl',
    })
        .when('/dashboard/snapshots', {
        templateUrl: 'public/app/features/snapshot/partials/snapshots.html',
        controller: 'SnapshotsCtrl',
        controllerAs: 'ctrl',
    })
        .when('/plugins', {
        templateUrl: 'public/app/features/plugins/partials/plugin_list.html',
        controller: 'PluginListCtrl',
        controllerAs: 'ctrl',
        resolve: loadPluginsBundle,
    })
        .when('/plugins/:pluginId/edit', {
        templateUrl: 'public/app/features/plugins/partials/plugin_edit.html',
        controller: 'PluginEditCtrl',
        controllerAs: 'ctrl',
        resolve: loadPluginsBundle,
    })
        .when('/plugins/:pluginId/page/:slug', {
        templateUrl: 'public/app/features/plugins/partials/plugin_page.html',
        controller: 'AppPageCtrl',
        controllerAs: 'ctrl',
        resolve: loadPluginsBundle,
    })
        .when('/global-alerts', {
        templateUrl: 'public/app/features/dashboard/partials/globalAlerts.html',
    })
        .when('/logs', {
        templateUrl: 'public/app/features/logs/partials/logs.html',
        controller: 'LogsCtrl',
        controllerAs: 'ctrl',
        resolve: loadLogsBundle,
    })
        .when('/logs/rules', {
        templateUrl: 'public/app/features/logs/partials/log_rules.html',
        controller: 'LogParseCtrl',
        controllerAs: 'ctrl',
        resolve: loadLogsBundle,
    })
        .when('/logs/rule-detail', {
        templateUrl: 'public/app/features/logs/partials/log_rule_detail.html',
        controller: 'LogParseCtrl',
        controllerAs: 'ctrl',
        resolve: loadLogsBundle,
    })
        .when('/logs/rules/new', {
        templateUrl: 'public/app/features/logs/partials/log_rules_new.html',
        controller: 'LogParseEditCtrl',
        controllerAs: 'ctrl',
        resolve: loadLogsBundle,
    })
        .when('/analysis', {
        templateUrl: 'public/app/features/analysis/partials/analysis.html',
        controller: 'AnalysisCtrl',
        resolve: loadAnalysisBundle,
    })
        .when('/association', {
        templateUrl: 'public/app/features/org/partials/alertAssociation.html',
        controller: 'AlertAssociationCtrl',
        controllerAs: 'ctrl',
        resolve: loadOrgBundle,
    })
        .when('/knowledgebase', {
        templateUrl: 'public/app/features/knowledge/partials/knowledge_base.html',
        controller: 'CreateKnowledgeCtrl',
        resolve: loadKnowledgeBundle,
    })
        .when('/customer', {
        templateUrl: 'public/app/features/summary/partials/customer.html',
        controller: 'CustomerCtrl',
        resolve: loadSummaryBundle,
    })
        .when('/report', {
        templateUrl: 'public/app/features/report/partials/report.html',
        controller: 'ReportCtrl',
        reloadOnSearch: false,
        controllerAs: 'ctrl',
        resolve: loadReportBundle
    })
        .when('/report/template', {
        templateUrl: 'public/app/features/report/partials/report_template.html',
        controller: 'ReportCtrl',
        reloadOnSearch: false,
        controllerAs: 'ctrl',
        resolve: loadReportBundle
    })
        .when('/report/edit', {
        templateUrl: 'public/app/features/report/partials/report_edit.html',
        controller: 'ReportCtrl',
        reloadOnSearch: false,
        controllerAs: 'ctrl',
        resolve: loadReportBundle
    })
        .when('/integrate', {
        templateUrl: 'public/app/features/analysis/partials/logIntegrate.html',
        controller: 'LogIntegrateCtrl',
        resolve: loadAnalysisBundle,
    })
        .when('/setting/agent', {
        templateUrl: 'public/app/features/setup/partials/host_agent.html',
        controller: 'HostAgentCtrl',
        resolve: loadSetupBundle,
    })
        .when('/setting/service', {
        templateUrl: 'public/app/features/setup/partials/service_agent.html',
        controller: 'ServiceAgentCtrl',
        resolve: loadSetupBundle,
    })
        .when('/setting/log', {
        templateUrl: 'public/app/features/setup/partials/log.html',
        reloadOnSearch: false,
    })
        .when('/setting/proxy', {
        templateUrl: 'public/app/features/setup/partials/proxy.html',
        reloadOnSearch: false,
    })
        .when('/setting/problems', {
        templateUrl: 'public/app/features/setup/partials/problems.html',
        reloadOnSearch: false,
        controllerAs: 'ctrl',
        controller: 'ProblemsCtrl',
        resolve: loadSetupBundle,
    })
        .when('/cmdb/hostlist', {
        templateUrl: 'public/app/features/cmdb/partials/host_list.html',
        controller: 'HostListCtrl',
        resolve: loadCMDBBundle
    })
        .when('/cmdb/hostlist/hostdetail', {
        templateUrl: 'public/app/features/cmdb/partials/host_detail.html',
        controller: 'HostDetailCtrl',
        resolve: loadCMDBBundle
    })
        .when('/cmdb/servicelist', {
        templateUrl: 'public/app/features/cmdb/partials/service_list.html',
        controller: 'ServiceListCtrl',
        resolve: loadCMDBBundle
    })
        .when('/cmdb/servicelist/servicedetail', {
        templateUrl: 'public/app/features/cmdb/partials/service_detail.html',
        controller: 'CMDBServiceDetailCtrl',
        resolve: loadCMDBBundle
    })
        .when('/cmdb/config', {
        templateUrl: 'public/app/features/cmdb/partials/uagent.html',
        controller: 'UagentCtrl',
        controllerAs: 'ctrl',
        resolve: loadCMDBBundle
    })
        .when('/cmdb/config/edit', {
        templateUrl: 'public/app/features/cmdb/partials/uagent_edit.html',
        controller: 'UagentCtrl',
        controllerAs: 'ctrl',
        resolve: loadCMDBBundle
    })
        .when('/cmdb/servicecustom', {
        templateUrl: 'public/app/features/cmdb/partials/service_custom.html',
        controller: 'ServiceCustomCtrl',
        controllerAs: 'ctrl',
        resolve: loadCMDBBundle
    })
        .when('/cmdb/metrics', {
        templateUrl: 'public/app/features/cmdb/partials/metrics_def.html',
        controller: 'MetricsDefCtrl',
        controllerAs: 'ctrl',
        resolve: loadCMDBBundle
    })
        .when('/cmdb/kpi', {
        templateUrl: 'public/app/features/cmdb/partials/metric_kpi.html',
        controller: 'MetricKpiCtrl',
        controllerAs: 'ctrl',
        resolve: loadCMDBBundle
    })
        .when('/service_dependency', {
        templateUrl: 'public/app/features/service/partials/service_dep.html',
        controller: 'BuildDependCtrl',
        controllerAs: 'ctrl',
        resolve: loadServiceBundle,
    })
        .when('/rca', {
        templateUrl: 'public/app/features/rca/partials/rca.html',
        controller: 'RootCauseAnalysisCtrl',
        reloadOnSearch: false,
        resolve: loadRcaBundle,
    })
        .when('/host_topology', {
        templateUrl: 'public/app/features/host/partials/host.html',
        controller: 'HostTopologyCtrl',
        reloadOnSearch: false,
        resolve: loadHostBundle
    })
        .when('/service_topology', {
        templateUrl: 'public/app/features/service/partials/service.html',
        controller: 'ServiceTopologyCtrl',
        reloadOnSearch: false,
        resolve: loadServiceBundle
    })
        .when('/styleguide/:page?', {
        controller: 'StyleGuideCtrl',
        controllerAs: 'ctrl',
        templateUrl: 'public/app/features/styleguide/styleguide.html',
    })
        .when('/topn', {
        controller: 'TopNCtrl',
        controllerAs: 'ctrl',
        templateUrl: 'public/app/features/topn/partials/topn.html'
    })
        .otherwise({
        templateUrl: 'public/app/partials/error.html',
        controller: 'ErrorCtrl',
        reloadOnSearch: false,
    });
}
__WEBPACK_IMPORTED_MODULE_1_app_core_core_module__["default"].config(setupAngularRoutes);


/***/ }),

/***/ 764:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export LoadDashboardCtrl */
/* unused harmony export DashFromImportCtrl */
/* unused harmony export NewDashboardCtrl */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_app_core_core_module__ = __webpack_require__(2);

var LoadDashboardCtrl = /** @class */ (function () {
    /** @ngInject */
    function LoadDashboardCtrl($scope, $routeParams, $location, dashboardLoaderSrv, backendSrv) {
        this.$scope = $scope;
        this.$routeParams = $routeParams;
        this.$location = $location;
        this.dashboardLoaderSrv = dashboardLoaderSrv;
        this.backendSrv = backendSrv;
        if (!$routeParams.slug) {
            backendSrv.get('/api/dashboards/home').then(function (homeDash) {
                if (homeDash.redirectUri) {
                    $location.path('dashboard/' + homeDash.redirectUri);
                }
                else {
                    var meta = homeDash.meta;
                    meta.canSave = meta.canShare = meta.canStar = false;
                    $scope.initDashboard(homeDash, $scope);
                }
            });
            return;
        }
        dashboardLoaderSrv.loadDashboard($routeParams.type, $routeParams.slug).then(function (result) {
            $scope.initDashboard(result, $scope);
        });
    }
    return LoadDashboardCtrl;
}());

__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].controller('LoadDashboardCtrl', LoadDashboardCtrl);
var DashFromImportCtrl = /** @class */ (function () {
    /** @ngInject */
    function DashFromImportCtrl($scope, $location, alertSrv, $translate) {
        this.$scope = $scope;
        this.$location = $location;
        this.alertSrv = alertSrv;
        this.$translate = $translate;
        if (!window.grafanaImportDashboard) {
            alertSrv.set($translate.i18n_sorry, $translate.page_dash_err_tip1, 'warning', 7000);
            $location.path('');
            return;
        }
        $scope.initDashboard({
            meta: { canShare: false, canStar: false },
            dashboard: window.grafanaImportDashboard
        }, $scope);
    }
    return DashFromImportCtrl;
}());

__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].controller('DashFromImportCtrl', DashFromImportCtrl);
var NewDashboardCtrl = /** @class */ (function () {
    /** @ngInject */
    function NewDashboardCtrl($scope, $routeParams) {
        this.$scope = $scope;
        this.$routeParams = $routeParams;
        var newTitle = $routeParams.title || "new dashboard";
        var newSystem = $routeParams.system;
        $scope.initDashboard({
            meta: { canStar: false, canShare: false },
            dashboard: {
                title: newTitle,
                system: newSystem,
                rows: [{ height: '250px', panels: [] }],
                time: { from: "now-6h", to: "now" },
                refresh: "30s",
            },
        }, $scope);
    }
    return NewDashboardCtrl;
}());

__WEBPACK_IMPORTED_MODULE_0_app_core_core_module__["default"].controller('NewDashboardCtrl', NewDashboardCtrl);


/***/ }),

/***/ 765:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BundleLoader; });
///<reference path="../../headers/common.d.ts" />
var BundleLoader = /** @class */ (function () {
    function BundleLoader(bundleName) {
        var _this = this;
        this.lazy = ["$q", "$route", "$rootScope", function ($q, $route, $rootScope) {
                if (_this.loadingDefer) {
                    return _this.loadingDefer.promise;
                }
                _this.loadingDefer = $q.defer();
                __webpack_require__(766)(bundleName).then(function () {
                    _this.loadingDefer.resolve();
                });
                return _this.loadingDefer.promise;
            }];
    }
    return BundleLoader;
}());



/***/ }),

/***/ 766:
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() {
		throw new Error("Cannot find module '" + req + "'.");
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 766;

/***/ }),

/***/ 767:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_angular__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_angular___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_angular__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_app_core_utils_datemath__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_module__ = __webpack_require__(2);
///<reference path="../../headers/common.d.ts" />





__WEBPACK_IMPORTED_MODULE_4__core_module__["default"].filter('stringSort', function () {
    return function (input) {
        return input.sort();
    };
});
__WEBPACK_IMPORTED_MODULE_4__core_module__["default"].filter('slice', function () {
    return function (arr, start, end) {
        if (!__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isUndefined(arr)) {
            return arr.slice(start, end);
        }
    };
});
__WEBPACK_IMPORTED_MODULE_4__core_module__["default"].filter('stringify', function () {
    return function (arr) {
        if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isObject(arr) && !__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(arr)) {
            return __WEBPACK_IMPORTED_MODULE_1_angular___default.a.toJson(arr);
        }
        else {
            return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isNull(arr) ? null : arr.toString();
        }
    };
});
__WEBPACK_IMPORTED_MODULE_4__core_module__["default"].filter('moment', function () {
    return function (date, mode) {
        switch (mode) {
            case 'ago':
                return __WEBPACK_IMPORTED_MODULE_2_moment___default()(date).fromNow();
        }
        return __WEBPACK_IMPORTED_MODULE_2_moment___default()(date).fromNow();
    };
});
__WEBPACK_IMPORTED_MODULE_4__core_module__["default"].filter('noXml', function () {
    var noXml = function (text) {
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isString(text)
            ? text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/'/g, '&#39;')
                .replace(/"/g, '&quot;')
            : text;
    };
    return function (text) {
        return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(text)
            ? __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(text, noXml)
            : noXml(text);
    };
});
__WEBPACK_IMPORTED_MODULE_4__core_module__["default"].filter('interpolateTemplateVars', function (templateSrv) {
    var filterFunc = function (text, scope) {
        var scopedVars;
        if (scope.ctrl && scope.ctrl.panel) {
            scopedVars = scope.ctrl.panel.scopedVars;
        }
        else {
            scopedVars = scope.row.scopedVars;
        }
        return templateSrv.replaceWithText(text, scopedVars);
    };
    filterFunc.$stateful = true;
    return filterFunc;
});
__WEBPACK_IMPORTED_MODULE_4__core_module__["default"].filter('formatItemType', function () {
    return function (text) {
        return text && text.replace('Host', '').replace('Service', '');
    };
});
__WEBPACK_IMPORTED_MODULE_4__core_module__["default"].filter('translateItemType', function ($translate) {
    return function (text) {
        var map = {
            "mem": $translate.i18n.i18n_mem,
            "io": $translate.i18n.i18n_io,
            "nw": $translate.i18n.i18n_net,
            "cpu": $translate.i18n.i18n_cpu,
            "kpi": $translate.i18n.page_overview_kpi_service,
            "state": $translate.i18n.page_overview_kpi_state
        };
        return text && map[text.toLowerCase()];
    };
});
__WEBPACK_IMPORTED_MODULE_4__core_module__["default"].filter('formatAnomalyHealth', function ($translate) {
    return function (value) {
        return value === 100 ? value : (value < 26 ? value + (" (" + $translate.i18n.page_anomaly_critical_metrics + ")") : value + (" (" + $translate.i18n.page_anomaly_warning_metrics + ")"));
    };
});
__WEBPACK_IMPORTED_MODULE_4__core_module__["default"].filter('formatTimeRange', function () {
    return function (text) {
        if (!text) {
            return;
        }
        var from = text.from, to = text.to;
        var args = Array.prototype.slice.call(arguments), time = args[0], relative = args[1], index = args[2];
        __WEBPACK_IMPORTED_MODULE_2_moment___default.a.isMoment(from) && (from = __WEBPACK_IMPORTED_MODULE_2_moment___default()(from));
        __WEBPACK_IMPORTED_MODULE_2_moment___default.a.isMoment(to) && (to = __WEBPACK_IMPORTED_MODULE_2_moment___default()(to));
        from = __WEBPACK_IMPORTED_MODULE_3_app_core_utils_datemath__["parse"](from, false);
        to = __WEBPACK_IMPORTED_MODULE_3_app_core_utils_datemath__["parse"](to, true);
        relative = parseInt(relative);
        !__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isNaN(relative) && (from = __WEBPACK_IMPORTED_MODULE_2_moment___default.a.utc(from).subtract(relative, 'days'),
            to = __WEBPACK_IMPORTED_MODULE_2_moment___default.a.utc(to).subtract(relative, 'days'));
        return __WEBPACK_IMPORTED_MODULE_2_moment___default.a.utc(index === 0 ? from : to).format("YYYY-MM-DD");
    };
});
__WEBPACK_IMPORTED_MODULE_4__core_module__["default"].filter('formatRCAType', function ($translate) {
    return function (value) {
        return (value === 1) ? $translate.i18n.i18n_metric : ((value === 2) ? $translate.i18n.i18n_menu_logs : $translate.i18n.i18n_other);
    };
});
/* unused harmony default export */ var _unused_webpack_default_export = ({});


/***/ }),

/***/ 768:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony default export */ var _unused_webpack_default_export = ([
    "#7EB26D", "#EAB839", "#6ED0E0", "#EF843C", "#E24D42", "#1F78C1", "#BA43A9", "#705DA0",
    "#508642", "#CCA300", "#447EBC", "#C15C17", "#890F02", "#0A437C", "#6D1F62", "#584477",
    "#B7DBAB", "#F4D598", "#70DBED", "#F9BA8F", "#F29191", "#82B5D8", "#E5A8E2", "#AEA2E0",
    "#629E51", "#E5AC0E", "#64B0C8", "#E0752D", "#BF1B00", "#0A50A1", "#962D82", "#614D93",
    "#9AC48A", "#F2C96D", "#65C5DB", "#F9934E", "#EA6460", "#5195CE", "#D683CE", "#806EB7",
    "#3F6833", "#967302", "#2F575E", "#99440A", "#58140C", "#052B51", "#511749", "#3F2B5B",
    "#E0F9D7", "#FCEACA", "#CFFAFF", "#F9E2D2", "#FCE2DE", "#BADFF4", "#F9D9F9", "#DEDAF7"
]);


/***/ }),

/***/ 769:
/***/ (function(module, exports) {


(function (window, angular, undefined) {
  'use strict';

  var util = {
    trim: function (text) {
      return text.toString().replace(/^\s+|\s+$/g, '');
    },
    lowercase: function (str) {
      return (typeof str === 'string') ? str.toLowerCase() : str;
    },
    indexOf: function (array, searchElement) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (array[i] === searchElement) {
          return i;
        }
      }
      return -1;
    }
  };

  var runTranslate = ['$translate', function ($translate) {
    var key = $translate.storageKey(),
      storage = $translate.storage();

    var fallbackFromIncorrectStorageValue = function () {
      var prefreed = $translate.preferredLanguage();
      if (angular.isString(prefreed)) {
        $translate.use(prefreed);
      } else {
        storage.put(key, $translate.use());
      }
    };

    if (storage) {
      if (!storage.get(key)) {
        fallbackFromIncorrectStorageValue();
      } else {
        $translate.use(storage.get(key))['catch'](fallbackFromIncorrectStorageValue);
      }
    } else if (angular.isString($translate.preferredLanguage())) {
      $translate.use($translate.preferredLanguage());
    }
  }];
  angular.module('cloudwiz.translate', ['ng']).run(runTranslate);

  /**
   * @name cloudwiz.translate.$translateProvider
   */
  var $translateProvider = ['$STORAGE_KEY', '$windowProvider', function ($STORAGE_KEY, $windowProvider) {

    var $translationTable = {},
      $preferredLanguage,
      $availableLanguageKeys = [],
      $languageKeyAliases,
      $fallbackLanguage,
      $fallbackWasString,
      $uses,
      $storageFactory,
      $storageKey = $STORAGE_KEY,
      $storagePrefix,
      $interpolationFactory,
      $interpolatorFactories = [],
      $loaderFactory,
      $loaderOptions,
      $nestedObjectDelimeter = '.',
      $isReady = false,
      $keepContent = false,
      $nextLang,
      $missingTranslationHandlerFactory,
      $postCompilingEnabled = false,
      loaderCache,
      postProcessFn,
      uniformLanguageTagResolver = 'default',
      statefulFilter = true,
      languageTagResolver = {
        'default' : function (tag) {
          return (tag || '').split('-').join('_');
        },
      };

    /**
     * @name flatObject
     */
    var flatObject = function (data, path, result, prevKey) {
      var key, keyWithPath, keyWithShortPath, val;

      !path && (path = []);
      !result && (result = {});
      for (key in data) {
        if (!Object.prototype.hasOwnProperty.call(data, key)) {
          continue;
        }
        val = data[key];
        if (angular.isObject(val)) {
          flatObject(val, path.concat(key), result, key);
        } else {
          keyWithPath = path.length ? (path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key) : key;
          if (path.length && key === prevKey) {
            // Create shortcut path (foo.bar == foo.bar.bar)
            keyWithShortPath = path.join($nestedObjectDelimeter);
            // Link it to original path
            result[keyWithShortPath] = '@:' + keyWithPath;
          }
          result[keyWithPath] = val;
        }
      }
      return result;
    };

    // tries to determine the browsers language
    var getFirstBrowserLanguage = function () {
      var navigator = $windowProvider.$get().navigator,
        browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'],
        i, language;

      // support for HTML 5.1 "navigator.languages"
      if (angular.isArray(navigator.languages)) {
        for (i = 0; i < navigator.languages.length; i++) {
          language = navigator.languages[i];
          if (language && language.length) {
            return language;
          }
        }
      }

      // support for other well known properties in browsers
      for (i = 0; i < browserLanguagePropertyKeys.length; i++) {
        language = navigator[browserLanguagePropertyKeys[i]];
        if (language && language.length) {
          return language;
        }
      }

      return null;
    };

    // tries to determine the browsers locale
    var getLocale = function () {
      var locale = getFirstBrowserLanguage() || '';
      if (languageTagResolver[uniformLanguageTagResolver]) {
        locale = languageTagResolver[uniformLanguageTagResolver](locale);
      }
      return locale;
    };

    /**
     * @name cloudwiz.translate.$translateProvider#determinePreferredLanguage
     */
    this.determinePreferredLanguage = function (fn) {
      var locale = (fn && angular.isFunction(fn)) ? fn() : getLocale();
      if (!$availableLanguageKeys.length) {
        $preferredLanguage = locale;
      }
      return this;
    };

    /**
     * @name cloudwiz.translate.$translateProvider#registerAvailableLanguageKeys
     */
    this.registerAvailableLanguageKeys = function (languageKeys, aliases) {
      if (languageKeys) {
        $availableLanguageKeys = languageKeys;
        if (aliases) {
          $languageKeyAliases = aliases;
        }
        return this;
      }
      return $availableLanguageKeys;
    };

    /**
     * @name cloudwiz.translate.$translateProvider#useLoader
     */
    this.useLoader = function (loaderFactory, options) {
      $loaderFactory = loaderFactory;
      $loaderOptions = options || {};
      return this;
    };

    /**
     * @name cloudwiz.translate.$translateProvider#useStaticFilesLoader
     */
    this.useStaticFilesLoader = function (options) {
      return this.useLoader('$translateStaticFilesLoader', options);
    };

    /**
     * @name cloudwiz.translate.$translateProvider#preferredLanguage
     */
    var setupPreferredLanguage = function (langKey) {
      if (langKey) { $preferredLanguage = langKey; }
      return $preferredLanguage;
    };
    this.preferredLanguage = function (langKey) {
      if (langKey) {
        setupPreferredLanguage(langKey);
        return this;
      }
      return $preferredLanguage;
    };

    /**
     * @name cloudwiz.translate.$translateProvider#fallbackLanguage
     */
    var fallbackStack = function (langKey) {
      if (langKey) {
        if (angular.isString(langKey)) {
          $fallbackWasString = true;
          $fallbackLanguage = [langKey];
        } else if (angular.isArray(langKey)) {
          $fallbackWasString = false;
          $fallbackLanguage = langKey;
        }
        if (angular.isString($preferredLanguage) && util.indexOf($fallbackLanguage, $preferredLanguage) < 0) {
          $fallbackLanguage.push($preferredLanguage);
        }

        return this;
      } else {
        if ($fallbackWasString) {
          return $fallbackLanguage[0];
        } else {
          return $fallbackLanguage;
        }
      }
    };
    this.fallbackLanguage = function (langKey) {
      fallbackStack(langKey);
      return this;
    };

    /**
     * @name cloudwiz.translate.$translateProvider#storageKey
     */
    var storageKey = function (key) {
      if (!key) {
        if ($storagePrefix) {
          return $storagePrefix + $storageKey;
        }
        return $storageKey;
      }
      $storageKey = key;
      return this;
    };
    this.storageKey = storageKey;

    /**
     * @name pascalprecht.translate.$translateProvider#statefulFilter
     */
    this.statefulFilter = function (state) {
      if (state === undefined) {
        // getter
        return statefulFilter;
      } else {
        // setter with chaining
        statefulFilter = state;
        return this;
      }
    };

    /**
     * @name cloudwiz.translate.$translateProvider#use
     */
    this.use = function (langKey) {
      if (langKey) {
        if (!$translationTable[langKey] && (!$loaderFactory)) {
          // only throw an error, when not loading translation data asynchronously
          throw new Error('$translateProvider couldn\'t find translationTable for langKey: \'' + langKey + '\'');
        }
        $uses = langKey;
        return this;
      }
      return $uses;
    };

    /**
     * @name cloudwiz.translate.$translateProvider#useStorage
     */
    this.useStorage = function (storageFactory) {
      $storageFactory = storageFactory;
      return this;
    };

    /**
     * @name cloudwiz.translate.$translateProvider#useLocalStorage
     */
    this.useLocalStorage = function () {
      return this.useStorage('$translateLocalStorage');
    };

    /**
     * @name cloudwiz.translate.$translateProvider#translations
     */
    var translations = function (langKey, translationTable) {
      if (!langKey && !translationTable) {
        return $translationTable;
      }

      if (langKey && !translationTable) {
        if (angular.isString(langKey)) {
          return $translationTable[langKey];
        }
      } else {
        if (!angular.isObject($translationTable[langKey])) {
          $translationTable[langKey] = {};
        }
        angular.extend($translationTable[langKey], flatObject(translationTable));
      }
      return this;
    };
    this.translations = translations;

    /**
     * @name cloudwiz.translate.$translate
     */
    this.$get = function ($injector, $rootScope, $q) {
      var Storage,
        defaultInterpolator = $injector.get($interpolationFactory || '$translateDefaultInterpolation'),
        pendingLoader = false,
        interpolatorHashMap = {},
        langPromises = {},
        fallbackIndex,
        startFallbackIteration;

      var applyPostProcessing = function (translationId, translation, resolvedTranslation, interpolateParams, uses, sanitizeStrategy) {
        var fn = postProcessFn;

        if (fn) {
          if (typeof(fn) === 'string') {
            // getting on-demand instance
            fn = $injector.get(fn);
          }
          if (fn) {
            return fn(translationId, translation, resolvedTranslation, interpolateParams, uses, sanitizeStrategy);
          }
        }

        return resolvedTranslation;
      };

      var getTranslationTable = function (langKey) {
        var deferred = $q.defer();
        if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {
          deferred.resolve($translationTable[langKey]);
        } else if (langPromises[langKey]) {
          var onResolve = function (data) {
            translations(data.key, data.table);
            deferred.resolve(data.table);
          };
          langPromises[langKey].then(onResolve, deferred.reject);
        } else {
          deferred.reject();
        }
        return deferred.promise;
      };

      var getFallbackTranslation = function (langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy) {
        var deferred = $q.defer();

        var onResolve = function (translationTable) {
          if (Object.prototype.hasOwnProperty.call(translationTable, translationId) && translationTable[translationId] !== null) {
            Interpolator.setLocale(langKey);
            var translation = translationTable[translationId];
            if (translation.substr(0, 2) === '@:') {
              getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator, sanitizeStrategy)
                .then(deferred.resolve, deferred.reject);
            } else {
              var interpolatedValue = Interpolator.interpolate(translationTable[translationId], interpolateParams, 'service', sanitizeStrategy, translationId);
              interpolatedValue = applyPostProcessing(translationId, translationTable[translationId], interpolatedValue, interpolateParams, langKey);

              deferred.resolve(interpolatedValue);

            }
            Interpolator.setLocale($uses);
          } else {
            deferred.reject();
          }
        };

        getTranslationTable(langKey).then(onResolve, deferred.reject);

        return deferred.promise;
      };

      var translateByHandler = function (translationId, interpolateParams, defaultTranslationText, sanitizeStrategy) {
        // If we have a handler factory - we might also call it here to determine if it provides
        // a default text for a translationid that can't be found anywhere in our tables
        if ($missingTranslationHandlerFactory) {
          return $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams, defaultTranslationText, sanitizeStrategy);
        } else {
          return translationId;
        }
      };

      var resolveForFallbackLanguage = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy) {
        var deferred = $q.defer();

        if (fallbackLanguageIndex < $fallbackLanguage.length) {
          var langKey = $fallbackLanguage[fallbackLanguageIndex];
          getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy).then(
            function (data) {
              deferred.resolve(data);
            },
            function () {
              // Look in the next fallback language for a translation.
              // It delays the resolving by passing another promise to resolve.
              return resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy).then(deferred.resolve, deferred.reject);
            }
          );
        } else {
          // No translation found in any fallback language
          // if a default translation text is set in the directive, then return this as a result
          if (defaultTranslationText) {
            deferred.resolve(defaultTranslationText);
          } else {
            var missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, defaultTranslationText);

            // if no default translation is set and an error handler is defined, send it to the handler
            // and then return the result if it isn't undefined
            if ($missingTranslationHandlerFactory && missingTranslationHandlerTranslation) {
              deferred.resolve(missingTranslationHandlerTranslation);
            } else {
              // deferred.reject(applyNotFoundIndicators(translationId));
            }
          }
        }
        return deferred.promise;
      };

      var fallbackTranslation = function (translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy) {
        // Start with the fallbackLanguage with index 0
        return resolveForFallbackLanguage((startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy);
      };

      var determineTranslation = function (translationId, interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy) {
        var deferred = $q.defer();

        var table = uses ? $translationTable[uses] : $translationTable,
          Interpolator = (interpolationId) ? interpolatorHashMap[interpolationId] : defaultInterpolator;

        // if the translation id exists, we can just interpolate it
        if (table && Object.prototype.hasOwnProperty.call(table, translationId) && table[translationId] !== null) {
          var translation = table[translationId];

          // If using link, rerun $translate with linked translationId and return it
          if (translation.substr(0, 2) === '@:') {

            $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy)
              .then(deferred.resolve, deferred.reject);
          } else {
            //
            var resolvedTranslation = Interpolator.interpolate(translation, interpolateParams, 'service', sanitizeStrategy, translationId);
            resolvedTranslation = applyPostProcessing(translationId, translation, resolvedTranslation, interpolateParams, uses);
            deferred.resolve(resolvedTranslation);
          }
        } else {
          var missingTranslationHandlerTranslation;
          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise
          if ($missingTranslationHandlerFactory && !pendingLoader) {
            // missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, defaultTranslationText);
          }

          // since we couldn't translate the inital requested translation id,
          // we try it now with one or more fallback languages, if fallback language(s) is
          // configured.
          if (uses && $fallbackLanguage && $fallbackLanguage.length) {
            fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy)
              .then(function (translation) {
                deferred.resolve(translation);
              }, function (_translationId) {
                // deferred.reject(applyNotFoundIndicators(_translationId));
              });
          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
            // looks like the requested translation id doesn't exists.
            // Now, if there is a registered handler for missing translations and no
            // asyncLoader is pending, we execute the handler
            if (defaultTranslationText) {
              deferred.resolve(defaultTranslationText);
            } else {
              deferred.resolve(missingTranslationHandlerTranslation);
            }
          } else {
            if (defaultTranslationText) {
              deferred.resolve(defaultTranslationText);
            } else {
              // deferred.reject(applyNotFoundIndicators(translationId));
            }
          }
        }
        return deferred.promise;
      };

      var determineTranslationInstant = function (translationId, interpolateParams, interpolationId, uses, sanitizeStrategy) {
        var result, table = uses ? $translationTable[uses] : $translationTable,
          Interpolator = defaultInterpolator;

        // if the interpolation id exists use custom interpolator
        if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId)) {
          Interpolator = interpolatorHashMap[interpolationId];
        }

        // if the translation id exists, we can just interpolate it
        if (table && Object.prototype.hasOwnProperty.call(table, translationId) && table[translationId] !== null) {
          var translation = table[translationId];

          // If using link, rerun $translate with linked translationId and return it
          if (translation.substr(0, 2) === '@:') {
            result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId, uses, sanitizeStrategy);
          } else {
            result = Interpolator.interpolate(translation, interpolateParams, 'filter', sanitizeStrategy, translationId);
            result = applyPostProcessing(translationId, translation, result, interpolateParams, uses, sanitizeStrategy);
          }
        } else {
          var missingTranslationHandlerTranslation;
          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise
          if ($missingTranslationHandlerFactory && !pendingLoader) {
            // missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, sanitizeStrategy);
          }

          // since we couldn't translate the inital requested translation id,
          // we try it now with one or more fallback languages, if fallback language(s) is
          // configured.
          if (uses && $fallbackLanguage && $fallbackLanguage.length) {
            fallbackIndex = 0;
            result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator, sanitizeStrategy);
          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
            // looks like the requested translation id doesn't exists.
            // Now, if there is a registered handler for missing translations and no
            // asyncLoader is pending, we execute the handler
            result = missingTranslationHandlerTranslation;
          } else {
            result = applyNotFoundIndicators(translationId);
          }
        }

        return result;
      };

      /**
       * @name the returened
       */
      var $translate = function (translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage, sanitizeStrategy) {
        if (!$uses && $preferredLanguage) {
          $uses = $preferredLanguage;
        }
        var uses = $uses;

        // Duck detection: If the first argument is an array, a bunch of translations was requested.
        // The result is an object.
        if (angular.isArray(translationId)) {
          // This transforms all promises regardless resolved or rejected
          var translateAll = function (translationIds) {
            var results = {}; // storing the actual results
            var promises = []; // promises to wait for
            // Wraps the promise a) being always resolved and b) storing the link id->value
            var translate = function (translationId) {
              var deferred = $q.defer();
              var regardless = function (value) {
                results[translationId] = value;
                deferred.resolve([translationId, value]);
              };
              // we don't care whether the promise was resolved or rejected; just store the values
              $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage, sanitizeStrategy).then(regardless, regardless);
              return deferred.promise;
            };
            for (var i = 0, c = translationIds.length; i < c; i++) {
              promises.push(translate(translationIds[i]));
            }
            // wait for all (including storing to results)
            return $q.all(promises).then(function () {
              return results;
            });
          };
          return translateAll(translationId);
        }

        var deferred = $q.defer();

        // trim off any whitespace
        if (translationId) {
          translationId = util.trim(translationId);
        }

        var promiseToWaitFor = (function () {
          var promise = langPromises[uses] || langPromises[$preferredLanguage];

          fallbackIndex = 0;

          if ($storageFactory && !promise) {
            // looks like there's no pending promise for $preferredLanguage or
            // $uses. Maybe there's one pending for a language that comes from
            // storage.
            var langKey = Storage.get($storageKey);
            promise = langPromises[langKey];

            if ($fallbackLanguage && $fallbackLanguage.length) {
              var index = util.indexOf($fallbackLanguage, langKey);
              // maybe the language from storage is also defined as fallback language
              // we increase the fallback language index to not search in that language
              // as fallback, since it's probably the first used language
              // in that case the index starts after the first element
              fallbackIndex = (index === 0) ? 1 : 0;

              // but we can make sure to ALWAYS fallback to preferred language at least
              if (util.indexOf($fallbackLanguage, $preferredLanguage) < 0) {
                $fallbackLanguage.push($preferredLanguage);
              }
            }
          }
          return promise;
        }());

        if (!promiseToWaitFor) {
          // no promise to wait for? okay. Then there's no loader registered
          // nor is a one pending for language that comes from storage.
          // We can just translate.
          determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy).then(deferred.resolve, deferred.reject);
        } else {
          var promiseResolved = function () {
            // $uses may have changed while waiting
            if (!forceLanguage) {
              uses = $uses;
            }
            determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy).then(deferred.resolve, deferred.reject);
          };

          promiseToWaitFor['finally'](promiseResolved)['catch'](angular.noop); // we don't care about errors here, already handled
        }
        return deferred.promise;
      };

      /**
       * @name loadAsync
       */
      var loadAsync = function (key) {
        if (!key) { throw 'No language key specified for loading.'; }

        var deferred = $q.defer();

        $rootScope.$emit('$translateLoadingStart', {language : key});
        pendingLoader = true;

        var cache = loaderCache;
        if (typeof(cache) === 'string') {
          // getting on-demand instance of loader
          cache = $injector.get(cache);
        }

        var loaderOptions = angular.extend({}, $loaderOptions, {
          key : key,
          $http : angular.extend({}, {
            cache : cache
          }, $loaderOptions.$http)
        });

        var onLoaderSuccess = function (data) {
          var translationTable = {};
          $rootScope.$emit('$translateLoadingSuccess', {language : key});

          if (angular.isArray(data)) {
            angular.forEach(data, function (table) {
              angular.extend(translationTable, flatObject(table));
            });
          } else {
            angular.extend(translationTable, flatObject(data));
          }
          pendingLoader = false;
          deferred.resolve({
            key : key,
            table : translationTable
          });

          $translate.i18n = translationTable;
          $rootScope.$emit('$translateLoadingEnd', {language : key});
        };

        var onLoaderError = function (key) {
          $rootScope.$emit('$translateLoadingError', {language : key});
          deferred.reject(key);
          $rootScope.$emit('$translateLoadingEnd', {language : key});
        };
        $injector.get($loaderFactory)(loaderOptions).then(onLoaderSuccess, onLoaderError);

        return deferred.promise;
      };

      /**
       * @name cloudwiz.translate.$translate#preferredLanguage
       */
      $translate.preferredLanguage = function (langKey) {
        if (langKey) {
          setupPreferredLanguage(langKey);
        }
        return $preferredLanguage;
      };

      /**
       * @name useLanguage
       */
      var useLanguage = function (key) {
        $uses = key;

        // make sure to store new language key before triggering success event
        if ($storageFactory) {
          Storage.put($translate.storageKey(), $uses);
        }

        $rootScope.$emit('$translateChangeSuccess', {language : key});

        // inform default interpolator
        defaultInterpolator.setLocale($uses);

        var eachInterpolator = function (interpolator, id) {
          interpolatorHashMap[id].setLocale($uses);
        };

        // inform all others too!
        angular.forEach(interpolatorHashMap, eachInterpolator);
        $rootScope.$emit('$translateChangeEnd', {language : key});
      };

      var clearNextLangAndPromise = function (key) {
        if ($nextLang === key) {
          $nextLang = undefined;
        }
        langPromises[key] = undefined;
      };

      // internal purpose only
      $translate.statefulFilter = function () {
        return statefulFilter;
      };

      /**
       * @name cloudwiz.translate.$translate#use
       */
      $translate.use = function (key) {
        if (!key) { return $uses; }

        var deferred = $q.defer();
        deferred.promise.then(null, angular.noop); // AJS "Possibly unhandled rejection"

        $rootScope.$emit('$translateChangeStart', {language : key});

        // if there isn't a translation table for the language we've requested,
        // we load it asynchronously
        $nextLang = key;
        if (!$translationTable[key] && $loaderFactory && !langPromises[key]) {
          langPromises[key] = loadAsync(key).then(function (translation) {
            translations(translation.key, translation.table);
            deferred.resolve(translation.key);
            if ($nextLang === key) {
              useLanguage(translation.key);
            }
            return translation;
          }, function (key) {
            $rootScope.$emit('$translateChangeError', {language : key});
            deferred.reject(key);
            $rootScope.$emit('$translateChangeEnd', {language : key});
            return $q.reject(key);
          });
          langPromises[key]['finally'](function () {
            clearNextLangAndPromise(key);
          })['catch'](angular.noop); // we don't care about errors (clearing)
        } else if (langPromises[key]) {
          // we are already loading this asynchronously
          // resolve our new deferred when the old langPromise is resolved
          langPromises[key].then(function (translation) {
            if ($nextLang === translation.key) {
              useLanguage(translation.key);
            }
            deferred.resolve(translation.key);
            return translation;
          }, function (key) {
            // find first available fallback language if that request has failed
            if (!$uses && $fallbackLanguage && $fallbackLanguage.length > 0 && $fallbackLanguage[0] !== key) {
              return $translate['use']($fallbackLanguage[0]).then(deferred.resolve, deferred.reject);
            } else {
              return deferred.reject(key);
            }
          });
        } else {
          deferred.resolve(key);
          useLanguage(key);
        }

        return deferred.promise;
      };

      /**
       * @name cloudwiz.translate.$translate#isPostCompilingEnabled
       */
      $translate.isPostCompilingEnabled = function () {
        return $postCompilingEnabled;
      };

      /**
       * @name cloudwiz.translate.$translate#storage
       */
      $translate.storage = function () {
        return Storage;
      };

      /**
       * @name cloudwiz.translate.$translate#storageKey
       */
      $translate.storageKey = function () {
        return storageKey();
      };

      /**
       * @name pascalprecht.translate.$translate#instant
       */
      $translate.instant = function (translationId, interpolateParams, interpolationId, forceLanguage, sanitizeStrategy) {
        // we don't want to re-negotiate $uses
        // var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses
        //   (negotiateLocale(forceLanguage) || forceLanguage) : $uses;
        var uses = $uses;

        // Detect undefined and null values to shorten the execution and prevent exceptions
        if (translationId === null || angular.isUndefined(translationId)) {
          return translationId;
        }

        // Duck detection: If the first argument is an array, a bunch of translations was requested.
        // The result is an object.
        if (angular.isArray(translationId)) {
          var results = {};
          for (var i = 0, c = translationId.length; i < c; i++) {
            results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId, forceLanguage, sanitizeStrategy);
          }
          return results;
        }

        // We discarded unacceptable values. So we just need to verify if translationId is empty String
        if (angular.isString(translationId) && translationId.length < 1) {
          return translationId;
        }

        // trim off any whitespace
        if (translationId) {
          translationId = util.trim(translationId);
        }

        var result, possibleLangKeys = [];
        if ($preferredLanguage) {
          possibleLangKeys.push($preferredLanguage);
        }
        if (uses) {
          possibleLangKeys.push(uses);
        }
        if ($fallbackLanguage && $fallbackLanguage.length) {
          possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);
        }
        for (var j = 0, d = possibleLangKeys.length; j < d; j++) {
          var possibleLangKey = possibleLangKeys[j];
          if ($translationTable[possibleLangKey]) {
            if (typeof $translationTable[possibleLangKey][translationId] !== 'undefined') {
              result = determineTranslationInstant(translationId, interpolateParams, interpolationId, uses, sanitizeStrategy);
            }
          }
          if (typeof result !== 'undefined') {
            break;
          }
        }
  
        if (!result && result !== '') {
          if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {
            throw Error('Not found indicator left or right');
            // result = applyNotFoundIndicators(translationId);
          } else {
            // Return translation of default interpolator if not found anything.
            result = defaultInterpolator.interpolate(translationId, interpolateParams, 'filter', sanitizeStrategy);
  
            // looks like the requested translation id doesn't exists.
            // Now, if there is a registered handler for missing translations and no
            // asyncLoader is pending, we execute the handler
            var missingTranslationHandlerTranslation;
            if ($missingTranslationHandlerFactory && !pendingLoader) {
              // missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, sanitizeStrategy);
            }
  
            if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
              result = missingTranslationHandlerTranslation;
            }
          }
        }
  
        return result;
      };

      if ($storageFactory) {
        Storage = $injector.get($storageFactory);

        if (!Storage.get || !Storage.put) {
          throw new Error('Couldn\'t use storage \'' + $storageFactory + '\', missing get() or put() method!');
        }
      }

      if ($loaderFactory) {
        // If at least one async loader is defined and there are no
        // (default) translations available we should try to load them.
        if (angular.equals($translationTable, {})) {
          if ($translate.use()) {
            $translate.use($translate.use());
          }
        }

        // Also, if there are any fallback language registered, we start
        // loading them asynchronously as soon as we can.
        if ($fallbackLanguage && $fallbackLanguage.length) {
          var processAsyncResult = function (translation) {
            translations(translation.key, translation.table);
            $rootScope.$emit('$translateChangeEnd', {language : translation.key});
            return translation;
          };
          for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
            var fallbackLanguageId = $fallbackLanguage[i];
            if (!$translationTable[fallbackLanguageId]) {
              langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult);
            }
          }
        }
      } else {
        $rootScope.$emit('$translateReady', {language : $translate.use()});
      }

      return $translate;
    };
  }];
  angular.module('cloudwiz.translate').provider('$translate', $translateProvider);

  /**
   * @name cloudwiz.translate.$translateStaticFilesLoader
   */
  angular.module('cloudwiz.translate').factory('$translateStaticFilesLoader', ['$q', '$http', function ($q, $http) {
    return function (options) {
      if (!options || (!angular.isArray(options.files) && (!angular.isString(options.prefix) || !angular.isString(options.suffix)))) {
        throw new Error('Couldn\'t load static files, no files and prefix or suffix specified!');
      }

      if (!options.files) {
        options.files = [{
          prefix: options.prefix,
          suffix: options.suffix
        }];
      }

      var load = function (file) {
        if (!file || (!angular.isString(file.prefix) || !angular.isString(file.suffix))) {
          throw new Error('Couldn\'t load static file, no prefix or suffix specified!');
        }

        var fileUrl = [
          file.prefix,
          options.key,
          file.suffix
        ].join('');

        if (angular.isObject(options.fileMap) && options.fileMap[fileUrl]) {
          fileUrl = options.fileMap[fileUrl];
        }

        return $http(angular.extend({
          url: fileUrl,
          method: 'GET'
        }, options.$http))
          .then(function (result) {
            return result.data;
          }, function () {
            return $q.reject(options.key);
          });
      };

      var promises = [], length = options.files.length;

      for (var i = 0; i < length; i++) {
        promises.push(load({
          prefix: options.files[i].prefix,
          key: options.key,
          suffix: options.files[i].suffix
        }));
      }

      return $q.all(promises).then(function (data) {
        var length = data.length, mergedData = {};
        for (var i = 0; i < length; i++) {
          for (var key in data[i]) {
            mergedData[key] = data[i][key];
          }
        }
        return mergedData;
      });
    };
  }]);

  angular.module('cloudwiz.translate').factory('$translateDefaultInterpolation', ['$interpolate', function ($interpolate) {
    var $translateInterpolator = {},
        $locale,
        $identifier = 'default';

    $translateInterpolator.setLocale = function (locale) {
      $locale = locale;
    };

    $translateInterpolator.getInterpolationIdentifier = function () {
      return $identifier;
    };

    $translateInterpolator.interpolate = function (value, interpolationParams, context, sanitizeStrategy, translationId) {
      interpolationParams = interpolationParams || {};
      // interpolationParams = $translateSanitization.sanitize(interpolationParams, 'params', sanitizeStrategy, context);

      var interpolatedText;
      if (angular.isNumber(value)) {
        // numbers are safe
        interpolatedText = String(value);
      } else if (angular.isString(value)) {
        // strings must be interpolated (that's the job here)
        interpolatedText = $interpolate(value)(interpolationParams);
        // interpolatedText = $translateSanitization.sanitize(interpolatedText, 'text', sanitizeStrategy, context);
      } else {
        // neither a number or a string, cant interpolate => empty string
        interpolatedText = '';
      }

      return interpolatedText;
    };

    return $translateInterpolator;
  }]);

  ////////
  // Directive
  ////////
  angular.module('cloudwiz.translate').directive('translate', function ($translate, $interpolate, $compile, $parse, $rootScope) {

    return {
      restrict: 'AE',
      scope: true,
      compile: function (tElement, tAttr) {

        var translateValuesExist = (tAttr.translateValues) ?
          tAttr.translateValues : undefined;

        var translateInterpolation = (tAttr.translateInterpolation) ?
          tAttr.translateInterpolation : undefined;

        var translateSanitizeStrategyExist = (tAttr.translateSanitizeStrategy) ?
          tAttr.translateSanitizeStrategy : undefined;

        var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);

        var interpolateRegExp = '^(.*)(' + $interpolate.startSymbol() + '.*' + $interpolate.endSymbol() + ')(.*)',
            watcherRegExp = '^(.*)' + $interpolate.startSymbol() + '(.*)' + $interpolate.endSymbol() + '(.*)';

        return function linkFn(scope, iElement, iAttr) {
          scope.interpolateParams = {};
          scope.preText = '';
          scope.postText = '';
          var translationIds = {};

          var initInterpolationParams = function (interpolateParams, iAttr, tAttr) {
            // initial setup
            if (iAttr.translateValues) {
              angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent));
            }
            // initially fetch all attributes if existing and fill the params
            if (translateValueExist) {
              for (var attr in tAttr) {
                if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {
                  var attributeName = util.lowercase(attr.substr(14, 1)) + attr.substr(15);
                  interpolateParams[attributeName] = tAttr[attr];
                }
              }
            }
          };

          var applyTranslation = function (value, scope, successful, translateAttr) {
            if (!successful) {
              if (typeof scope.defaultText !== 'undefined') {
                value = scope.defaultText;
              }
            }
            if (translateAttr === 'translate') {
              // default translate into innerHTML
              if (successful || (!successful && !$translate.isKeepContent() && typeof iAttr.translateKeepContent === 'undefined')) {
                iElement.empty().append(scope.preText + value + scope.postText);
              }
              var globallyEnabled = $translate.isPostCompilingEnabled();
              var locallyDefined = typeof tAttr.translateCompile !== 'undefined';
              var locallyEnabled = locallyDefined && tAttr.translateCompile !== 'false';
              if ((globallyEnabled && !locallyDefined) || locallyEnabled) {
                $compile(iElement.contents())(scope);
              }
            } else {
              // translate attribute
              var attributeName = iAttr.$attr[translateAttr];
              if (attributeName.substr(0, 5) === 'data-') {
                // ensure html5 data prefix is stripped
                attributeName = attributeName.substr(5);
              }
              attributeName = attributeName.substr(15);
              iElement.attr(attributeName, value);
            }
          };

          // Put translation processing function outside loop
          var updateTranslation = function (translateAttr, translationId, scope, interpolateParams, defaultTranslationText) {
            if (translationId) {
              $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText, scope.translateLanguage, scope.sanitizeStrategy)
                .then(function (translation) {
                  applyTranslation(translation, scope, true, translateAttr);
                }, function (translationId) {
                  applyTranslation(translationId, scope, false, translateAttr);
                });
            } else {
              // as an empty string cannot be translated, we can solve this using successful=false
              applyTranslation(translationId, scope, false, translateAttr);
            }
          };

          // Master update function
          var updateTranslations = function () {
            for (var key in translationIds) {
              if (translationIds.hasOwnProperty(key) && translationIds[key] !== undefined) {
                updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText);
              }
            }
          };

          // Ensures any change of the attribute "translate" containing the id will
          // be re-stored to the scope's "translationId".
          // If the attribute has no content, the element's text value (white spaces trimmed off) will be used.
          var observeElementTranslation = function (translationId) {

            // Remove any old watcher
            if (angular.isFunction(observeElementTranslation._unwatchOld)) {
              observeElementTranslation._unwatchOld();
              observeElementTranslation._unwatchOld = undefined;
            }

            if (angular.equals(translationId , '') || !angular.isDefined(translationId)) {
              var iElementText = util.trim(iElement.text());

              // Resolve translation id by inner html if required
              var interpolateMatches = iElementText.match(interpolateRegExp);
              // Interpolate translation id if required
              if (angular.isArray(interpolateMatches)) {
                scope.preText = interpolateMatches[1];
                scope.postText = interpolateMatches[3];
                translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);
                var watcherMatches = iElementText.match(watcherRegExp);
                if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {
                  observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function (newValue) {
                    translationIds.translate = newValue;
                    updateTranslations();
                  });
                }
              } else {
                // do not assigne the translation id if it is empty.
                translationIds.translate = !iElementText ? undefined : iElementText;
              }
            } else {
              translationIds.translate = translationId;
            }
            updateTranslations();
          };

          var observeAttributeTranslation = function (translateAttr) {
            iAttr.$observe(translateAttr, function (translationId) {
              translationIds[translateAttr] = translationId;
              updateTranslations();
            });
          };

          // initial setup with values
          initInterpolationParams(scope.interpolateParams, iAttr, tAttr);

          var firstAttributeChangedEvent = true;
          iAttr.$observe('translate', function (translationId) {
            if (typeof translationId === 'undefined') {
              // case of element "<translate>xyz</translate>"
              observeElementTranslation('');
            } else {
              // case of regular attribute
              if (translationId !== '' || !firstAttributeChangedEvent) {
                translationIds.translate = translationId;
                updateTranslations();
              }
            }
            firstAttributeChangedEvent = false;
          });

          for (var translateAttr in iAttr) {
            if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === 'translateAttr' && translateAttr.length > 13) {
              observeAttributeTranslation(translateAttr);
            }
          }

          iAttr.$observe('translateDefault', function (value) {
            scope.defaultText = value;
            updateTranslations();
          });

          if (translateSanitizeStrategyExist) {
            iAttr.$observe('translateSanitizeStrategy', function (value) {
              scope.sanitizeStrategy = $parse(value)(scope.$parent);
              updateTranslations();
            });
          }

          if (translateValuesExist) {
            iAttr.$observe('translateValues', function (interpolateParams) {
              if (interpolateParams) {
                scope.$parent.$watch(function () {
                  angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));
                });
              }
            });
          }

          if (translateValueExist) {
            var observeValueAttribute = function (attrName) {
              iAttr.$observe(attrName, function (value) {
                var attributeName = util.lowercase(attrName.substr(14, 1)) + attrName.substr(15);
                scope.interpolateParams[attributeName] = value;
              });
            };
            for (var attr in iAttr) {
              if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {
                observeValueAttribute(attr);
              }
            }
          }

          if (translateValuesExist || translateValueExist || iAttr.translateDefault) {
            scope.$watch('interpolateParams', updateTranslations, true);
          }

          // Replaced watcher on translateLanguage with event listener
          scope.$on('translateLanguageChanged', updateTranslations);

          // Ensures the text will be refreshed after the current language was changed
          // w/ $translate.use(...)
          var unbind = $rootScope.$on('$translateChangeSuccess', updateTranslations);

          // ensure translation will be looked up at least one
          if (iElement.text().length) {
            if (iAttr.translate) {
              observeElementTranslation(iAttr.translate);
            } else {
              observeElementTranslation('');
            }
          } else if (iAttr.translate) {
            // ensure attribute will be not skipped
            observeElementTranslation(iAttr.translate);
          }
          updateTranslations();
          scope.$on('$destroy', unbind);
        };
      }
    };
  });

  ////////
  // filter
  ////////
  angular.module('cloudwiz.translate').filter('translate', function ($parse, $translate) {
    var translateFilter = function (translationId, interpolateParams, interpolation, forceLanguage) {
      if (!angular.isObject(interpolateParams)) {
        var ctx = this;
        interpolateParams = $parse(interpolateParams)(ctx);
      }
  
      return $translate.instant(translationId, interpolateParams, interpolation, forceLanguage);
    };
  
    if ($translate.statefulFilter()) {
      translateFilter.$stateful = true;
    }
  
    return translateFilter;
  });

  ////////
  // Storage
  ////////
  angular.module('cloudwiz.translate').constant('$STORAGE_KEY', 'CLOUDWIZ_LANG_KEY');
  angular.module('cloudwiz.translate').factory('$translateLocalStorage', ['$window', function ($window) {
    var localStorageAdapter = (function () {
      var langKey;
      return {
        get: function (name) {
          if (!langKey) {
            langKey = $window.localStorage.getItem(name);
          }
          return langKey;
        },
        set: function (name, value) {
          langKey = value;
          $window.localStorage.setItem(name, value);
        },
        put: function (name, value) {
          langKey = value;
          $window.localStorage.setItem(name, value);
        }
      };
    }());

    var $translateLocalStorage = localStorageAdapter;
    return $translateLocalStorage;
  }]);

})(window, window.angular);


/***/ }),

/***/ 93:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
var kbn = {};
kbn.valueFormats = {};
///// HELPER FUNCTIONS /////
kbn.round_interval = function (interval) {
    switch (true) {
        // 0.3s
        case (interval <= 300):
            return 100; // 0.1s
        // 0.75s
        case (interval <= 750):
            return 500; // 0.5s
        // 1.5s
        case (interval <= 1500):
            return 1000; // 1s
        // 3.5s
        case (interval <= 3500):
            return 2000; // 2s
        // 7.5s
        case (interval <= 7500):
            return 5000; // 5s
        // 12.5s
        case (interval <= 12500):
            return 10000; // 10s
        // 17.5s
        case (interval <= 17500):
            return 15000; // 15s
        // 25s
        case (interval <= 25000):
            return 20000; // 20s
        // 45s
        case (interval <= 45000):
            return 30000; // 30s
        // 1.5m
        case (interval <= 90000):
            return 60000; // 1m
        // 3.5m
        case (interval <= 210000):
            return 120000; // 2m
        // 7.5m
        case (interval <= 450000):
            return 300000; // 5m
        // 12.5m
        case (interval <= 750000):
            return 600000; // 10m
        // 12.5m
        case (interval <= 1050000):
            return 900000; // 15m
        // 25m
        case (interval <= 1500000):
            return 1200000; // 20m
        // 45m
        case (interval <= 2700000):
            return 1800000; // 30m
        // 1.5h
        case (interval <= 5400000):
            return 3600000; // 1h
        // 2.5h
        case (interval <= 9000000):
            return 7200000; // 2h
        // 4.5h
        case (interval <= 16200000):
            return 10800000; // 3h
        // 9h
        case (interval <= 32400000):
            return 21600000; // 6h
        // 24h
        case (interval <= 86400000):
            return 43200000; // 12h
        // 48h
        case (interval <= 172800000):
            return 86400000; // 24h
        // 1w
        case (interval <= 604800000):
            return 86400000; // 24h
        // 3w
        case (interval <= 1814400000):
            return 604800000; // 1w
        // 2y
        case (interval < 3628800000):
            return 2592000000; // 30d
        default:
            return 31536000000; // 1y
    }
};
kbn.secondsToHms = function (seconds) {
    var numyears = Math.floor(seconds / 31536000);
    if (numyears) {
        return numyears + 'y';
    }
    var numdays = Math.floor((seconds % 31536000) / 86400);
    if (numdays) {
        return numdays + 'd';
    }
    var numhours = Math.floor(((seconds % 31536000) % 86400) / 3600);
    if (numhours) {
        return numhours + 'h';
    }
    var numminutes = Math.floor((((seconds % 31536000) % 86400) % 3600) / 60);
    if (numminutes) {
        return numminutes + 'm';
    }
    var numseconds = Math.floor((((seconds % 31536000) % 86400) % 3600) % 60);
    if (numseconds) {
        return numseconds + 's';
    }
    var nummilliseconds = Math.floor(seconds * 1000.0);
    if (nummilliseconds) {
        return nummilliseconds + 'ms';
    }
    return 'less then a millisecond'; //'just now' //or other string you like;
};
kbn.to_percent = function (nr, outof) {
    return Math.floor(nr / outof * 10000) / 100 + '%';
};
kbn.addslashes = function (str) {
    str = str.replace(/\\/g, '\\\\');
    str = str.replace(/\'/g, '\\\'');
    str = str.replace(/\"/g, '\\"');
    str = str.replace(/\0/g, '\\0');
    return str;
};
kbn.interval_regex = /(\d+(?:\.\d+)?)([Mwdhmsy])/;
// histogram & trends
kbn.intervals_in_seconds = {
    y: 31536000,
    M: 2592000,
    w: 604800,
    d: 86400,
    h: 3600,
    m: 60,
    s: 1
};
kbn.calculateInterval = function (range, resolution, userInterval) {
    var lowLimitMs = 1; // 1 millisecond default low limit
    var intervalMs, lowLimitInterval;
    if (userInterval) {
        if (userInterval[0] === '>') {
            lowLimitInterval = userInterval.slice(1);
            lowLimitMs = kbn.interval_to_ms(lowLimitInterval);
        }
        else {
            return userInterval;
        }
    }
    intervalMs = kbn.round_interval((range.to.valueOf() - range.from.valueOf()) / resolution);
    if (lowLimitMs > intervalMs) {
        intervalMs = lowLimitMs;
    }
    return kbn.secondsToHms(intervalMs / 1000);
};
kbn.describe_interval = function (str) {
    var matches = str.match(kbn.interval_regex);
    if (!matches || !kbn.intervals_in_seconds.hasOwnProperty(matches[2])) {
        // if (!matches || !_.has(kbn.intervals_in_seconds, matches[2])) {
        throw new Error('Invalid interval string, expecting a number followed by one of "Mwdhmsy"');
    }
    else {
        return {
            sec: kbn.intervals_in_seconds[matches[2]],
            type: matches[2],
            count: parseInt(matches[1], 10)
        };
    }
};
kbn.interval_to_ms = function (str) {
    var info = kbn.describe_interval(str);
    return info.sec * 1000 * info.count;
};
kbn.interval_to_seconds = function (str) {
    var info = kbn.describe_interval(str);
    return info.sec * info.count;
};
kbn.query_color_dot = function (color, diameter) {
    return '<div class="icon-circle" style="' + [
        'display:inline-block',
        'color:' + color,
        'font-size:' + diameter + 'px',
    ].join(';') + '"></div>';
};
kbn.slugifyForUrl = function (str) {
    return str
        .toLowerCase()
        .replace(/[^\w ]+/g, '')
        .replace(/ +/g, '-');
};
// kbn.exportSeriesListToCsv = function(seriesList) {
//   var text = 'Series;Time;Value\n';
//   _.each(seriesList, function(series) {
//     _.each(series.datapoints, function(dp) {
//       text += series.alias + ';' + new Date(dp[1]).toISOString() + ';' + dp[0] + '\n';
//     });
//   });
//   var blob = new Blob([text], { type: "text/csv;charset=utf-8" });
//   window.saveAs(blob, 'cloudwiz_data_export.csv');
// };
kbn.stringToJsRegex = function (str) {
    if (str[0] !== '/') {
        return new RegExp('^' + str + '$');
    }
    var match = str.match(new RegExp('^/(.*?)/(g?i?m?y?)$'));
    return new RegExp(match[1], match[2]);
};
kbn.toFixed = function (value, decimals) {
    if (value === null) {
        return "";
    }
    var factor = decimals ? Math.pow(10, Math.max(0, decimals)) : 1;
    var formatted = String(Math.round(value * factor) / factor);
    // if exponent return directly
    if (formatted.indexOf('e') !== -1 || value === 0) {
        return formatted;
    }
    // If tickDecimals was specified, ensure that we have exactly that
    // much precision; otherwise default to the value's own precision.
    if (decimals !== null) {
        var decimalPos = formatted.indexOf(".");
        var precision = decimalPos === -1 ? 0 : formatted.length - decimalPos - 1;
        if (precision < decimals) {
            return (precision ? formatted : formatted + ".") + (String(factor)).substr(1, decimals - precision);
        }
    }
    return formatted;
};
kbn.toFixedScaled = function (value, decimals, scaledDecimals, additionalDecimals, ext) {
    if (scaledDecimals === null) {
        return kbn.toFixed(value, decimals) + ext;
    }
    else {
        return kbn.toFixed(value, scaledDecimals + additionalDecimals) + ext;
    }
};
kbn.roundValue = function (num, decimals) {
    if (num === null) {
        return null;
    }
    var n = Math.pow(10, decimals);
    var formatted = (n * num).toFixed(decimals);
    return Math.round(parseFloat(formatted)) / n;
};
///// FORMAT FUNCTION CONSTRUCTORS /////
kbn.formatBuilders = {};
// Formatter which always appends a fixed unit string to the value. No
// scaling of the value is performed.
kbn.formatBuilders.fixedUnit = function (unit) {
    return function (size, decimals) {
        if (size === null) {
            return "";
        }
        return kbn.toFixed(size, decimals) + ' ' + unit;
    };
};
// Formatter which scales the unit string geometrically according to the given
// numeric factor. Repeatedly scales the value down by the factor until it is
// less than the factor in magnitude, or the end of the array is reached.
kbn.formatBuilders.scaledUnits = function (factor, extArray) {
    return function (size, decimals, scaledDecimals) {
        if (size === null) {
            return "";
        }
        var steps = 0;
        var limit = extArray.length;
        while (Math.abs(size) >= factor) {
            steps++;
            size /= factor;
            if (steps >= limit) {
                return "NA";
            }
        }
        if (steps > 0 && scaledDecimals !== null) {
            decimals = scaledDecimals + (3 * steps);
        }
        return kbn.toFixed(size, decimals) + extArray[steps];
    };
};
// Extension of the scaledUnits builder which uses SI decimal prefixes. If an
// offset is given, it adjusts the starting units at the given prefix; a value
// of 0 starts at no scale; -3 drops to nano, +2 starts at mega, etc.
kbn.formatBuilders.decimalSIPrefix = function (unit, offset) {
    var prefixes = ['n', '', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];
    prefixes = prefixes.slice(3 + (offset || 0));
    var units = prefixes.map(function (p) { return ' ' + p + unit; });
    return kbn.formatBuilders.scaledUnits(1000, units);
};
// Extension of the scaledUnits builder which uses SI binary prefixes. If
// offset is given, it starts the units at the given prefix; otherwise, the
// offset defaults to zero and the initial unit is not prefixed.
kbn.formatBuilders.binarySIPrefix = function (unit, offset) {
    var prefixes = ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'].slice(offset);
    var units = prefixes.map(function (p) { return ' ' + p + unit; });
    return kbn.formatBuilders.scaledUnits(1024, units);
};
// Currency formatter for prefixing a symbol onto a number. Supports scaling
// up to the trillions.
kbn.formatBuilders.currency = function (symbol) {
    var units = ['', 'K', 'M', 'B', 'T'];
    var scaler = kbn.formatBuilders.scaledUnits(1000, units);
    return function (size, decimals, scaledDecimals) {
        if (size === null) {
            return "";
        }
        var scaled = scaler(size, decimals, scaledDecimals);
        return symbol + scaled;
    };
};
kbn.formatBuilders.simpleCountUnit = function (symbol) {
    var units = ['', 'K', 'M', 'B', 'T'];
    var scaler = kbn.formatBuilders.scaledUnits(1000, units);
    return function (size, decimals, scaledDecimals) {
        if (size === null) {
            return "";
        }
        var scaled = scaler(size, decimals, scaledDecimals);
        return scaled + " " + symbol;
    };
};
///// VALUE FORMATS /////
// Dimensionless Units
kbn.valueFormats.none = kbn.toFixed;
kbn.valueFormats.short = kbn.formatBuilders.scaledUnits(1000, ['', ' K', ' Mil', ' Bil', ' Tri', ' Quadr', ' Quint', ' Sext', ' Sept']);
kbn.valueFormats.dB = kbn.formatBuilders.fixedUnit('dB');
kbn.valueFormats.ppm = kbn.formatBuilders.fixedUnit('ppm');
kbn.valueFormats.percent = function (size, decimals) {
    if (size === null) {
        return "";
    }
    return kbn.toFixed(size, decimals) + '%';
};
kbn.valueFormats.percentunit = function (size, decimals) {
    if (size === null) {
        return "";
    }
    return kbn.toFixed(100 * size, decimals) + '%';
};
// Currencies
kbn.valueFormats.currencyUSD = kbn.formatBuilders.currency('$');
kbn.valueFormats.currencyGBP = kbn.formatBuilders.currency('');
kbn.valueFormats.currencyEUR = kbn.formatBuilders.currency('');
kbn.valueFormats.currencyJPY = kbn.formatBuilders.currency('');
// Data
kbn.valueFormats.bits = kbn.formatBuilders.binarySIPrefix('b');
kbn.valueFormats.bytes = kbn.formatBuilders.binarySIPrefix('B');
kbn.valueFormats.kbytes = kbn.formatBuilders.binarySIPrefix('B', 1);
kbn.valueFormats.mbytes = kbn.formatBuilders.binarySIPrefix('B', 2);
kbn.valueFormats.gbytes = kbn.formatBuilders.binarySIPrefix('B', 3);
// Data Rate
kbn.valueFormats.pps = kbn.formatBuilders.decimalSIPrefix('pps');
kbn.valueFormats.bps = kbn.formatBuilders.decimalSIPrefix('bps');
kbn.valueFormats.Bps = kbn.formatBuilders.decimalSIPrefix('Bps');
kbn.valueFormats.KBs = kbn.formatBuilders.decimalSIPrefix('Bs', 1);
kbn.valueFormats.Kbits = kbn.formatBuilders.decimalSIPrefix('bits', 1);
kbn.valueFormats.MBs = kbn.formatBuilders.decimalSIPrefix('Bs', 2);
kbn.valueFormats.Mbits = kbn.formatBuilders.decimalSIPrefix('bits', 2);
kbn.valueFormats.GBs = kbn.formatBuilders.decimalSIPrefix('Bs', 3);
kbn.valueFormats.Gbits = kbn.formatBuilders.decimalSIPrefix('bits', 3);
// Throughput
kbn.valueFormats.ops = kbn.formatBuilders.simpleCountUnit('ops');
kbn.valueFormats.rps = kbn.formatBuilders.simpleCountUnit('rps');
kbn.valueFormats.wps = kbn.formatBuilders.simpleCountUnit('wps');
kbn.valueFormats.iops = kbn.formatBuilders.simpleCountUnit('iops');
// Energy
kbn.valueFormats.watt = kbn.formatBuilders.decimalSIPrefix('W');
kbn.valueFormats.kwatt = kbn.formatBuilders.decimalSIPrefix('W', 1);
kbn.valueFormats.voltamp = kbn.formatBuilders.decimalSIPrefix('VA');
kbn.valueFormats.kvoltamp = kbn.formatBuilders.decimalSIPrefix('VA', 1);
kbn.valueFormats.voltampreact = kbn.formatBuilders.decimalSIPrefix('var');
kbn.valueFormats.watth = kbn.formatBuilders.decimalSIPrefix('Wh');
kbn.valueFormats.kwatth = kbn.formatBuilders.decimalSIPrefix('Wh', 1);
kbn.valueFormats.joule = kbn.formatBuilders.decimalSIPrefix('J');
kbn.valueFormats.ev = kbn.formatBuilders.decimalSIPrefix('eV');
kbn.valueFormats.amp = kbn.formatBuilders.decimalSIPrefix('A');
kbn.valueFormats.volt = kbn.formatBuilders.decimalSIPrefix('V');
// Temperature
kbn.valueFormats.celsius = kbn.formatBuilders.fixedUnit('C');
kbn.valueFormats.farenheit = kbn.formatBuilders.fixedUnit('F');
kbn.valueFormats.kelvin = kbn.formatBuilders.fixedUnit('K');
kbn.valueFormats.humidity = kbn.formatBuilders.fixedUnit('%H');
// Pressure
kbn.valueFormats.pressurembar = kbn.formatBuilders.fixedUnit('mbar');
kbn.valueFormats.pressurehpa = kbn.formatBuilders.fixedUnit('hPa');
kbn.valueFormats.pressurehg = kbn.formatBuilders.fixedUnit('"Hg');
kbn.valueFormats.pressurepsi = kbn.formatBuilders.scaledUnits(1000, [' psi', ' ksi', ' Mpsi']);
// Length
kbn.valueFormats.lengthm = kbn.formatBuilders.decimalSIPrefix('m');
kbn.valueFormats.lengthmm = kbn.formatBuilders.decimalSIPrefix('m', -1);
kbn.valueFormats.lengthkm = kbn.formatBuilders.decimalSIPrefix('m', 1);
kbn.valueFormats.lengthmi = kbn.formatBuilders.fixedUnit('mi');
// Velocity
kbn.valueFormats.velocityms = kbn.formatBuilders.fixedUnit('m/s');
kbn.valueFormats.velocitykmh = kbn.formatBuilders.fixedUnit('km/h');
kbn.valueFormats.velocitymph = kbn.formatBuilders.fixedUnit('mph');
kbn.valueFormats.velocityknot = kbn.formatBuilders.fixedUnit('kn');
// Volume
kbn.valueFormats.litre = kbn.formatBuilders.decimalSIPrefix('L');
kbn.valueFormats.mlitre = kbn.formatBuilders.decimalSIPrefix('L', -1);
kbn.valueFormats.m3 = kbn.formatBuilders.decimalSIPrefix('m3');
// Time
kbn.valueFormats.hertz = kbn.formatBuilders.decimalSIPrefix('Hz');
kbn.valueFormats.ms = function (size, decimals, scaledDecimals) {
    if (size === null) {
        return "";
    }
    if (Math.abs(size) < 1000) {
        return kbn.toFixed(size, decimals) + ' ms';
    }
    else if (Math.abs(size) < 60000) {
        // Less than 1 min
        return kbn.toFixedScaled(size / 1000, decimals, scaledDecimals, 3, ' s');
    }
    else if (Math.abs(size) < 3600000) {
        // Less than 1 hour, devide in minutes
        return kbn.toFixedScaled(size / 60000, decimals, scaledDecimals, 5, ' min');
    }
    else if (Math.abs(size) < 86400000) {
        // Less than one day, devide in hours
        return kbn.toFixedScaled(size / 3600000, decimals, scaledDecimals, 7, ' hour');
    }
    else if (Math.abs(size) < 31536000000) {
        // Less than one year, devide in days
        return kbn.toFixedScaled(size / 86400000, decimals, scaledDecimals, 8, ' day');
    }
    return kbn.toFixedScaled(size / 31536000000, decimals, scaledDecimals, 10, " year");
};
kbn.valueFormats.s = function (size, decimals, scaledDecimals) {
    if (size === null) {
        return "";
    }
    // Less than 1 s, devide in ns
    if (Math.abs(size) < 0.000001) {
        return kbn.toFixedScaled(size * 1e9, decimals, scaledDecimals - decimals, -9, ' ns');
    }
    // Less than 1 ms, devide in s
    if (Math.abs(size) < 0.001) {
        return kbn.toFixedScaled(size * 1e6, decimals, scaledDecimals - decimals, -6, ' s');
    }
    // Less than 1 second, devide in ms
    if (Math.abs(size) < 1) {
        return kbn.toFixedScaled(size * 1e3, decimals, scaledDecimals - decimals, -3, ' ms');
    }
    if (Math.abs(size) < 60) {
        return kbn.toFixed(size, decimals) + ' s';
    }
    else if (Math.abs(size) < 3600) {
        // Less than 1 hour, devide in minutes
        return kbn.toFixedScaled(size / 60, decimals, scaledDecimals, 1, ' min');
    }
    else if (Math.abs(size) < 86400) {
        // Less than one day, devide in hours
        return kbn.toFixedScaled(size / 3600, decimals, scaledDecimals, 4, ' hour');
    }
    else if (Math.abs(size) < 604800) {
        // Less than one week, devide in days
        return kbn.toFixedScaled(size / 86400, decimals, scaledDecimals, 5, ' day');
    }
    else if (Math.abs(size) < 31536000) {
        // Less than one year, devide in week
        return kbn.toFixedScaled(size / 604800, decimals, scaledDecimals, 6, ' week');
    }
    return kbn.toFixedScaled(size / 3.15569e7, decimals, scaledDecimals, 7, " year");
};
kbn.valueFormats['s'] = function (size, decimals, scaledDecimals) {
    if (size === null) {
        return "";
    }
    if (Math.abs(size) < 1000) {
        return kbn.toFixed(size, decimals) + ' s';
    }
    else if (Math.abs(size) < 1000000) {
        return kbn.toFixedScaled(size / 1000, decimals, scaledDecimals, 3, ' ms');
    }
    else {
        return kbn.toFixedScaled(size / 1000000, decimals, scaledDecimals, 6, ' s');
    }
};
kbn.valueFormats.ns = function (size, decimals, scaledDecimals) {
    if (size === null) {
        return "";
    }
    if (Math.abs(size) < 1000) {
        return kbn.toFixed(size, decimals) + ' ns';
    }
    else if (Math.abs(size) < 1000000) {
        return kbn.toFixedScaled(size / 1000, decimals, scaledDecimals, 3, ' s');
    }
    else if (Math.abs(size) < 1000000000) {
        return kbn.toFixedScaled(size / 1000000, decimals, scaledDecimals, 6, ' ms');
    }
    else if (Math.abs(size) < 60000000000) {
        return kbn.toFixedScaled(size / 1000000000, decimals, scaledDecimals, 9, ' s');
    }
    else {
        return kbn.toFixedScaled(size / 60000000000, decimals, scaledDecimals, 12, ' min');
    }
};
kbn.valueFormats.m = function (size, decimals, scaledDecimals) {
    if (size === null) {
        return "";
    }
    if (Math.abs(size) < 60) {
        return kbn.toFixed(size, decimals) + ' min';
    }
    else if (Math.abs(size) < 1440) {
        return kbn.toFixedScaled(size / 60, decimals, scaledDecimals, 2, ' hour');
    }
    else if (Math.abs(size) < 10080) {
        return kbn.toFixedScaled(size / 1440, decimals, scaledDecimals, 3, ' day');
    }
    else if (Math.abs(size) < 604800) {
        return kbn.toFixedScaled(size / 10080, decimals, scaledDecimals, 4, ' week');
    }
    else {
        return kbn.toFixedScaled(size / 5.25948e5, decimals, scaledDecimals, 5, ' year');
    }
};
kbn.valueFormats.h = function (size, decimals, scaledDecimals) {
    if (size === null) {
        return "";
    }
    if (Math.abs(size) < 24) {
        return kbn.toFixed(size, decimals) + ' hour';
    }
    else if (Math.abs(size) < 168) {
        return kbn.toFixedScaled(size / 24, decimals, scaledDecimals, 2, ' day');
    }
    else if (Math.abs(size) < 8760) {
        return kbn.toFixedScaled(size / 168, decimals, scaledDecimals, 3, ' week');
    }
    else {
        return kbn.toFixedScaled(size / 8760, decimals, scaledDecimals, 4, ' year');
    }
};
kbn.valueFormats.d = function (size, decimals, scaledDecimals) {
    if (size === null) {
        return "";
    }
    if (Math.abs(size) < 7) {
        return kbn.toFixed(size, decimals) + ' day';
    }
    else if (Math.abs(size) < 365) {
        return kbn.toFixedScaled(size / 7, decimals, scaledDecimals, 2, ' week');
    }
    else {
        return kbn.toFixedScaled(size / 365, decimals, scaledDecimals, 3, ' year');
    }
};
///// FORMAT MENU /////
kbn.getUnitFormats = function () {
    return [
        {
            text: 'none',
            submenu: [
                { text: 'none', value: 'none' },
                { text: 'short', value: 'short' },
                { text: 'percent (0-100)', value: 'percent' },
                { text: 'percent (0.0-1.0)', value: 'percentunit' },
                { text: 'Humidity (%H)', value: 'humidity' },
                { text: 'ppm', value: 'ppm' },
                { text: 'decibel', value: 'dB' },
            ]
        },
        {
            text: 'currency',
            submenu: [
                { text: 'Dollars ($)', value: 'currencyUSD' },
                { text: 'Pounds ()', value: 'currencyGBP' },
                { text: 'Euro ()', value: 'currencyEUR' },
                { text: 'Yen ()', value: 'currencyJPY' },
            ]
        },
        {
            text: 'time',
            submenu: [
                { text: 'Hertz (1/s)', value: 'hertz' },
                { text: 'nanoseconds (ns)', value: 'ns' },
                { text: 'microseconds (s)', value: 's' },
                { text: 'milliseconds (ms)', value: 'ms' },
                { text: 'seconds (s)', value: 's' },
                { text: 'minutes (m)', value: 'm' },
                { text: 'hours (h)', value: 'h' },
                { text: 'days (d)', value: 'd' },
            ]
        },
        {
            text: 'data',
            submenu: [
                { text: 'bits', value: 'bits' },
                { text: 'bytes', value: 'bytes' },
                { text: 'kilobytes', value: 'kbytes' },
                { text: 'megabytes', value: 'mbytes' },
                { text: 'gigabytes', value: 'gbytes' },
            ]
        },
        {
            text: 'data rate',
            submenu: [
                { text: 'packets/sec', value: 'pps' },
                { text: 'bits/sec', value: 'bps' },
                { text: 'bytes/sec', value: 'Bps' },
                { text: 'kilobits/sec', value: 'Kbits' },
                { text: 'kilobytes/sec', value: 'KBs' },
                { text: 'megabits/sec', value: 'Mbits' },
                { text: 'megabytes/sec', value: 'MBs' },
                { text: 'gigabytes/sec', value: 'GBs' },
                { text: 'gigabits/sec', value: 'Gbits' },
            ]
        },
        {
            text: 'throughput',
            submenu: [
                { text: 'ops/sec (ops)', value: 'ops' },
                { text: 'reads/sec (rps)', value: 'rps' },
                { text: 'writes/sec (wps)', value: 'wps' },
                { text: 'I/O ops/sec (iops)', value: 'iops' },
            ]
        },
        {
            text: 'length',
            submenu: [
                { text: 'millimetre (mm)', value: 'lengthmm' },
                { text: 'meter (m)', value: 'lengthm' },
                { text: 'kilometer (km)', value: 'lengthkm' },
                { text: 'mile (mi)', value: 'lengthmi' },
            ]
        },
        {
            text: 'velocity',
            submenu: [
                { text: 'm/s', value: 'velocityms' },
                { text: 'km/h', value: 'velocitykmh' },
                { text: 'mph', value: 'velocitymph' },
                { text: 'knot (kn)', value: 'velocityknot' },
            ]
        },
        {
            text: 'volume',
            submenu: [
                { text: 'millilitre', value: 'mlitre' },
                { text: 'litre', value: 'litre' },
                { text: 'cubic metre', value: 'm3' },
            ]
        },
        {
            text: 'energy',
            submenu: [
                { text: 'watt (W)', value: 'watt' },
                { text: 'kilowatt (kW)', value: 'kwatt' },
                { text: 'volt-ampere (VA)', value: 'voltamp' },
                { text: 'kilovolt-ampere (kVA)', value: 'kvoltamp' },
                { text: 'volt-ampere reactive (var)', value: 'voltampreact' },
                { text: 'watt-hour (Wh)', value: 'watth' },
                { text: 'kilowatt-hour (kWh)', value: 'kwatth' },
                { text: 'joule (J)', value: 'joule' },
                { text: 'electron volt (eV)', value: 'ev' },
                { text: 'Ampere (A)', value: 'amp' },
                { text: 'Volt (V)', value: 'volt' },
            ]
        },
        {
            text: 'temperature',
            submenu: [
                { text: 'Celcius (C)', value: 'celsius' },
                { text: 'Farenheit (F)', value: 'farenheit' },
                { text: 'Kelvin (K)', value: 'kelvin' },
            ]
        },
        {
            text: 'pressure',
            submenu: [
                { text: 'Millibars', value: 'pressurembar' },
                { text: 'Hectopascals', value: 'pressurehpa' },
                { text: 'Inches of mercury', value: 'pressurehg' },
                { text: 'PSI', value: 'pressurepsi' },
            ]
        }
    ];
};
/* harmony default export */ __webpack_exports__["default"] = (kbn);


/***/ })

},[457]);
//# sourceMappingURL=app.ade1f37ab7d5044b3fc7.js.map